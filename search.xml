<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/posts/0/"/>
      <url>/posts/0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ParamChecked</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gwall.wes.common.base.ParamChecked;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.gwall.wes.core..*.*(..)) &quot; +</span></span><br><span class="line"><span class="meta">            &quot;&amp;&amp; args(com.gwall.wes.common.base.ParamChecked,..)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointCut</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pointCut()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        <span class="keyword">for</span> (Object arg : args) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> ParamChecked) &#123;</span><br><span class="line">                ((ParamChecked) arg).check();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> List) &#123; <span class="comment">// 如果参数是 List 类型</span></span><br><span class="line">                List&lt;?&gt; list = (List&lt;?&gt;) arg;</span><br><span class="line">                <span class="keyword">for</span> (Object item : list) &#123;</span><br><span class="line">                    <span class="comment">// 检查列表中的每个元素是否是 ParamChecked 的实例</span></span><br><span class="line">                    <span class="keyword">if</span> (item <span class="keyword">instanceof</span> ParamChecked) &#123;</span><br><span class="line">                        ((ParamChecked) item).check();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gwall.common.commons.exception.BizException;</span><br><span class="line"><span class="keyword">import</span> com.gwall.common.commons.exception.Errors;</span><br><span class="line"><span class="keyword">import</span> com.gwall.wes.common.basic.errors.BizError;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Supplier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CheckUtil</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertTrue</span><span class="params">(<span class="type">boolean</span> bool, String error)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bool) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERROR, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertTrue</span><span class="params">(<span class="type">boolean</span> bool, BizException exception)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!bool) &#123;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertFalse</span><span class="params">(<span class="type">boolean</span> bool, String error)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bool) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERROR, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertFalse</span><span class="params">(<span class="type">boolean</span> bool, BizException exception)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (bool) &#123;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertGtZero</span><span class="params">(Integer obj, String error)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span> || obj &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERROR, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertGtZero</span><span class="params">(Long obj, String error)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span> || obj &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERROR, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertGtZero</span><span class="params">(BigDecimal obj, String error)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span> || obj.doubleValue() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERROR, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertGtZero</span><span class="params">(BigDecimal obj, Errors error)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span> || obj.doubleValue() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertGtZero</span><span class="params">(Double obj, String error)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span> || obj &lt;= <span class="number">0D</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERROR, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertGteZero</span><span class="params">(Integer obj, String error)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span> || obj &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERROR, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertGteZero</span><span class="params">(BigDecimal obj, String error)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span> || obj.doubleValue() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERROR, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertNotNull</span><span class="params">(Object obj, Errors error)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertNotNull</span><span class="params">(Object obj, String error)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERROR, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertNull</span><span class="params">(Object obj, String error)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERROR, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertEmpty</span><span class="params">(Collection&lt;?&gt; coll, String error)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (coll != <span class="literal">null</span> &amp;&amp; coll.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERROR, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertNotEmpty</span><span class="params">(Collection&lt;?&gt; coll, String error)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (coll == <span class="literal">null</span> || coll.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERROR, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertEmpty</span><span class="params">(Map&lt;?, ?&gt; map, String error)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span> &amp;&amp; map.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERROR, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertNotEmpty</span><span class="params">(Map&lt;?, ?&gt; map, String error)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map == <span class="literal">null</span> || map.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERROR, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertEmpty</span><span class="params">(String str, String error)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="literal">null</span> &amp;&amp; str.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERROR, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertNotEmpty</span><span class="params">(String str, String error)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERROR, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertNotEmpty</span><span class="params">(BigDecimal str, String error)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERROR, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertNotEmpty</span><span class="params">(String str, Errors error)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setDefault</span><span class="params">(Supplier&lt;String&gt; supplier, Consumer&lt;String&gt; consumer)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> supplier.get();</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            consumer.accept(StringUtils.EMPTY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">setDefault</span><span class="params">(Supplier&lt;T&gt; supplier, Consumer&lt;T&gt; consumer, T defaultValue)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> supplier.get();</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            consumer.accept(defaultValue);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            consumer.accept(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertNotEmpty</span><span class="params">(String str, Errors error, Object... params)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(error, params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertIntervalValid</span><span class="params">(Long begin, Long end, <span class="type">long</span> interval, String error)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (begin == <span class="literal">null</span> || end == <span class="literal">null</span> || end &lt; begin || (end - begin) &gt; interval) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERROR, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertIntegerZero</span><span class="params">(Integer obj, String error)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> != obj &amp;&amp; obj &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERROR, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertObjectLength</span><span class="params">(Object obj, <span class="type">int</span> length, String error)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == obj) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Number &amp;&amp; obj.toString().contains(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">//如果是数字类型包含小数点 截取整数位</span></span><br><span class="line">            obj = obj.toString().split(<span class="string">&quot;\\.&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj.toString().length() &gt; length) &#123;</span><br><span class="line">            <span class="keyword">if</span>(error.contains(<span class="string">&quot;&#123;0&#125;&quot;</span>))&#123;</span><br><span class="line">                error = error.replace(<span class="string">&quot;&#123;0&#125;&quot;</span>, String.valueOf(length));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAMES_ASSERT_TOO_LONG, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertStringLength</span><span class="params">(String data, <span class="type">int</span> maxLength, String desc)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isEmpty(data) || maxLength &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(data.length() &gt; maxLength) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.PARAM_ERROR, <span class="string">&quot;[&quot;</span> + desc + <span class="string">&quot;]数据过长，不能超过[&quot;</span> + maxLength + <span class="string">&quot;]位&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">assertBigDecimalLength</span><span class="params">(BigDecimal data, String desc)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">integerPartLength</span> <span class="operator">=</span> data.toPlainString().split(<span class="string">&quot;\\.&quot;</span>)[<span class="number">0</span>].length();</span><br><span class="line">            <span class="type">int</span> <span class="variable">decimalPartLength</span> <span class="operator">=</span> data.scale();</span><br><span class="line">            <span class="keyword">if</span> (integerPartLength &gt; <span class="number">9</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.QUANTITY_INTEGER_PART_OVER_RANGE, desc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (decimalPartLength &gt; <span class="number">6</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizException</span>(BizError.QUANTITY_DECIMAL_PART_OVER_RANGE, desc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getOrDefault</span><span class="params">(String source, String df)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> source == <span class="literal">null</span> ? df : source;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>项目总结</title>
      <link href="/posts/520508/"/>
      <url>/posts/520508/</url>
      
        <content type="html"><![CDATA[<h1 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h1><h2 id="AZKK工具社区"><a href="#AZKK工具社区" class="headerlink" title="AZKK工具社区"></a>AZKK工具社区</h2><p>知识共享社区，通过签到获得AZ币（Redis的BitMap实现），可以利用AZ币执行抽奖和抵扣支付金额，对接微信公众号鉴权，使用会话模型与策略模式对接各大模型集成AI对话，通过微信支付充值AI对话额度，针对支付全流程可能出现的异常情况使用SpringTask做补偿（1. 订单到期关闭补偿，当订单超时未支付将会将订单关闭 2. 未收到支付回调补偿，当订单超过一分钟未更新支付状态时会给向微信支付询问该支付单是否已经完成支付 3. 订单重新发货补偿，当订单已完成但未执行发货时做补偿），系统通过Nacos做注册中心、Dubbo进行服务间远程调用，Seata解决AZ币抵扣支付金额时的分布式事务问题</p><h3 id="AI对话服务"><a href="#AI对话服务" class="headerlink" title="AI对话服务"></a>AI对话服务</h3><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><ul><li>chatgpt-data-app：程序启动服务，定义各种配置信息</li><li>chatgpt-data-trigger：触发器层，提供消息接收、接口实现、任务执行等，相当于MVC结构中的Controller</li><li>chatgpt-data-domain：领域层，主要有<ul><li>weixin：微信领域，公众号验签与消息应答</li><li>auth：登录鉴权领域，校验code是否存在，生成token，解析token等</li><li>limiter：限流领域<ul><li>Guava单机限流：RateLimiter令牌桶，以固定时间间隔往里面放令牌，每次尝试取出一个许可，失败则拒绝</li><li>Redis分布式限流：简单的使用String结构初始化值为1，过期时间设置为指定的时间间隔，每次访问自增1，判断是否超过指定的访问次数，超过则拒绝 </li></ul></li><li>openai：openai对话领域<ul><li>规则校验：账户状态校验、模型类型校验、账户额度校验、访问次数限制（有额度不校验）、敏感词校验</li><li>AI流式对话： 策略模式定位到指定的大模型实现中执行对话，ResponseBodyEmitter流式返回</li></ul></li><li>order：订单领域：查询商品列表、创建更新订单、执行发货等</li></ul></li><li>chatgpt-data-infrastructure：基础层，由领域层定义仓储接口，基础层实现，是依赖倒置的关系</li><li>chatgpt-data-type：公共层，定义公共工具类、常量、异常处理、枚举等</li></ul><h4 id="微信公众号对接"><a href="#微信公众号对接" class="headerlink" title="微信公众号对接"></a>微信公众号对接</h4><blockquote><p>微信服务器签名验证（验证合法性）,验证逻辑是将token、timestamp、nonce三个参数进行字典序排序，然后拼装成一个字符串进行sha1加密，若结果跟signature相同则说明验签成功，将echostr返回</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理微信服务器发来的get请求，进行签名的验证</span></span><br><span class="line"><span class="comment">     * &lt;a href=&quot;http://apix.natapp1.cc/api/v1/wx/portal/wxad979c0307864a66&quot;&gt;http://apix.natapp1.cc/api/v1/wx/portal/wxad979c0307864a66&lt;/a&gt;</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * appid     微信端AppID</span></span><br><span class="line"><span class="comment">     * signature 微信端发来的签名</span></span><br><span class="line"><span class="comment">     * timestamp 微信端发来的时间戳</span></span><br><span class="line"><span class="comment">     * nonce     微信端发来的随机字符串</span></span><br><span class="line"><span class="comment">     * echostr   微信端发来的验证字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@GetMapping(produces = &quot;text/plain;charset=utf-8&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">validate</span><span class="params">(<span class="meta">@PathVariable(&quot;appid&quot;)</span> String appid,</span></span><br><span class="line"><span class="params">                       <span class="meta">@RequestParam(value = &quot;signature&quot;,required = false)</span> String signature,</span></span><br><span class="line"><span class="params">                       <span class="meta">@RequestParam(value = &quot;timestamp&quot;, required = false)</span> String timestamp,</span></span><br><span class="line"><span class="params">                       <span class="meta">@RequestParam(value = &quot;nonce&quot;, required = false)</span> String nonce,</span></span><br><span class="line"><span class="params">                       <span class="meta">@RequestParam(value = &quot;echostr&quot;, required = false)</span> String echostr)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//初步验证是否有属性为空</span></span><br><span class="line">        log.info(<span class="string">&quot;微信公众号验签信息&#123;&#125;开始 [&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;]&quot;</span>, appid, signature, timestamp, nonce, echostr);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isAnyBlank(signature,timestamp,nonce,echostr))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;请求参数非法，请核实!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">checkSign</span> <span class="operator">=</span> validateService.checkSign(signature, timestamp, nonce);</span><br><span class="line">        <span class="keyword">if</span> (!checkSign) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> echostr;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        log.error(<span class="string">&quot;微信公众号验签信息&#123;&#125;失败 [&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;]&quot;</span>, appid, signature, timestamp, nonce, echostr, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>公众号接收并处理用户信息，在项目中若用户在公众号发送的验证码为408则会随机构建4位code验证码，同时将openid与code的映射存入Guava缓存中，方便后续登录鉴权且为用户生成token</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">acceptUserBehavior</span><span class="params">(UserBehaviorMessageEntity userBehaviorMessage)</span> &#123;</span><br><span class="line">    <span class="comment">//如果消息为事件消息则不处理</span></span><br><span class="line">    <span class="keyword">if</span> (MsgTypeVO.EVENT.getCode().equals(userBehaviorMessage.getMsgType())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (MsgTypeVO.TEXT.getCode().equals(userBehaviorMessage.getMsgType())) &#123;</span><br><span class="line">        <span class="comment">//用户回复内容为408则处理，否则返回空</span></span><br><span class="line">        <span class="keyword">if</span> (userBehaviorMessage.getContent().equals(<span class="string">&quot;408&quot;</span>))&#123;</span><br><span class="line">            <span class="comment">//先从cache里面拿到code</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">isExitCode</span> <span class="operator">=</span> codeCache.getIfPresent(userBehaviorMessage.getOpenid());</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(isExitCode)) &#123;</span><br><span class="line">                <span class="comment">//如果cache中拿不到code</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> RandomStringUtils.randomNumeric(<span class="number">4</span>);</span><br><span class="line">                <span class="comment">//将两个映射关系存入cache</span></span><br><span class="line">                codeCache.put(userBehaviorMessage.getOpenid(), code);</span><br><span class="line">                codeCache.put(code, userBehaviorMessage.getOpenid());</span><br><span class="line">                isExitCode = code;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//构建消息实体</span></span><br><span class="line">            <span class="type">MessageTextEntity</span> <span class="variable">messageText</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageTextEntity</span>();</span><br><span class="line">            messageText.setFromUserName(originalId);</span><br><span class="line">            messageText.setCreateTime(String.valueOf(System.currentTimeMillis() / <span class="number">1000L</span>));</span><br><span class="line">            messageText.setMsgType(<span class="string">&quot;text&quot;</span>);</span><br><span class="line">            messageText.setToUserName(userBehaviorMessage.getOpenid());</span><br><span class="line">            messageText.setContent(String.format(<span class="string">&quot;您的验证码为：%s 有效期%d分钟！&quot;</span>, isExitCode, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> XmlUtil.beanToXml(messageText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ChatGPTException</span>(userBehaviorMessage.getMsgType()+<span class="string">&quot; 未支持处理的行为类型 Err!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="登录鉴权"><a href="#登录鉴权" class="headerlink" title="登录鉴权"></a>登录鉴权</h4><ol><li><p>验证code是否存在，存在则构建验证信息，将缓存中code与openid映射关系去除</p></li><li><p>验证成功，生成token，openid作为负载，base64加密返回</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> AuthStateEntity <span class="title function_">doLogin</span><span class="params">(String code)</span> &#123;</span><br><span class="line">    <span class="comment">//初步验证，若code不为4位有效数字字符串直接return</span></span><br><span class="line">    <span class="keyword">if</span> (!code.matches(<span class="string">&quot;\\d&#123;4&#125;&quot;</span>))&#123;</span><br><span class="line">        log.info(<span class="string">&quot;鉴权，用户输入的验证码无效&#123;&#125;&quot;</span>,code);</span><br><span class="line">        <span class="keyword">return</span> AuthStateEntity.builder()</span><br><span class="line">            .code(AuthTypeVO.A0002.getCode())</span><br><span class="line">            .info(AuthTypeVO.A0002.getInfo())</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">AuthStateEntity</span> <span class="variable">authStateEntity</span> <span class="operator">=</span> <span class="built_in">this</span>.checkCode(code);</span><br><span class="line">    <span class="keyword">if</span> (!authStateEntity.getCode().equals(AuthTypeVO.A0000.getCode()))&#123;</span><br><span class="line">        <span class="comment">//鉴权不成功直接返回</span></span><br><span class="line">        <span class="keyword">return</span> authStateEntity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成token返回</span></span><br><span class="line">    HashMap&lt;String,Object&gt; chaim=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    chaim.put(<span class="string">&quot;openId&quot;</span>,authStateEntity.getOpenId());</span><br><span class="line">    String token=encode(authStateEntity.getOpenId(),<span class="number">7</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000L</span>,chaim);</span><br><span class="line">    authStateEntity.setToken(token);</span><br><span class="line">    <span class="keyword">return</span> authStateEntity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> AuthStateEntity <span class="title function_">checkCode</span><span class="params">(String code)</span> &#123;</span><br><span class="line">    <span class="comment">//从cache中取得openid</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">openId</span> <span class="operator">=</span> codeCache.getIfPresent(code);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(openId))&#123;</span><br><span class="line">        log.info(<span class="string">&quot;鉴权，用户输入的验证码不存在 &#123;&#125;&quot;</span>, code);</span><br><span class="line">        <span class="keyword">return</span> AuthStateEntity.builder()</span><br><span class="line">            .code(AuthTypeVO.A0001.getCode())</span><br><span class="line">            .info(AuthTypeVO.A0001.getInfo())</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//鉴权成功，删除cache内容</span></span><br><span class="line">    codeCache.invalidate(code);</span><br><span class="line">    codeCache.invalidate(openId);</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;鉴权成功，用户输入的验证码 &#123;&#125;&quot;</span>, code);</span><br><span class="line">    <span class="keyword">return</span> AuthStateEntity.builder()</span><br><span class="line">        .code(AuthTypeVO.A0000.getCode())</span><br><span class="line">        .info(AuthTypeVO.A0000.getInfo())</span><br><span class="line">        .openId(openId)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> String <span class="title function_">encode</span><span class="params">(String issuer, <span class="type">long</span> ttlMillis, HashMap&lt;String, Object&gt; chaim)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (chaim==<span class="literal">null</span>)&#123;</span><br><span class="line">        chaim=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="variable">nowMills</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    JwtBuilder builder= Jwts.builder()</span><br><span class="line">        <span class="comment">//荷载部分</span></span><br><span class="line">        .setClaims(chaim)</span><br><span class="line">        <span class="comment">//这个是JWT的唯一标识，一般设置成唯一的，这个方法可以生成唯一标识</span></span><br><span class="line">        .setId(UUID.randomUUID().toString())</span><br><span class="line">        <span class="comment">//签发人，也就是JWT是给谁的（逻辑上一般都是username或者userId）</span></span><br><span class="line">        .setIssuer(issuer)</span><br><span class="line">        <span class="comment">//签发时间</span></span><br><span class="line">        .setIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>(nowMills))</span><br><span class="line">        <span class="comment">//使用算法与密钥生成jwt</span></span><br><span class="line">        .signWith(SignatureAlgorithm.HS256,base64EncodedSecretKey);</span><br><span class="line">    <span class="keyword">if</span> (ttlMillis&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//设置过期时间</span></span><br><span class="line">        <span class="type">long</span> expireTime=ttlMillis+nowMills;</span><br><span class="line">        builder.setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(expireTime));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成token并返回</span></span><br><span class="line">    <span class="keyword">return</span> builder.compact();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="流式对话"><a href="#流式对话" class="headerlink" title="流式对话"></a>流式对话</h4><h5 id="对话前校验"><a href="#对话前校验" class="headerlink" title="对话前校验"></a>对话前校验</h5><blockquote><ol><li>token是否有效校验；2. 限流（频率）校验； 3. 执行对话</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 基础配置；流式输出、编码、禁用缓存</span></span><br><span class="line">    response.setContentType(<span class="string">&quot;text/event-stream&quot;</span>);</span><br><span class="line">    response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    response.setHeader(<span class="string">&quot;Cache-Control&quot;</span>, <span class="string">&quot;no-cache&quot;</span>);</span><br><span class="line">    <span class="comment">// 2. 构建异步响应对象</span></span><br><span class="line">    <span class="type">ResponseBodyEmitter</span> <span class="variable">emitter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResponseBodyEmitter</span>(<span class="number">3</span> * <span class="number">60</span> * <span class="number">1000L</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【对 Token 过期拦截】</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> authService.checkToken(token);</span><br><span class="line">    <span class="keyword">if</span> (!success)&#123;</span><br><span class="line">        <span class="comment">//校验token失败，token失效</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            emitter.send(Constants.ResponseCode.TOKEN_ERROR.getCode());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        emitter.complete();</span><br><span class="line">        <span class="keyword">return</span> emitter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.查看response状态,是否访问频率过快</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">isMostVisited</span> <span class="operator">=</span> response.getHeader(MOST_VISITED.getCode());</span><br><span class="line">    <span class="keyword">if</span>(isMostVisited!=<span class="literal">null</span>&amp;&amp;isMostVisited.equals(MOST_VISITED.getInfo()))&#123;</span><br><span class="line">        response.setHeader(MOST_VISITED.getCode(), <span class="string">&quot;&quot;</span>);</span><br><span class="line">        emitter.send(MOST_VISITED.getInfo());</span><br><span class="line">        emitter.complete();</span><br><span class="line">        <span class="keyword">return</span> emitter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 获取 OpenID</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">openId</span> <span class="operator">=</span> authService.getOpenId(token);</span><br><span class="line">    log.info(<span class="string">&quot;流式问答请求处理，openid:&#123;&#125; 请求模型:&#123;&#125;&quot;</span>, openId, request.getModel());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.构建参数</span></span><br><span class="line">    <span class="type">ChatProcessAggregate</span> <span class="variable">chatProcess</span> <span class="operator">=</span> ChatProcessAggregate.builder()</span><br><span class="line">        .model(request.getModel())</span><br><span class="line">        .openid(openId)</span><br><span class="line">        .messages(request.getMessages().stream()</span><br><span class="line">                  .map(entity -&gt; MessageEntity.builder()</span><br><span class="line">                       .role(entity.getRole())</span><br><span class="line">                       .content(entity.getContent())</span><br><span class="line">                       .name(entity.getName()).build())</span><br><span class="line">                  .collect(Collectors.toList()))</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">//6.执行问答</span></span><br><span class="line">    <span class="keyword">return</span> chatService.completions(emitter,chatProcess);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;流式应答，请求模型：&#123;&#125; 发生异常&quot;</span>, request.getModel(), e);</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ChatGPTException</span>(e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="执行对话"><a href="#执行对话" class="headerlink" title="执行对话"></a>执行对话</h5><ol><li>规则校验领域：<ol><li>账户状态校验（是否可用）；</li><li>模型类型校验（当前账户是否支持该模型）；</li><li>用户额度校验（是否有额度可以执行对话）；</li><li>访问次数校验（用户每天有固定免费访问次数，当账户不为空且有额度时不受访问次数限制）</li><li>敏感词校验（采用敏感词校验库给用户输入内容做敏感词捕捉并做无害化转换）</li></ol></li><li>通过规则校验后，根据选用的模型类型从策略模式构建的map中得到对应的模型实现，执行对话</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    emitter.onCompletion(() -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">&quot;流式问答请求完成，使用模型:&#123;&#125;&quot;</span>, chatProcess.getModel());</span><br><span class="line">    &#125;);</span><br><span class="line">    emitter.onError(throwable -&gt; log.error(<span class="string">&quot;流式问答请求异常，使用模型：&#123;&#125;&quot;</span>, chatProcess.getModel(), throwable));</span><br><span class="line">    <span class="comment">//获取用户账户信息</span></span><br><span class="line">    <span class="type">UserAccountEntity</span> <span class="variable">userAccount</span> <span class="operator">=</span> openAiRepository.queryUserAccount(chatProcess.getOpenid());</span><br><span class="line">    <span class="comment">//规则过滤,传入进行过滤的模式列表</span></span><br><span class="line">    RuleLogicEntity&lt;ChatProcessAggregate&gt; ruleLogicEntity = <span class="built_in">this</span>.doCheckLogic(chatProcess, userAccount,</span><br><span class="line">                                                                              <span class="literal">null</span> != userAccount ? DefaultLogicFactory.LogicModel.ACCOUNT_STATUS.getCode() : DefaultLogicFactory.LogicModel.NULL.getCode(),</span><br><span class="line">                                                                              <span class="literal">null</span> != userAccount ? DefaultLogicFactory.LogicModel.MODEL_TYPE.getCode() : DefaultLogicFactory.LogicModel.NULL.getCode(),</span><br><span class="line">                                                                              <span class="literal">null</span> != userAccount ? DefaultLogicFactory.LogicModel.USER_QUOTA.getCode() : DefaultLogicFactory.LogicModel.NULL.getCode(),</span><br><span class="line">                                                                              DefaultLogicFactory.LogicModel.ACCESS_LIMIT.getCode(),</span><br><span class="line">                                                                              DefaultLogicFactory.LogicModel.SENSITIVE_WORD.getCode()</span><br><span class="line"></span><br><span class="line">                                                                             );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!LogicCheckTypeVO.SUCCESS.equals(ruleLogicEntity.getType())) &#123;</span><br><span class="line">        emitter.send(ruleLogicEntity.getInfo());</span><br><span class="line">        emitter.complete();</span><br><span class="line">        <span class="keyword">return</span> emitter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理问答</span></span><br><span class="line">    <span class="type">OpenAIChannel</span> <span class="variable">channel</span> <span class="operator">=</span> chatProcess.getChannel();</span><br><span class="line">    <span class="keyword">if</span> (channel==<span class="literal">null</span>)&#123;</span><br><span class="line">        emitter.send(<span class="string">&quot;暂未支持&quot;</span>+chatProcess.getModel()+<span class="string">&quot;模型！！&quot;</span>);</span><br><span class="line">        emitter.complete();</span><br><span class="line">        <span class="keyword">return</span> emitter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">OpenAIGroupService</span> <span class="variable">openAIService</span> <span class="operator">=</span> openAIGroup.get(channel);</span><br><span class="line">    openAIService.doMessageResponse(ruleLogicEntity.getData(), emitter);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ChatGPTException</span>(Constants.ResponseCode.UN_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> emitter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="大模型SDK"><a href="#大模型SDK" class="headerlink" title="大模型SDK"></a>大模型SDK</h4><p>对接大模型SDK采用的是会话模型，细节上使⽤OKHttp3与retrofit2 框架完成模型对接，通过工厂屏蔽使用细节，简化接口调用，像mybatis也是运用了这种结构，底层只有查和改两种操作（增删改都是改），但是通过会话工厂包装会话，提供增删改查四个接口，简化了接口调用，也方便用户调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Configuration</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">apiHost</span> <span class="operator">=</span> <span class="string">&quot;https://open.bigmodel.cn/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 智普Ai https://open.bigmodel.cn/usercenter/apikeys - apiSecretKey = &#123;apiKey&#125;.&#123;apiSecret&#125;</span></span><br><span class="line">    <span class="keyword">private</span> String apiSecretKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String apiKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String apiSecret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将apiSecretKey拆分获得apiKey &amp; apiSecret</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> apiSecretKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApiSecretKey</span><span class="params">(String apiSecretKey)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.apiSecretKey=apiSecretKey;</span><br><span class="line">        String[] keyAndSecret = apiSecretKey.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (keyAndSecret.length!=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;invalid apiSecretKey&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.apiKey=keyAndSecret[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">this</span>.apiSecret=keyAndSecret[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IOpenAiApi openAiApi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> OkHttpClient okHttpClient;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建请求的长连接</span></span><br><span class="line">    <span class="keyword">public</span> EventSource.Factory <span class="title function_">createRequestFactory</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EventSources.createFactory(okHttpClient);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> HttpLoggingInterceptor.Level level=HttpLoggingInterceptor.Level.HEADERS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">connectTimeout</span> <span class="operator">=</span> <span class="number">450</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">writeTimeout</span> <span class="operator">=</span> <span class="number">450</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">readTimeout</span> <span class="operator">=</span> <span class="number">450</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// http keywords</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SSE_CONTENT_TYPE</span> <span class="operator">=</span> <span class="string">&quot;text/event-stream&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DEFAULT_USER_AGENT</span> <span class="operator">=</span> <span class="string">&quot;Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">APPLICATION_JSON</span> <span class="operator">=</span> <span class="string">&quot;application/json&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">JSON_CONTENT_TYPE</span> <span class="operator">=</span> APPLICATION_JSON + <span class="string">&quot;; charset=utf-8&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> OpenAiSession <span class="title function_">openSession</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//1.日志配置</span></span><br><span class="line">    HttpLoggingInterceptor httpLoggingInterceptor=<span class="keyword">new</span> <span class="title class_">HttpLoggingInterceptor</span>();</span><br><span class="line">    httpLoggingInterceptor.setLevel(configuration.getLevel());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.开启http客户端</span></span><br><span class="line">    OkHttpClient okHttpClient=<span class="keyword">new</span> <span class="title class_">OkHttpClient</span></span><br><span class="line">        .Builder()</span><br><span class="line">        .addInterceptor(httpLoggingInterceptor)</span><br><span class="line">        .addInterceptor(<span class="keyword">new</span> <span class="title class_">OpenAiHTTPInterceptor</span>(configuration))</span><br><span class="line">        .readTimeout(configuration.getReadTimeout(), TimeUnit.SECONDS)</span><br><span class="line">        .writeTimeout(configuration.getWriteTimeout(),TimeUnit.SECONDS)</span><br><span class="line">        .connectTimeout(configuration.getConnectTimeout(),TimeUnit.SECONDS)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    configuration.setOkHttpClient(okHttpClient);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.创建API服务</span></span><br><span class="line">    IOpenAiApi openAiApi=<span class="keyword">new</span> <span class="title class_">Retrofit</span>.Builder()</span><br><span class="line">        .baseUrl(configuration.getApiHost())</span><br><span class="line">        .client(okHttpClient)</span><br><span class="line">        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</span><br><span class="line">        .addConverterFactory(JacksonConverterFactory.create())</span><br><span class="line">        .build().create(IOpenAiApi.class);</span><br><span class="line"></span><br><span class="line">    configuration.setOpenAiApi(openAiApi);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultOpenAiSession</span>(configuration);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultOpenAiSession</span> <span class="keyword">implements</span> <span class="title class_">OpenAiSession</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * OpenAi 配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工厂事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventSource.Factory factory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DefaultOpenAiSession</span><span class="params">(Configuration configuration)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.configuration = configuration;</span><br><span class="line">        <span class="built_in">this</span>.factory=configuration.createRequestFactory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> EventSource <span class="title function_">completions</span><span class="params">(ChatCompletionRequest chatCompletionRequest, EventSourceListener eventSourceListener)</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line">        <span class="comment">//构建请求</span></span><br><span class="line">        Request request=<span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">                .url(configuration.getApiHost().concat(IOpenAiApi.v3_completions).replace(<span class="string">&quot;&#123;model&#125;&quot;</span>,chatCompletionRequest.getModel().getCode()))</span><br><span class="line">                .post(RequestBody.create(MediaType.parse(<span class="string">&quot;application/json&quot;</span>),chatCompletionRequest.toString())).build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> factory.newEventSource(request,eventSourceListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">completions</span><span class="params">(ChatCompletionRequest chatCompletionRequest)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">        <span class="comment">// 用于执行异步任务并获取结果</span></span><br><span class="line">        CompletableFuture&lt;String&gt; future=<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">        StringBuffer dataBuffer=<span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">        <span class="comment">//构建请求</span></span><br><span class="line">        Request request=<span class="keyword">new</span> <span class="title class_">Request</span>.Builder()</span><br><span class="line">                .url(configuration.getApiHost().concat(IOpenAiApi.v3_completions).replace(<span class="string">&quot;&#123;model&#125;&quot;</span>,chatCompletionRequest.getModel().getCode()))</span><br><span class="line">                .post(RequestBody.create(MediaType.parse(<span class="string">&quot;application/json&quot;</span>),chatCompletionRequest.toString())).build();</span><br><span class="line">        <span class="comment">// 异步响应请求</span></span><br><span class="line">        factory.newEventSource(request, <span class="keyword">new</span> <span class="title class_">EventSourceListener</span>() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onEvent</span><span class="params">(EventSource eventSource, <span class="meta">@Nullable</span> String id, <span class="meta">@Nullable</span> String type, String data)</span> &#123;</span><br><span class="line">                <span class="comment">//将Json格式的结果转化为类对象</span></span><br><span class="line">                <span class="type">ChatCompletionResponse</span> <span class="variable">response</span> <span class="operator">=</span> JSON.parseObject(data, ChatCompletionResponse.class);</span><br><span class="line">                <span class="keyword">if</span> (EventType.add.getCode().equals(type))&#123;</span><br><span class="line">                    dataBuffer.append(response.getData());</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (EventType.finish.getCode().equals(type))&#123;</span><br><span class="line">                    future.complete(dataBuffer.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClosed</span><span class="params">(EventSource eventSource)</span> &#123;</span><br><span class="line">                future.completeExceptionally(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Request closed before completion&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFailure</span><span class="params">(EventSource eventSource, <span class="meta">@Nullable</span> Throwable t, <span class="meta">@Nullable</span> Response response)</span> &#123;</span><br><span class="line">                future.completeExceptionally(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Request closed before completion&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：yml中配置模型的配置信息，包装成对应的Configuration对话，交给对应的工厂开启会话，其实工厂做的事情也是包装Configuration里面的OkHttpClient客户端、IOpenAiApi服务等等，最后把Configuration交给会话使得会话可以通过这些信息执行操作</p><h4 id="订单支付"><a href="#订单支付" class="headerlink" title="订单支付"></a>订单支付</h4><h5 id="创建订单"><a href="#创建订单" class="headerlink" title="创建订单"></a>创建订单</h5><ol><li>校验token是否有效</li><li>若用户选择使用AZ币抵扣支付金额，则会通过Dubbo远程调用得到用户当前AZ币数量，再得到优惠金额</li><li>包装购物车，将商品ID、openid、用户ID、优惠金额等等包装成购物车实体</li><li>判断同个购物车下是否有未支付的订单，有则返回，无则判断商品是否有效，创建订单，再调用蓝兔支付获取支付单，写入并返回</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板方法定义用户下单流程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shopCarEntity 简单购物车</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 支付单实体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PayOrderEntity <span class="title function_">createOrder</span><span class="params">(ShopCarEntity shopCarEntity)</span> <span class="keyword">throws</span> AlipayApiException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//0.获取购物车信息，商品与用户</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">openid</span> <span class="operator">=</span> shopCarEntity.getOpenid();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">productId</span> <span class="operator">=</span> shopCarEntity.getProductId();</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">discountAmount</span> <span class="operator">=</span> shopCarEntity.getDiscountAmount();</span><br><span class="line">        <span class="type">String</span> <span class="variable">userId</span> <span class="operator">=</span> shopCarEntity.getUserId();</span><br><span class="line">        <span class="comment">//获取是否未支付的订单</span></span><br><span class="line">        UnpaidOrderEntity unpaidOrder=orderRepository.queryUnpaidOrder(shopCarEntity);</span><br><span class="line">        <span class="keyword">if</span> (unpaidOrder!=<span class="literal">null</span>&amp;&amp;PayStatusVO.WAIT.equals(unpaidOrder.getPayStatus())&amp;&amp;</span><br><span class="line">            unpaidOrder.getPayUrl()!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//有等待支付的有效订单切有相应的payUrl,直接返回</span></span><br><span class="line">            log.info(<span class="string">&quot;创建订单-存在，已生成支付宝支付，返回 openid: &#123;&#125; orderId: &#123;&#125; payUrl: &#123;&#125;&quot;</span>, openid, unpaidOrder.getOrderId(), unpaidOrder.getPayUrl());</span><br><span class="line">            <span class="keyword">return</span> PayOrderEntity.builder()</span><br><span class="line">                .orderId(unpaidOrder.getOrderId())</span><br><span class="line">                .payStatus(unpaidOrder.getPayStatus())</span><br><span class="line">                .openid(openid)</span><br><span class="line">                .payUrl(unpaidOrder.getPayUrl()).build();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (unpaidOrder!=<span class="literal">null</span>&amp;&amp;unpaidOrder.getPayUrl()==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//没有相应的支付地址</span></span><br><span class="line">            log.info(<span class="string">&quot;创建订单-存在，未生成支付宝支付，返回 openid: &#123;&#125; orderId: &#123;&#125;&quot;</span>, openid, unpaidOrder.getOrderId());</span><br><span class="line">            PayOrderEntity payOrderEntity=<span class="built_in">this</span>.doPrepayOrder(openid,unpaidOrder.getOrderId(),</span><br><span class="line">                                                             unpaidOrder.getProductName(),unpaidOrder.getTotalAmount());</span><br><span class="line">            log.info(<span class="string">&quot;创建订单-完成，已生成支付宝支付，返回 openid: &#123;&#125; orderId: &#123;&#125; payUrl: &#123;&#125;&quot;</span>, openid, unpaidOrder.getOrderId(), unpaidOrder.getPayUrl());</span><br><span class="line">            <span class="keyword">return</span> payOrderEntity;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有未支付的订单 1.查询商品信息</span></span><br><span class="line">        ProductEntity productEntity=orderRepository.queryProduct(productId);</span><br><span class="line">        <span class="keyword">if</span> (!productEntity.isAvailable()) &#123;</span><br><span class="line">            <span class="comment">//商品无效</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ChatGPTException</span>(Constants.ResponseCode.ORDER_PRODUCT_ERR.getCode(), Constants.ResponseCode.ORDER_PRODUCT_ERR.getInfo());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2.新建订单并保存</span></span><br><span class="line">        OrderEntity orderEntity=<span class="built_in">this</span>.doSaveOrder(shopCarEntity,productEntity);</span><br><span class="line">        <span class="comment">//3.创建支付，与订单入库没法做事务，由定时任务补偿,注意总价需要减去优惠金额</span></span><br><span class="line">        <span class="type">PayOrderEntity</span> <span class="variable">payOrderEntity</span> <span class="operator">=</span> doPrepayOrder(openid, orderEntity.getOrderId(), productEntity.getProductName(),</span><br><span class="line">                                                      orderEntity.getTotalAmount().subtract(discountAmount).setScale(<span class="number">2</span>,BigDecimal.ROUND_HALF_UP));</span><br><span class="line">        log.info(<span class="string">&quot;创建订单-完成，生成支付单。openid: &#123;&#125; orderId: &#123;&#125; payUrl: &#123;&#125;&quot;</span>, openid, orderEntity.getOrderId(), payOrderEntity.getPayUrl());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> payOrderEntity;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        log.info(<span class="string">&quot;创建订单-失败。openid: &#123;&#125; productId:&#123;&#125;&quot;</span>, shopCarEntity.getOpenid(),shopCarEntity.getProductId());</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ChatGPTException</span>(Constants.ResponseCode.UN_ERROR.getCode(), Constants.ResponseCode.UN_ERROR.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> PayOrderEntity <span class="title function_">doPrepayOrder</span><span class="params">(String openid, String orderId, String productName, BigDecimal totalAmount)</span> <span class="keyword">throws</span> AlipayApiException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 策略服务可以根据类型动态选择,这里写死,后续可更换传参形式</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">payUrl</span> <span class="operator">=</span> payGroup.get(PayChannel.LTPay).createPayUrl(orderId, productName, totalAmount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建支付单</span></span><br><span class="line">    <span class="type">PayOrderEntity</span> <span class="variable">payOrderEntity</span> <span class="operator">=</span> PayOrderEntity.builder()</span><br><span class="line">        .payUrl(payUrl)</span><br><span class="line">        .payStatus(PayStatusVO.WAIT)</span><br><span class="line">        .openid(openid)</span><br><span class="line">        .orderId(orderId)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">//更新订单支付信息</span></span><br><span class="line">    orderRepository.updateOrderPayInfo(payOrderEntity);</span><br><span class="line">    <span class="keyword">return</span> payOrderEntity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="支付回调"><a href="#支付回调" class="headerlink" title="支付回调"></a>支付回调</h5><ol><li>更新订单支付状态</li><li>发送EventBus消息推送</li><li>job监听消息执行发货：判断订单是否使用了AZ币抵扣，有则远程调用扣减AZ币，最后给账户添加额度</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deliverGoods</span><span class="params">(String orderId)</span> &#123;</span><br><span class="line">    <span class="type">OrderEntity</span> <span class="variable">orderEntity</span> <span class="operator">=</span> orderRepository.queryDiscountOrder(orderId);</span><br><span class="line">    <span class="keyword">if</span> (orderEntity!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//用户使用优惠且未发货订单</span></span><br><span class="line">        log.info(<span class="string">&quot;远程调用扣减用户AZ币：用户ID：&#123;&#125; AZ币：&#123;&#125;&quot;</span>,orderEntity.getUserId());</span><br><span class="line">        <span class="type">boolean</span> subAzCoins= userRpcService.subAzCoins(orderEntity.getDiscountAmount()</span><br><span class="line">        .multiply(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="number">10</span>)).setScale(<span class="number">2</span>, RoundingMode.HALF_UP).doubleValue(),</span><br><span class="line">        orderEntity.getUserId());</span><br><span class="line">        <span class="keyword">if</span> (!subAzCoins)&#123;</span><br><span class="line">        log.error(<span class="string">&quot;远程调用扣减用户AZ币失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    orderRepository.deliverGoods(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LuckyAZ"><a href="#LuckyAZ" class="headerlink" title="LuckyAZ"></a>LuckyAZ</h2><p><img src= "/img/loading.gif" data-src="https://qiniu.azkk.top/typora/image-20240404194902266.png" alt="image-20240404194902266"></p><h3 id="lottery-rpc"><a href="#lottery-rpc" class="headerlink" title="lottery-rpc"></a>lottery-rpc</h3><blockquote><p>提供rpc接口信息，调用方通过rpc调用时需要引入的jar包</p></blockquote><ul><li>指定活动抽奖：用户指定了活动ID执行抽奖</li><li>量化人群执行抽奖：量化物料通过组合模式路由到对应的活动ID，执行抽奖</li></ul><h3 id="lottery-interfaces"><a href="#lottery-interfaces" class="headerlink" title="lottery-interfaces"></a>lottery-interfaces</h3><blockquote><p>应用启动与配置，实现rpc接口</p></blockquote><h3 id="lottery-application"><a href="#lottery-application" class="headerlink" title="lottery-application"></a>lottery-application</h3><blockquote><p>应用层，进行领域的编排</p></blockquote><ul><li>执行抽奖<ul><li>活动领取（第一次领取则发送MQ扣减活动库存）</li><li>通过活动策略执行抽奖，包装中奖信息</li><li>抽奖结果落库</li><li>MQ发送通知触发发奖流程，返回中奖结果</li></ul></li><li>量化人群：根据决策物料调用规则过滤引擎得到对应的活动</li><li>MQ消息（设置setConfirmCallback消息到达MQ之后设置发货单MQ发送状态为已发送，同时依靠xxl-job定时扫描发货单，若MQ状态未发送则执行重发补偿，同时关闭MQ的自动ack，在消费者也就是执行完发奖之后再手动返回ack，并且在数据库中设计了防重字段保证消息消费幂等性，也就是说不会重复消费，活动领取uuid设计为用户ID加上活动ID加上已领取次数，发奖uuid单纯使用订单ID做防重）<ul><li>初次领取活动会发送MQ消息执行活动库存扣减</li><li>发奖工厂获取相应发奖实例执行发奖</li></ul></li><li>xxl-job任务调度<ul><li>扫描审核通过的活动，活动时间到更换为活动中</li><li>活动中的活动到期关闭</li><li>MQ消息发送失败补偿</li></ul></li></ul><h3 id="lottery-domain"><a href="#lottery-domain" class="headerlink" title="lottery-domain"></a>lottery-domain</h3><h4 id="activity：活动领域–状态模式"><a href="#activity：活动领域–状态模式" class="headerlink" title="activity：活动领域–状态模式"></a>activity：活动领域–状态模式</h4><ul><li><p>活动配置：全流程事务控制，有一个失败则rollback</p><p>​                    包括活动信息（活动ID、名称、描述、开始结束时间、库存、每人可参与次数、状态、对应的策略ID）</p><p>​                    奖品信息（奖品ID、奖品类型–优惠券/实物等、奖品名称、奖品内容）</p><p>​                    策略信息（策略ID、策略描述、策略算法、发奖方式、发奖文案等）</p><p>​                    策略详情（策略ID、奖品ID、奖品名称、奖品库存、奖品剩余库存、中奖概率）</p></li><li><p>活动状态流转：状态模式（对于所有修改状态的操作来说其实对于每个状态都是存在的，只是有些操作针对当前状态来说无权修改，所以针对每个状态定义实现类实现操作接口，有无权力执行修改状态操作由自身实现类实现，我们无需关心，只需要根据当前状态调用状态实现类的操作即可）</p><blockquote><p>定义抽象类AbstractState：包括所有状态操作(提审、通过、拒绝、撤审、关闭、开启、进行中) </p><p>针对每一个状态定义一个状态实现类，继承AbstractState，作为当前状态执行各状态操作的 结果，若当前状态不可执行操作则返回，否则执行状态转换操作。 </p><p>定义配置类StateConfig：初始化状态与对应状态实现类的对应关系的Map集合stateGroup </p><p>IStateHandler接口：状态处理接口，定义所有状态操作接口 </p><p>StateHandlerImpl实现类：继承StateConfig，实现IStateHandler接口，从stateGroup中获 得当前状态对应的状态实现类，执行相应的操作，不用关心当前状态是否可以执行此操作， 在状态实现类中已经有相应的处理，这样让我们不必在业务逻辑中做if-else来判断但概念状 态是否可以执行相应的操作，造成逻辑混乱且不易修改和扩展。</p></blockquote></li><li><p>活动领取：</p><ul><li><p>若有已领取未执行活动单则直接返回</p></li><li><p>校验活动状态、活动库存、日期是否有效、个人参与次数等</p></li><li><p>扣减活动库存——！！这里针对热门活动领取采用分段竞态锁来缩小锁的的粒度，防止超卖</p><p>也就是每次进来扣减一次当前库存，判断是否超过了活动库存，超过恢复原始库存，扣减成功用setnx给活动的当前库存加锁，加锁失败恢复，也就是不针对活动加独占锁，而是针对活动的某个库存加锁，细化锁的粒度，当执行完活动领取后记得将锁释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> StockResult <span class="title function_">subtractionActivityStockByRedis</span><span class="params">(String uId, Long activityId, Integer stockCount)</span> &#123;</span><br><span class="line">    <span class="comment">//获取活动key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">stockKey</span> <span class="operator">=</span> Constants.RedisKey.KEY_LOTTERY_ACTIVITY_STOCK_COUNT(activityId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扣减库存，已使用库存+1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">stockUsedCount</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(stockKey, <span class="number">1</span>).intValue();</span><br><span class="line">    <span class="keyword">if</span> (stockUsedCount &gt; stockCount)&#123;</span><br><span class="line">        <span class="comment">//超出库存,恢复原始库存</span></span><br><span class="line">        stringRedisTemplate.opsForValue().decrement(stockKey,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StockResult</span>(Constants.ResponseCode.OUT_OF_STOCK.getCode(),Constants.ResponseCode.OUT_OF_STOCK.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//扣减成功，以活动库存编号，生成对应的加锁key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">stockTokenKey</span> <span class="operator">=</span> Constants.RedisKey.KEY_LOTTERY_ACTIVITY_STOCK_COUNT_TOKEN(activityId, stockUsedCount);</span><br><span class="line">    <span class="comment">//使用setnx加一个分布式锁并设置过期时间，以便其他线程也可以竞争锁</span></span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">lockToken</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(stockTokenKey, <span class="string">&quot;1&quot;</span>, <span class="number">350L</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    <span class="keyword">if</span> (Boolean.FALSE.equals(lockToken))&#123;</span><br><span class="line">        <span class="comment">//加锁失败</span></span><br><span class="line">        stringRedisTemplate.opsForValue().decrement(stockKey,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StockResult</span>(Constants.ResponseCode.ERR_TOKEN.getCode(),Constants.ResponseCode.ERR_TOKEN.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StockResult</span>(Constants.ResponseCode.SUCCESS.getCode(),Constants.ResponseCode.SUCCESS.getInfo()</span><br><span class="line">                           ,stockTokenKey,stockCount - stockUsedCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>扣减活动库存成功，添加活动领取记录、扣减个人参与次数</p><ul><li><p>编程式事务，多个执行SQL，使用分库分表时会涉及多个数据源切换，注解式的事务不起作用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Result <span class="title function_">grabActivity</span><span class="params">(PartakeReq req, ActivityBillVO bill, Long takeId)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        dbRouter.doRouter(req.getUId());</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 编程式事务，多个执行SQL，使用分库分表时会涉及多个数据源切换，注解式的事务不起作用</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">return</span> transactionTemplate.execute(status-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//扣减个人参与次数</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> userTakeActivityRepository.subtractionLeftCount(bill.getActivityId(), bill.getActivityName(),</span><br><span class="line">                                                                            bill.getTakeCount(), bill.getUserTakeLeftCount(), req.getUId(), req.getPartakeTime());</span><br><span class="line">                <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//扣减失败,回滚</span></span><br><span class="line">                    status.setRollbackOnly();</span><br><span class="line">                    logger.info(<span class="string">&quot;领取活动，扣减个人剩余参与次数失败 activityId:&#123;&#125; uId:&#123;&#125;&quot;</span>, req.getActivityId(), req.getUId());</span><br><span class="line">                    <span class="keyword">return</span> Result.buildResult(Constants.ResponseCode.NO_UPDATE);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//添加活动记录</span></span><br><span class="line">                <span class="comment">//                    int count1 =</span></span><br><span class="line">                userTakeActivityRepository.takeActivity(req.getUId(), bill.getStrategyId(),bill.getActivityId(), bill.getActivityName(),</span><br><span class="line">                                                        bill.getUserTakeLeftCount(), bill.getTakeCount(), req.getPartakeTime(), takeId);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (DuplicateKeyException e)&#123;</span><br><span class="line">                status.setRollbackOnly();</span><br><span class="line">                logger.error(<span class="string">&quot;领取活动，唯一索引冲突 activityId：&#123;&#125; uId：&#123;&#125;&quot;</span>, req.getActivityId(), req.getUId(), e);</span><br><span class="line">                <span class="keyword">return</span> Result.buildResult(Constants.ResponseCode.INDEX_DUP);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Result.buildSuccessResult();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        dbRouter.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>释放锁，返回领取结果</p></li></ul></li></ul><h4 id="rule：规则引擎领域–组合模式"><a href="#rule：规则引擎领域–组合模式" class="headerlink" title="rule：规则引擎领域–组合模式"></a>rule：规则引擎领域–组合模式</h4><blockquote><p>量化人群得到活动ID</p></blockquote><ul><li><p>节点规则过滤：针对当前节点，遍历从这个节点出发的链路，根据决策物料与链路条件比较得到下一个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Long <span class="title function_">filter</span><span class="params">(String matterValue, List&lt;TreeNodeLineVO&gt; treeNodeLineVOList)</span> &#123;</span><br><span class="line">    <span class="comment">//遍历节点每一个链路，找到符合条件的下一个节点</span></span><br><span class="line">    <span class="keyword">for</span> (TreeNodeLineVO treeNodeLineVO : treeNodeLineVOList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (decisionLogic(matterValue,treeNodeLineVO))&#123;</span><br><span class="line">            <span class="keyword">return</span> treeNodeLineVO.getNodeIdTo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//空节点</span></span><br><span class="line">    <span class="keyword">return</span> Constants.Global.TREE_NULL_NODE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">decisionLogic</span><span class="params">(String matterValue,TreeNodeLineVO treeNodeLineVO)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (treeNodeLineVO.getRuleLimitType())&#123;</span><br><span class="line">        <span class="keyword">case</span> Constants.RuleLimitType.EQUAL:</span><br><span class="line">            <span class="keyword">return</span> matterValue.equals(treeNodeLineVO.getRuleLimitValue());</span><br><span class="line">        <span class="keyword">case</span> Constants.RuleLimitType.GT:</span><br><span class="line">            <span class="keyword">return</span>  Double.parseDouble(matterValue) &gt; Double.parseDouble(treeNodeLineVO.getRuleLimitValue());</span><br><span class="line">        <span class="keyword">case</span> Constants.RuleLimitType.LT:</span><br><span class="line">            <span class="keyword">return</span>  Double.parseDouble(matterValue) &lt; Double.parseDouble(treeNodeLineVO.getRuleLimitValue());</span><br><span class="line">        <span class="keyword">case</span> Constants.RuleLimitType.GE:</span><br><span class="line">            <span class="keyword">return</span>  Double.parseDouble(matterValue) &gt;= Double.parseDouble(treeNodeLineVO.getRuleLimitValue());</span><br><span class="line">        <span class="keyword">case</span> Constants.RuleLimitType.LE:</span><br><span class="line">            <span class="keyword">return</span>  Double.parseDouble(matterValue) &lt;= Double.parseDouble(treeNodeLineVO.getRuleLimitValue());</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>规则引擎</p><ul><li><p>获取规则树聚合信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> EngineResult <span class="title function_">process</span><span class="params">(DecisionMatterReq req)</span> &#123;</span><br><span class="line">    <span class="comment">//获取规则树聚合信息</span></span><br><span class="line">    <span class="type">TreeRuleRich</span> <span class="variable">treeRuleRich</span> <span class="operator">=</span> ruleRepository.queryTreeRuleRich(req.getTreeId());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (treeRuleRich==<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Tree Rule is Null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据决策物料和规则树聚合信息找到对应的果实活动</span></span><br><span class="line">    <span class="type">TreeNodeVO</span> <span class="variable">treeNodeVO</span> <span class="operator">=</span> engineDecisionMaker(treeRuleRich, req);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EngineResult</span>(req.getUserId(),req.getTreeId(),treeNodeVO.getTreeNodeId(), treeNodeVO.getNodeValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从根节点出发执行规则过滤直到果实节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据决策物料和规则树聚合信息找到对应的果实活动</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> treeRuleRich 规则树聚合信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req  决策物料</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  果实活动节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">protected</span> TreeNodeVO <span class="title function_">engineDecisionMaker</span><span class="params">(TreeRuleRich treeRuleRich, DecisionMatterReq req)</span> &#123;</span><br><span class="line">    <span class="comment">//获取头节点</span></span><br><span class="line">    <span class="type">TreeRootVO</span> <span class="variable">treeRoot</span> <span class="operator">=</span> treeRuleRich.getTreeRoot();</span><br><span class="line">    <span class="comment">//获取节点与旗下链路对应关系的Map</span></span><br><span class="line">    Map&lt;Long, TreeNodeVO&gt; treeNodeMap = treeRuleRich.getTreeNodeMap();</span><br><span class="line">    <span class="comment">//树根ID</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">rootId</span> <span class="operator">=</span> treeRoot.getTreeRootNodeId();</span><br><span class="line">    <span class="comment">//得到树根节点的详细信息</span></span><br><span class="line">    <span class="type">TreeNodeVO</span> <span class="variable">treeNodeVO</span> <span class="operator">=</span> treeNodeMap.get(rootId);</span><br><span class="line">    <span class="comment">//当treeNodeVO为树茎时继续往下查找</span></span><br><span class="line">    <span class="keyword">while</span>(Constants.NodeType.STEM.equals(treeNodeVO.getNodeType()))&#123;</span><br><span class="line">        <span class="comment">//得到路由关键词</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">ruleKey</span> <span class="operator">=</span> treeNodeVO.getRuleKey();</span><br><span class="line">        <span class="comment">//获取对应的规则</span></span><br><span class="line">        <span class="type">LogicFilter</span> <span class="variable">logicFilter</span> <span class="operator">=</span> logicFilterMap.get(ruleKey);</span><br><span class="line">        <span class="comment">//根据获得的规则渠道对应的决策物料</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">matterValue</span> <span class="operator">=</span> logicFilter.matterValue(req);</span><br><span class="line">        <span class="comment">//执行找到下一个节点ID</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">nextNodeId</span> <span class="operator">=</span> logicFilter.filter(matterValue, treeNodeVO.getTreeNodeLineVOList());</span><br><span class="line">        treeNodeVO = treeNodeMap.get(nextNodeId);</span><br><span class="line">        logger.info(<span class="string">&quot;决策树引擎=&gt;&#123;&#125; userId：&#123;&#125; treeId：&#123;&#125; treeNode：&#123;&#125; ruleKey：&#123;&#125; matterValue：&#123;&#125;&quot;</span>,</span><br><span class="line">                    treeRoot.getTreeName(), req.getUserId(), req.getTreeId(),</span><br><span class="line">                    treeNodeVO.getTreeNodeId(), ruleKey, matterValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> treeNodeVO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="strategy：策略领域–策略、模板模式"><a href="#strategy：策略领域–策略、模板模式" class="headerlink" title="strategy：策略领域–策略、模板模式"></a>strategy：策略领域–策略、模板模式</h4><blockquote><p>根据策略算法执行抽奖得到奖品</p></blockquote><ul><li>根据策略ID获取抽奖策略</li><li>校验抽奖策略是否已经初始化到内存（总体概率无需先初始化到内存，因为抽奖概率随着奖品库存而改变，需要实时计算）<ul><li>单项概率：根据奖品概率将概率100%划分为几个部分，分别对其进行斐波那契散列定位到散列数组的某个位置，存放对应的奖品ID，这样执行抽奖时只需要对随机数进行斐波那契散列，取出对应位置的奖品ID即可</li></ul></li><li>获取不在抽奖范围内的奖品列表，包括库存为0、风控策略、临时调整等</li><li>策略模式调用对应策略算法执行抽奖<ul><li>单项概率：取出初始化到内存的对应策略的斐波那契散列数组，只需要对随机数进行斐波那契散列，取出对应位置的奖品ID即可，当奖品在排除的集合内，返回未中奖</li><li>总体概率：<ul><li>遍历策略下所有奖品信息，得到有效奖品集合与有效奖品总概率</li><li>遍历有效奖品集合，当前奖品概率除以有效奖品总概率就是真正的奖品概率，当随机数在当前奖品概率下，返回奖品ID</li></ul></li></ul></li><li>扣减奖品库存，包装中奖信息返回</li></ul><h4 id="award：发奖领域–简单工厂模式"><a href="#award：发奖领域–简单工厂模式" class="headerlink" title="award：发奖领域–简单工厂模式"></a>award：发奖领域–简单工厂模式</h4><blockquote><p>简单工厂模式：由工厂类来负责创建实例的过程，如果具体产品之间有功能的逻辑或，我们就必须把这些共同的东西提取出来，放在一个抽象类中，然后让具体产品继承抽象类，工厂根据传入参数返回不同 对象的实例。</p></blockquote><p>关于 award 发奖领域中主要的核心实现在于 service 中的两块功能逻辑实现，分别是： goods 商品处理 、 factory 工厂</p><ul><li><p>goods商品处理主要有：定义抽象类实现方法更改订单发货状态，不同发奖类型先执行自身逻辑，再调用更改发货状态</p><blockquote><p>接口类IDistributionGoods：抽象出doDistribution()接口作为发奖处理 </p><p>抽象类DistributionBase：提供商品处理的公共方法，供具体处理类继承 </p><p>N个实现类：继承DistributionBase抽象类，实现IDistributionGoods接口，为具体商品处理 类</p></blockquote></li><li><p>factory工厂：将不同发奖逻辑根据类型映射到Map中，后续通过工厂取出对应的发奖实现</p><blockquote><p>GoodsConfig配置类：定义awardType与商品处理类的对应关系，形成Map集合 </p><p>DistributionGoodsFactory工厂类：根据传入的awardType参数值返回不同的商品处理实例对象</p></blockquote></li></ul><p>在处理发奖业务时，只需要将奖品的类型awardType传入工厂类，即可获得与其对应的实现类实例对 象，执行相应的方法即可，避免逻辑混乱，使功能更加清晰易于扩展和维护，将创建者和具体的产品逻 辑解耦，满足单一职责</p><h3 id="lottery-infrastructure"><a href="#lottery-infrastructure" class="headerlink" title="lottery-infrastructure"></a>lottery-infrastructure</h3><blockquote><p>基础层，由领域层定义仓储接口，基础层实现，是依赖倒置的关系</p></blockquote><h3 id="lottery-common："><a href="#lottery-common：" class="headerlink" title="lottery-common："></a>lottery-common：</h3><blockquote><p>公共层，定义公共工具类、常量、异常处理、枚举等</p></blockquote><h2 id="DB-Router分库分表"><a href="#DB-Router分库分表" class="headerlink" title="DB-Router分库分表"></a>DB-Router分库分表</h2><h3 id="读取配置信息配置数据源"><a href="#读取配置信息配置数据源" class="headerlink" title="读取配置信息配置数据源"></a>读取配置信息配置数据源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据源配置提取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> environment 环境上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEnvironment</span><span class="params">(Environment environment)</span> &#123;</span><br><span class="line">    <span class="comment">//获取配置的前缀,方便定位yml中配置信息</span></span><br><span class="line">    String prefix=<span class="string">&quot;router.jdbc.datasource.&quot;</span>;</span><br><span class="line">    <span class="comment">//获取yml配置文件中设置的分库分表数量</span></span><br><span class="line">    dbCount=Integer.valueOf(environment.getProperty(prefix+<span class="string">&quot;dbCount&quot;</span>));</span><br><span class="line">    tbCount=Integer.valueOf(environment.getProperty(prefix+<span class="string">&quot;tbCount&quot;</span>));</span><br><span class="line">    routerKey= environment.getProperty(prefix+<span class="string">&quot;routerKey&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取数据源列表</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">datasources</span> <span class="operator">=</span> environment.getProperty(prefix + <span class="string">&quot;list&quot;</span>);</span><br><span class="line">    <span class="comment">//当数据源为null时中断</span></span><br><span class="line">    <span class="keyword">assert</span> datasources!=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (String dataInfo: datasources.split(<span class="string">&quot;,&quot;</span>))&#123;</span><br><span class="line">        <span class="comment">//通过“,”分割数据源列表，获取配置信息，存入数据源配置组</span></span><br><span class="line">        Map&lt;String,Object&gt; dataSourceProps = PropertyUtil.handle(environment, prefix + dataInfo, Map.class);</span><br><span class="line">        dataSourceMap.put(dataInfo,dataSourceProps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//默认数据源</span></span><br><span class="line">    String defaultData=environment.getProperty(prefix+<span class="string">&quot;default&quot;</span>);</span><br><span class="line">    defaultDataSourceConfig=PropertyUtil.handle(environment,prefix+defaultData,Map.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 动态数据源获取</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//创建数据源</span></span><br><span class="line">    Map&lt;Object,Object&gt; targetDataSources=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//遍历dataSourceMap获得每一个数据源配置信息</span></span><br><span class="line">    <span class="keyword">for</span> (String dataInfo : dataSourceMap.keySet()) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; objMap = dataSourceMap.get(dataInfo);</span><br><span class="line">        <span class="comment">//根据数据源配置信息创建数据源</span></span><br><span class="line">        targetDataSources.put(dataInfo,</span><br><span class="line">                              <span class="keyword">new</span> <span class="title class_">DriverManagerDataSource</span>(objMap.get(<span class="string">&quot;url&quot;</span>).toString()</span><br><span class="line">                                                          ,objMap.get(<span class="string">&quot;username&quot;</span>).toString(),objMap.get(<span class="string">&quot;password&quot;</span>).toString()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置数据源，DynamicDataSource用于动态获取数据源，所以先存入</span></span><br><span class="line">    DynamicDataSource dynamicDataSource=<span class="keyword">new</span> <span class="title class_">DynamicDataSource</span>();</span><br><span class="line">    <span class="comment">//设置动态数据源</span></span><br><span class="line">    dynamicDataSource.setTargetDataSources(targetDataSources);</span><br><span class="line">    <span class="comment">//设置默认数据源</span></span><br><span class="line">    dynamicDataSource.setDefaultTargetDataSource(<span class="keyword">new</span> <span class="title class_">DriverManagerDataSource</span>(</span><br><span class="line">        defaultDataSourceConfig.get(<span class="string">&quot;url&quot;</span>).toString(),</span><br><span class="line">        defaultDataSourceConfig.get(<span class="string">&quot;username&quot;</span>).toString(),</span><br><span class="line">        defaultDataSourceConfig.get(<span class="string">&quot;password&quot;</span>).toString()</span><br><span class="line">    ));</span><br><span class="line">    <span class="keyword">return</span> dynamicDataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事务管理器"><a href="#事务管理器" class="headerlink" title="事务管理器"></a>事务管理器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置事务模板</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> TransactionTemplate <span class="title function_">transactionTemplate</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">    <span class="comment">//配置事务管理器，设置数据源</span></span><br><span class="line">    DataSourceTransactionManager dataSourceTransactionManager=<span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">    dataSourceTransactionManager.setDataSource(dataSource);</span><br><span class="line"></span><br><span class="line">    TransactionTemplate transactionTemplate=<span class="keyword">new</span> <span class="title class_">TransactionTemplate</span>();</span><br><span class="line">    transactionTemplate.setTransactionManager(dataSourceTransactionManager);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定传播行为，&quot;PROPAGATION_REQUIRED&quot;表示若当前存在事务，则加入事务，若不存在则新建事务</span></span><br><span class="line">    transactionTemplate.setPropagationBehaviorName(<span class="string">&quot;PROPAGATION_REQUIRED&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> transactionTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doRouter</span><span class="params">(String dbKeyAttr)</span> &#123;</span><br><span class="line">    <span class="comment">//hash桶的长度</span></span><br><span class="line">    <span class="type">int</span> size=dbRouterConfig.getDbCount()* dbRouterConfig.getTbCount();</span><br><span class="line">    <span class="comment">//设置扰动函数，使散列更加均匀，将hash值右移16位之后与本身做异或操作，再与（长度-1）相与使其落在hash桶上</span></span><br><span class="line">    <span class="type">int</span> idx=(size-<span class="number">1</span>)&amp;(dbKeyAttr.hashCode() ^ (dbKeyAttr.hashCode()&gt;&gt;&gt;<span class="number">16</span>));</span><br><span class="line">    <span class="comment">//每一个对idx都可以找到对应哪个库哪个表</span></span><br><span class="line">    <span class="comment">//对应库的索引等于idx除以分表的数量</span></span><br><span class="line">    <span class="type">int</span> dbIdx=idx / dbRouterConfig.getTbCount() +<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//对应表的索引等于idx- 前一个库的所有表</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">tbIdx</span> <span class="operator">=</span> idx - dbRouterConfig.getTbCount() * (dbIdx - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//将当前库表索引存入ThreadLocal</span></span><br><span class="line">    DBContextHolder.setDbKey(String.format(<span class="string">&quot;%02d&quot;</span>,dbIdx));</span><br><span class="line">    DBContextHolder.setTbKey(String.format(<span class="string">&quot;%03d&quot;</span>,tbIdx));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义DBRouter注解实现分库"><a href="#自定义DBRouter注解实现分库" class="headerlink" title="自定义DBRouter注解实现分库"></a>自定义DBRouter注解实现分库</h3><ul><li>切面逻辑：取出路由字段，为空则使用配置信息中指定的字段，得到路由字段的值执行路由策略</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;aopPoint()&amp;&amp;@annotation(dbRouter)&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">doRouter</span><span class="params">(ProceedingJoinPoint pj, DBRouter dbRouter)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="comment">//路由字段</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">dbKey</span> <span class="operator">=</span> dbRouter.key();</span><br><span class="line">    <span class="comment">//如果路由字段为空</span></span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(dbKey) &amp;&amp; StringUtils.isBlank(dbRouterConfig.getRouterKey()))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;annotation DBRouter key is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dbKey = StringUtils.isNotBlank(dbKey) ? dbKey : dbRouterConfig.getRouterKey();</span><br><span class="line">    <span class="comment">//获取路由属性,pj.getArgs()获取方法参数，进而获取参数对象的属性</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">dbKeyAttr</span> <span class="operator">=</span> getAttrValue(dbKey,pj.getArgs());</span><br><span class="line">    <span class="comment">//执行路由策略</span></span><br><span class="line">    dbRouterStrategy.doRouter(dbKeyAttr);</span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pj.proceed();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        dbRouterStrategy.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>动态数据源切换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicDataSource</span> <span class="keyword">extends</span> <span class="title class_">AbstractRoutingDataSource</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">determineCurrentLookupKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;db&quot;</span> + DBContextHolder.getDbKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义DBRouterStrategy实现分表"><a href="#自定义DBRouterStrategy实现分表" class="headerlink" title="自定义DBRouterStrategy实现分表"></a>自定义DBRouterStrategy实现分表</h3><p><strong>采用<code>MyBatis Plugin StatementHandler</code>实现对SQL语句的拦截与修改</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> AZ</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> Mybatis拦截器，通过对SQL语句的拦截处理，修改分表信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/8/10 16:19</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Intercepts</span> 标识该类是一个拦截器；</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Signature</span> 指明自定义拦截器需要拦截哪一个类型，哪一个方法；</span></span><br><span class="line"><span class="comment"> * - type：上述四种类型中的一种；</span></span><br><span class="line"><span class="comment"> * - method：对应接口中的哪类方法（因为可能存在重载方法）；</span></span><br><span class="line"><span class="comment"> * - args：对应哪一个方法的入参；</span></span><br><span class="line"><span class="comment"> * 1.Executor：拦截执行器的方法。</span></span><br><span class="line"><span class="comment"> * 2.ParameterHandler：拦截参数的处理。</span></span><br><span class="line"><span class="comment"> * 3.ResultHandler：拦截结果集的处理。</span></span><br><span class="line"><span class="comment"> * 4.StatementHandler：拦截Sql语法构建的处理。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Intercepts(@Signature(type = StatementHandler.class,method = &quot;prepare&quot;,args = &#123;Connection.class,Integer.class&#125;))</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicMybatisPlugin</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建了一个正则表达式的模式 `Pattern`，用于匹配 SQL 语句中的表名。该正则表达式可以匹配 `from`、`into` 或者 `update` 后面的表名。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;(from|into|update)[\\s]&#123;1,&#125;(\\w&#123;1,&#125;)&quot;</span>, Pattern.CASE_INSENSITIVE);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">//获取StatementHandler</span></span><br><span class="line">        <span class="type">StatementHandler</span> <span class="variable">statementHandler</span> <span class="operator">=</span> (StatementHandler) invocation.getTarget();</span><br><span class="line">        <span class="comment">//通过 `MetaObject` 获取`statementHandler` 对象的反射内容，方便后续对其属性进行操作</span></span><br><span class="line">        MetaObject metaObject=MetaObject.forObject(statementHandler, SystemMetaObject.DEFAULT_OBJECT_FACTORY,SystemMetaObject.DEFAULT_OBJECT_WRAPPER_FACTORY,<span class="keyword">new</span> <span class="title class_">DefaultReflectorFactory</span>());</span><br><span class="line">        <span class="comment">//获取MetaObject中&quot;delegate.mappedStatement&quot;属性值，即当前执行SQL语句的详细信息</span></span><br><span class="line">        <span class="type">MappedStatement</span> <span class="variable">mappedStatement</span> <span class="operator">=</span> (MappedStatement) metaObject.getValue(<span class="string">&quot;delegate.mappedStatement&quot;</span>);</span><br><span class="line">        <span class="comment">//获取类路径,如cn.az.middleware.db.router.DBContextHolder</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> mappedStatement.getId();</span><br><span class="line">        <span class="comment">//根据类路径获取类名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> id.substring(<span class="number">0</span>, id.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">        <span class="comment">//反射获得类信息</span></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">        <span class="comment">//获取DBRouterStrategy注解信息</span></span><br><span class="line">        <span class="type">DBRouterStrategy</span> <span class="variable">dbRouterStrategy</span> <span class="operator">=</span> clazz.getAnnotation(DBRouterStrategy.class);</span><br><span class="line">        <span class="keyword">if</span>(dbRouterStrategy==<span class="literal">null</span>|| !dbRouterStrategy.spiltTable())&#123;</span><br><span class="line">            <span class="comment">//如果没有这个注解或者注解中是否分表的字段为否，直接放行</span></span><br><span class="line">            <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取SQL</span></span><br><span class="line">        <span class="type">BoundSql</span> <span class="variable">boundSql</span> <span class="operator">=</span> statementHandler.getBoundSql();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> boundSql.getSql();</span><br><span class="line">        <span class="comment">//获取表名并替换，例：user -&gt; user03</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(sql);</span><br><span class="line">        <span class="type">String</span> <span class="variable">tableName</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (matcher.find()) &#123;</span><br><span class="line">            tableName = matcher.group().trim();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">assert</span> tableName!=<span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//替换表名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">replaceSql</span> <span class="operator">=</span> matcher.replaceAll(tableName + <span class="string">&quot;_&quot;</span> + DBContextHolder.getTbKey());</span><br><span class="line">        <span class="comment">//通过反射修改sql语句</span></span><br><span class="line">        Field field=boundSql.getClass().getDeclaredField(<span class="string">&quot;sql&quot;</span>);</span><br><span class="line">        <span class="comment">//开启操作字段的权限</span></span><br><span class="line">        field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        field.set(boundSql,replaceSql);</span><br><span class="line">        field.setAccessible(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//放行</span></span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目经历 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目经历 </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Acwing算法基础班</title>
      <link href="/posts/520501/"/>
      <url>/posts/520501/</url>
      
        <content type="html"><![CDATA[<h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a><a href="#基础算法" title="基础算法"></a>基础算法</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><a href="#快速排序" title="快速排序"></a>快速排序</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>,x = q[l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>];<span class="comment">//注意是向上取整,因为向下取整可能使得x取到q[l]</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, i - <span class="number">1</span>), <span class="built_in">quick_sort</span>(q, i, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用j做划分，就不能从右边开始。用i做划分，就不能从左边开始；</span></span><br></pre></td></tr></table></figure><p>快排时间复杂度nlogn，最坏情况可能到达n*n</p><p>i 等于 j 或者 j 比 i 小（模拟3 1 2 4 5 就行）</p><p>快排有很多边界情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[r];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r); <span class="comment">// 当x等于q[r]时，不能用j 和 j + 1，不能会无限循环，例如（1 2），就会一直quick_sort(q,0,1);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i = l - <span class="number">1</span>, j = r + <span class="number">1</span>, x = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) <span class="built_in">swap</span>(q[i], q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l,i), <span class="built_in">quick_sort</span>(q, j + <span class="number">1</span>, r); <span class="comment">//j 不可以改成 i ，这样会无限循环，试试模拟（241 164 60 291 67 67 196 260），会发现291和260一直换来换去，无限下去</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x = q[l + r &gt;&gt; <span class="number">1</span>],i = l - <span class="number">1</span>,j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i ++ ;<span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j -- ;<span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) <span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(q,l,j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,j + <span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(q,<span class="number">0</span>,n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">100010</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] q = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l - <span class="number">1</span>,j = r + <span class="number">1</span>,mid = q[l + r &gt;&gt; <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">do</span> i ++; <span class="keyword">while</span>(q[i] &lt; mid);</span><br><span class="line">            <span class="keyword">do</span> j --; <span class="keyword">while</span>(q[j] &gt; mid);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> q[i];</span><br><span class="line">                q[i] = q[j];</span><br><span class="line">                q[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        quickSort(l,j);</span><br><span class="line">        quickSort(j + <span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i ++) q[i] = sc.nextInt();</span><br><span class="line">        quickSort(<span class="number">0</span>,n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i ++) System.out.printf(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a><a href="#二分法" title="二分法"></a>二分法</h3><p>1：找大于等于数的第一个位置 （满足某个条件的第一个数）q[mid] &gt;= x<br>2：找小于等于数的最后一个数 （满足某个条件的最后一个数）q[mid] &lt;= x</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>,r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(q[mid] &gt;= x) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q[l] != x) cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            l = <span class="number">0</span>,r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(q[mid] &lt;= x) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">100010</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] binary = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">binaryQuery</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>,r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(binary[mid] &gt;= x) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(binary[l] != x) System.out.println(<span class="string">&quot;-1 -1&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d &quot;</span>,l);</span><br><span class="line">            l = <span class="number">0</span>;</span><br><span class="line">            r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(binary[mid] &lt;= x) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%d\n&quot;</span>,l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">q</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i ++) binary[i] = sc.nextInt();</span><br><span class="line">        <span class="keyword">while</span>(q -- != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            binaryQuery(x,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a><a href="#高精度加法" title="高精度加法"></a>高精度加法</h3><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A,vector&lt;<span class="type">int</span>&gt; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(B.<span class="built_in">size</span>() &gt; A.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="built_in">add</span>(B,A);</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; A.<span class="built_in">size</span>();i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A,B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    C = <span class="built_in">add</span>(A,B);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        List&lt;Integer&gt; A = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; B = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --) A.add(a.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b.length() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --) B.add(b.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; C = add(A,B);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> C.size() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --) System.out.print(C.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">add</span><span class="params">(List&lt;Integer&gt; A,List&lt;Integer&gt; B)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; C = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; A.size() || i &lt; B.size();i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; A.size()) t += A.get(i);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; B.size()) t += B.get(i);</span><br><span class="line">            </span><br><span class="line">            C.add(t % <span class="number">10</span>);</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t &gt; <span class="number">0</span>) C.add(t);</span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a><a href="#高精度减法" title="高精度减法"></a>高精度减法</h3><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A,vector&lt;<span class="type">int</span>&gt; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --)</span><br><span class="line">        <span class="keyword">if</span>(A[i] != B[i]) </span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A,vector&lt;<span class="type">int</span>&gt; B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; A.<span class="built_in">size</span>();i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(t &gt;= <span class="number">0</span>) t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A,B;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(A,B) == <span class="literal">true</span>) C = <span class="built_in">sub</span>(A,B);</span><br><span class="line">    <span class="keyword">else</span> C = <span class="built_in">sub</span>(B,A),cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; A = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; B = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --) A.add(a.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b.length() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --) B.add(b.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; C;</span><br><span class="line">        <span class="keyword">if</span>(Compare(A,B)) C = sub(A,B);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            C = sub(B,A);</span><br><span class="line">            System.out.print(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> C.size() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --) System.out.print(C.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">Compare</span><span class="params">(List&lt;Integer&gt; A,List&lt;Integer&gt; B)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.size() != B.size()) <span class="keyword">return</span> A.size() &gt; B.size();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(A.size() == B.size())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> A.size() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --)</span><br><span class="line">                <span class="keyword">if</span>(A.get(i) != B.get(i))</span><br><span class="line">                    <span class="keyword">return</span> A.get(i) &gt; B.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">sub</span><span class="params">(List&lt;Integer&gt; A,List&lt;Integer&gt; B)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; C = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; A.size();i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            t += A.get(i);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; B.size()) t -= B.get(i);</span><br><span class="line">            </span><br><span class="line">            C.add((t + <span class="number">10</span>) % <span class="number">10</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(t &lt; <span class="number">0</span>) t = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(C.size() &gt; <span class="number">1</span> &amp;&amp; C.get(C.size() - <span class="number">1</span>) == <span class="number">0</span>) C.remove(C.size() - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a><a href="#高精度乘法" title="高精度乘法"></a>高精度乘法</h3><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; A,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; A.<span class="built_in">size</span>();i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(t) C.<span class="built_in">push_back</span>(t);</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    C = <span class="built_in">mul</span>(A,b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> sc.next();</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        List&lt;Integer&gt; A = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.length() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --) A.add(a.charAt(i) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; C = Multiply(A,b);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> C.size() - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i --) System.out.print(C.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title function_">Multiply</span><span class="params">(List&lt;Integer&gt; A,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; C = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; A.size();i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            t += A.get(i) * b;</span><br><span class="line">            C.add(t % <span class="number">10</span>);</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(t &gt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            C.add(t % <span class="number">10</span>);</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(C.size() &gt; <span class="number">1</span> &amp;&amp; C.get(C.size() - <span class="number">1</span>) == <span class="number">0</span>) C.remove(C.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> C;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间和"><a href="#区间和" class="headerlink" title="区间和"></a><a href="#区间和" title="区间和"></a>区间和</h3><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">        List&lt;Integer&gt; alls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Pair&gt; add = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Pair&gt; query = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            alls.add(x);</span><br><span class="line">            add.add(<span class="keyword">new</span> <span class="title class_">Pair</span>(x,c));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; m;i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line">            alls.add(l);</span><br><span class="line">            alls.add(r);</span><br><span class="line">            query.add(<span class="keyword">new</span> <span class="title class_">Pair</span>(l,r));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.sort(alls);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> unique(alls); <span class="comment">//去重</span></span><br><span class="line">        alls = alls.subList(<span class="number">0</span>,index); <span class="comment">// 返回从[0,index)的集合</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] pre = <span class="keyword">new</span> <span class="title class_">int</span>[alls.size() + <span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= add.size() - <span class="number">1</span>;i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Pair</span> <span class="variable">t</span> <span class="operator">=</span> add.get(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> binarySort(t.first,alls);</span><br><span class="line">            pre[x] += t.second;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= alls.size();i ++) pre[i] += pre[i - <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= query.size() - <span class="number">1</span>;i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">Pair</span> <span class="variable">t</span> <span class="operator">=</span> query.get(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> binarySort(t.first,alls);</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> binarySort(t.second,alls);</span><br><span class="line">            System.out.println(pre[r] - pre[l - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">unique</span><span class="params">(List&lt;Integer&gt; alls)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; alls.size();i ++)</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || alls.get(i) != alls.get(i - <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                alls.set(j,alls.get(i));</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySort</span><span class="params">(<span class="type">int</span> x,List&lt;Integer&gt; alls)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>,r = alls.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(alls.get(mid) &gt;= x) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l + <span class="number">1</span>; <span class="comment">// 前缀和数组从1开始,所以这里加1就会更方便</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&#123;</span><br><span class="line">    <span class="type">int</span> first;</span><br><span class="line">    <span class="type">int</span> second;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.first = x;</span><br><span class="line">        <span class="built_in">this</span>.second = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pre[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls;</span><br><span class="line">vector&lt;PII&gt; add,query;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>,r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x,c&#125;);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(),alls.<span class="built_in">end</span>()),alls.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; add.<span class="built_in">size</span>();i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(add[i].first);</span><br><span class="line">        pre[x] += add[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= alls.<span class="built_in">size</span>();i ++) pre[i] += pre[i - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; query.<span class="built_in">size</span>();i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">find</span>(query[i].first),r = <span class="built_in">find</span>(query[i].second);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,pre[r] - pre[l - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a><a href="#位运算" title="位运算"></a>位运算</h3><p><strong><em>模板：</em></strong></p><blockquote><p>求n的第k位数字: n &gt;&gt; k &amp; 1<br>返回n的最后一位1：lowbit(n) = n &amp; -n</p></blockquote><p><em>例：</em></p><p>x = 00001010101000       lowbit(x)得到的是1000</p><p>-x = ~x + 1   负数表示为补码   ，补码等于反码加1</p><p>因为 2 + （- 2） = 0</p><p>2为0010                    - 2 =  ~2 + 1 = 1110             0010 +1110 = 10000 = 0000</p><p><em>二进制中1的个数：</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x)&#123;</span><br><span class="line">            x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">            res ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">暴力枚举法</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,a,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">        </span><br><span class="line">        k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(a)&#123;</span><br><span class="line">            k += a &amp; <span class="number">1</span>;</span><br><span class="line">            a = a &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a><a href="#离散化" title="离散化"></a>离散化</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; alls; <span class="comment">// 存储所有待离散化的值</span></span><br><span class="line"><span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()); <span class="comment">// 将所有值排序</span></span><br><span class="line">alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());   <span class="comment">// 去掉重复元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分求出x对应的离散化的值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// 找到第一个大于等于x的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>; <span class="comment">// 映射到1, 2, ...n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开辟那么大的数组显然不可取，只需开辟n + 2*m个数组空间</p><p>alls中存放的都是位置而不是值</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cqq144%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211214211744285.png" alt="image-20211214211744285"></p><p>pair是C++中一种模板类型。每个pair对象可以存储两个值，这两个值可以是不同的数据类型。存储的值可以是基本数据类型也可以是自定义数据类型。</p><ul><li>unique去掉容器中相邻元素的重复元素（所有不重复的元素排在数组的最前面，数组末尾未占用的位置保留原来的值）</li><li>返回值是不重复的元素个数（标准说法是去重之后的尾地址）。</li><li>在使用unique之前要先排序，可使用sort()函数。</li></ul><p><strong>erase一共三种用法：</strong><br>1.erase(pos,n);<br>删除从下标pos开始的n个字符，比如erase(0,1)就是删除第一个字符<br>2.erase(position);<br>删除postion处的一个字符（position是一个string类型的迭代器）<br>3.erase(first,last)<br>删除从first到last之间的字符（first和last都是迭代器）</p><p><strong>主要分为5大步：</strong><br>1.读输入。将每次读入的x c push_back()到add中，将每次读入的位置x push_back()到alls中，将每次读入的l r push_back()到query中。<br>2.排序、去重。<br>3.通过遍历add，完成在离散化的数组映射到的a数组中进行加上c的操作（用到find函数）。<br>4.初始化s数组。<br>5.通过遍历query，完成求区间[l,r]的和。</p><p><strong>区间和：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; alls;</span><br><span class="line">vector&lt;PII&gt; add, query;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x, c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x, c&#125;);</span><br><span class="line"></span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line"></span><br><span class="line">        alls.<span class="built_in">push_back</span>(l);</span><br><span class="line">        alls.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去重</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理插入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : add)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="built_in">find</span>(item.first);</span><br><span class="line">        a[x] += item.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i ++ ) s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理询问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : query)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">find</span>(item.first), r = <span class="built_in">find</span>(item.second);</span><br><span class="line">        cout &lt;&lt; s[r] - s[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间合并化"><a href="#区间合并化" class="headerlink" title="区间合并化"></a><a href="#区间合并化" title="区间合并化"></a>区间合并化</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将所有存在交集的区间合并</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());<span class="comment">//先排序左端，再排序右端</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;<span class="comment">//st表示区间开头，ed表示区间结尾 ；值定义比原有的小即可</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)<span class="comment">//seg 在计算机专业术语中是段（segment）的缩写。</span></span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)<span class="comment">//维护区间右端</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);<span class="comment">//如果不是第一个区间，就加入</span></span><br><span class="line">            st = seg.first, ed = seg.second;   <span class="comment">//更新范围</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;); <span class="comment">//把最后一个区间加入，   防止是空的就加入</span></span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先排序再区间化</p><p><strong>区间合并</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;PII&gt; segs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(),segs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> st = <span class="number">-2e9</span>,ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> seg : segs)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ed &lt; seg.first) &#123;</span><br><span class="line">            <span class="keyword">if</span>(st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st,ed&#125;);</span><br><span class="line">            st = seg.first,ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed,seg.second);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st,ed&#125;);</span><br><span class="line">    </span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)&#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        </span><br><span class="line">        segs.<span class="built_in">push_back</span>(&#123;l,r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge</span>(segs);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; segs.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><a href="#数据结构" title="数据结构"></a>数据结构</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a><a href="#单链表" title="单链表"></a>单链表</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头插入一个数a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = a, ne[idx] = head, head = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将头结点删除，需要保证头结点存在</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = ne[head];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不能定义next[]数组</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// head 表示头结点的下标</span></span><br><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点i的next指针是多少</span></span><br><span class="line"><span class="comment">// idx 存储当前已经用到了哪个点</span></span><br><span class="line"><span class="type">int</span> head,value[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;</span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插到头结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    value[idx] = x;<span class="comment">//将值放进去</span></span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插到下标是k的点后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    value[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将下标是k的点后面的点删掉</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        </span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;H&#x27;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add_to_head</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span>(!k) head = ne[head];</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">remove</span>(k - <span class="number">1</span>);<span class="comment">//注意删除第k个输入后面的数，那函数里放的是下标，k要减去1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k - <span class="number">1</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head;i != <span class="number">-1</span>;i = ne[i])    <span class="comment">//最后一个为-1，无下标</span></span><br><span class="line">        cout &lt;&lt; value[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双链表"><a href="#双链表" class="headerlink" title=" 双链表"></a><a href="#双链表" title="双链表"></a> 双链表</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span></span><br><span class="line"><span class="type">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//0是左端点，1是右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点a的右边插入一个数x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    l[idx] = a, r[idx] = r[a];</span><br><span class="line">    l[r[a]] = idx, r[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点a</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    l[r[a]] = l[a];</span><br><span class="line">    r[l[a]] = r[a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2020/12/13/2675_bee82d743d-2.png" alt="2.png"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> value[N],l[N],r[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>,l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//画图理解</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    value[idx] = x;</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    r[idx] = r[k];</span><br><span class="line">    l[r[k]] = idx;  <span class="comment">//必须比r[k] = idx ++;先执行，前两个则无需排序</span></span><br><span class="line">    r[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    r[l[k]] = r[k];    <span class="comment">//颠倒也可以，无影响</span></span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">init</span>();     <span class="comment">//别忘了初始化哦</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        string op;</span><br><span class="line">        </span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&quot;L&quot;</span>)&#123;          <span class="comment">//最左端插入      字符串用双引号，单个字符可用单引号</span></span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">insert</span>(<span class="number">0</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;R&quot;</span>)&#123;    <span class="comment">//最右端插入      元素均在0和1之间</span></span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">insert</span>(l[<span class="number">1</span>],x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;D&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="built_in">remove</span>(k + <span class="number">1</span>);    <span class="comment">//idx索引从2开始，需加1，如idx从0开始，即k - 1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;IL&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">insert</span>(l[k + <span class="number">1</span>],x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">insert</span>(k + <span class="number">1</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = r[<span class="number">0</span>];i != <span class="number">1</span>;i = r[i]) <span class="comment">//最右端i = 1</span></span><br><span class="line">        cout &lt;&lt; value[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟栈（用数组）"><a href="#模拟栈（用数组）" class="headerlink" title=" 模拟栈（用数组）"></a><a href="#模拟栈（用数组）" title="模拟栈（用数组）"></a> 模拟栈（用数组）</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tt表示栈顶</span></span><br><span class="line"><span class="type">int</span> stk[N], tt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶的值</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> stk[N],tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//栈顶所在索引往后移动一格，然后放入x。</span></span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&quot;push&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            stk[ ++tt] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//往前移动一格</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;pop&quot;</span>) tt --;</span><br><span class="line">        <span class="comment">//大于等于 0 栈非空，小于 0 栈空</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;empty&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tt &gt; <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回栈顶元素，query</span></span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; stk[tt] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="表达式求值（栈的应用）"><a href="#表达式求值（栈的应用）" class="headerlink" title=" 表达式求值（栈的应用）"></a><a href="#表达式求值（栈的应用）" title="表达式求值（栈的应用）"></a> 表达式求值（栈的应用）</h3><p>输入长度为n的字符串，例如：1+2+3 * 4 * 5</p><p>输出表达式的值，即：63</p><p>应该用什么数据结构？</p><p>栈。</p><p>应该先计算哪一步？</p><p>实际应该先计算1+2。</p><p>“表达式求值”问题，两个核心关键点：</p><p>（1）双栈，一个操作数栈，一个运算符栈；</p><p>（2）运算符优先级，栈顶运算符，和，即将入栈的运算符的优先级比较：</p><p>如果栈顶的运算符优先级低，新运算符直接入栈</p><p>如果栈顶的运算符优先级高，先出栈计算，新运算符再入栈</p><p>仍以1+2+3 * 4 * 5举例，看是如何利用上述两个关键点实施计算的。</p><p>首先，这个例子只有+和*两个运算符，所以它的运算符表是：</p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/20/55289_095276ee89-00.webp.jpg" alt="00.webp.jpg" style="zoom:200%;" /><p>这里的含义是：</p><p>（1）如果栈顶是+，即将入栈的是+，栈顶优先级高，需要先计算，再入栈；</p><p>（2）如果栈顶是+，即将入栈的是*，栈顶优先级低，直接入栈；</p><p>（3）如果栈顶是*，即将入栈的是+，栈顶优先级高，需要先计算，再入栈；</p><p>（4）如果栈顶是<em>，即将入栈的是</em>，栈顶优先级高，需要先计算，再入栈；</p><p>有了运算符表，一切就好办了。</p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/20/55289_0d357dc289-01.webp.jpg" alt="01.webp.jpg" style="zoom:150%;" /><p>​                                                                                 一 开始，初始化好输入的字符串，以及操作数栈，运算符栈。</p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/20/55289_10cc705789-02.webp.jpg" alt="02.webp.jpg" style="zoom:150%;" /><p>​                                                                               一步步，扫描字符串，操作数一个个入栈，运算符也入栈。</p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/20/55289_14359ecb89-3.png" alt="3.png" style="zoom:150%;" /><p>​                                                                                           下一个操作符要入栈时，需要先比较优先级。</p><p>​                                                                                                 栈内的优先级高，必须先计算，才能入栈。</p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/20/55289_17b96fe289-4.webp.jpg" alt="4.webp.jpg" style="zoom:150%;" /><p>计算的过程为：</p><p>（1）操作数出栈，作为num2；</p><p>（2）操作数出栈，作为num1；</p><p>（3）运算符出栈，作为op；</p><p>（4）计算出结果；</p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/20/55289_1b6cac1c89-5.webp.jpg" alt="5.webp.jpg" style="zoom:150%;" /><p>5）结果入操作数栈；</p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/20/55289_1ed49bd989-6.png" alt="6.png" style="zoom:150%;" /><p>接下来，运算符和操作数才能继续入栈。下一个操作符要入栈时，继续比较与栈顶的优先级。</p><p>栈内的优先级低，可以直接入栈。</p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/20/55289_21bfcd8989-7.png" alt="7.png" style="zoom:150%;" /><p>​                                                                                                               字符串继续移动。</p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/20/55289_26237d8e89-8.png" alt="8.png" style="zoom:150%;" /><p>​                                                                                                    又要比较优先级了。</p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/20/55289_28e8139389-9.webp.jpg" alt="9.webp.jpg" style="zoom:150%;" /><p>​                                                                                   栈内的优先级高，还是先计算（3*4=12），再入栈。</p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/20/55289_2c8291c589-10.png" alt="10.png" style="zoom:150%;" /><p>​                                                                                         不断入栈，直到字符串扫描完毕。</p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/20/55289_2e61c67089-11.webp.jpg" alt="11.webp.jpg" style="zoom:150%;" /><p>不断出栈，直到得到最终结果3+60=63，算法完成。</p><p>总结</p><p>“表达式求值”问题，两个核心关键点：</p><p>（1）双栈，一个操作数栈，一个运算符栈；</p><p>（2）运算符优先级，栈顶运算符，和，即将入栈的运算符的优先级比较：<br>如果栈顶的运算符优先级低，新运算符直接入栈</p><p>如果栈顶的运算符优先级高，先出栈计算，新运算符再入栈</p><p>这个方法的时间复杂度为O(n)，整个字符串只需要扫描一遍。</p><p>运算符有+ - * / ( ) ~ ^ &amp; 都没问题，如果共有n个运算符，会有一个n * n的优先级表。 </p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt; op;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优先级表</span></span><br><span class="line">unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; pr&#123;&#123;<span class="string">&#x27;+&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;-&#x27;</span>,<span class="number">1</span>&#125;,&#123;<span class="string">&#x27;*&#x27;</span>,<span class="number">2</span>&#125;,&#123;<span class="string">&#x27;/&#x27;</span>,<span class="number">2</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eval</span><span class="params">()</span></span>&#123;<span class="comment">//求值</span></span><br><span class="line">    <span class="type">int</span> b = num.<span class="built_in">top</span>(); num.<span class="built_in">pop</span>();<span class="comment">//第二个操作数</span></span><br><span class="line">    <span class="type">int</span> a = num.<span class="built_in">top</span>(); num.<span class="built_in">pop</span>();<span class="comment">//第一个操作数</span></span><br><span class="line">    <span class="type">int</span> c = op.<span class="built_in">top</span>(); op.<span class="built_in">pop</span>();<span class="comment">//运算符</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="comment">//计算结果</span></span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27;+&#x27;</span>) s = a + b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) s = a - b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;*&#x27;</span>) s = a * b;</span><br><span class="line">    <span class="keyword">else</span> s = a / b;</span><br><span class="line">    </span><br><span class="line">    num.<span class="built_in">push</span>(s);<span class="comment">//结果入栈</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string str;<span class="comment">//读入表达式</span></span><br><span class="line">    cin &gt;&gt; str;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; str.<span class="built_in">size</span>();i ++)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(str[i]))&#123;<span class="comment">//数字入栈</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> x = <span class="number">0</span>,j = i;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(str[j]))   <span class="comment">//例如1111，如果没有这步操作，就会变成1，1,1,1四个数字</span></span><br><span class="line">                x = x * <span class="number">10</span> + str[j ++] - <span class="string">&#x27;0&#x27;</span>;<span class="comment">//x = x * 10 + str[j ++] - 48;</span></span><br><span class="line">            i = j - <span class="number">1</span>;</span><br><span class="line">            num.<span class="built_in">push</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左括号无优先级，直接入栈</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;(&#x27;</span>) op.<span class="built_in">push</span>(str[i]);</span><br><span class="line">        <span class="comment">//括号特殊，遇到左括号直接入栈，遇到右括号计算括号里面的</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span>) <span class="built_in">eval</span>();<span class="comment">//一直计算到左括号</span></span><br><span class="line">            op.<span class="built_in">pop</span>();<span class="comment">//左括号出栈</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(op.<span class="built_in">size</span>() &amp;&amp; op.<span class="built_in">top</span>() != <span class="string">&#x27;(&#x27;</span> &amp;&amp; pr[op.<span class="built_in">top</span>()] &gt;= pr[str[i]]) <span class="built_in">eval</span>();<span class="comment">//待入栈运算符优先级低，则先进行栈顶操作符计算</span></span><br><span class="line">            op.<span class="built_in">push</span>(str[i]);<span class="comment">//无论优先级高级，待入栈操作符入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(op.<span class="built_in">size</span>()) <span class="built_in">eval</span>();<span class="comment">//剩余的进行计算</span></span><br><span class="line">    cout &lt;&lt; num.<span class="built_in">top</span>() &lt;&lt; endl;<span class="comment">//输出结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟队列（用数组）"><a href="#模拟队列（用数组）" class="headerlink" title=" 模拟队列（用数组）"></a><a href="#模拟队列（用数组）" title="模拟队列（用数组）"></a> 模拟队列（用数组）</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾</span></span><br><span class="line"><span class="type">int</span> q[N], hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> q[N],hh,tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        string op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&quot;push&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            q[++ tt] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;pop&quot;</span>) hh ++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;empty&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tt &lt; hh) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; q[hh] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调栈"><a href="#单调栈" class="headerlink" title=" 单调栈"></a><a href="#单调栈" title="单调栈"></a> 单调栈</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出每个数左边离它最近的比它大/小的数</span><br><span class="line"><span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (tt &amp;&amp; <span class="built_in">check</span>(stk[tt], i)) tt -- ;</span><br><span class="line">    stk[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> stk[N],tt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; stk[tt] &gt;= x) tt --;<span class="comment">//如果栈顶元素大于当前待入栈元素，则出栈</span></span><br><span class="line">        <span class="keyword">if</span>(tt) cout &lt;&lt; stk[tt] &lt;&lt; <span class="string">&#x27; &#x27;</span>;<span class="comment">//如果栈空，则没有比该元素小的值。</span></span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;<span class="comment">//栈顶元素就是左侧第一个比它小的元素。</span></span><br><span class="line">        stk[++ tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="滑动窗口（队列的运用）"><a href="#滑动窗口（队列的运用）" class="headerlink" title=" 滑动窗口（队列的运用）"></a><a href="#滑动窗口（队列的运用）" title="滑动窗口（队列的运用）"></a> 滑动窗口（队列的运用）</h3><p><strong><em>模板:</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">常见模型：找出滑动窗口中的最大值/最小值</span><br><span class="line"><span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check_out</span>(q[hh])) hh ++ ;  <span class="comment">// 判断队头是否滑出窗口</span></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; <span class="built_in">check</span>(q[tt], i)) tt -- ;</span><br><span class="line">    q[ ++ tt] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"><span class="type">int</span> a[N],q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) &#123;          <span class="comment">//单调增弹出队头最小值</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh ++;<span class="comment">// 若队首出窗口，hh加1</span></span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt --;<span class="comment">// 若队尾不单调，tt减1</span></span><br><span class="line">        q[++ tt] = i;     <span class="comment">// 下标加到队尾</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    hh = <span class="number">0</span>,tt =  <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)&#123;             <span class="comment">//单调减弹出队头最大值</span></span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh ++;</span><br><span class="line">        <span class="keyword">while</span>(hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) tt --;</span><br><span class="line">        q[ ++tt] = i;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">&#x27; &#x27;</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KMP字符串"><a href="#KMP字符串" class="headerlink" title=" KMP字符串"></a><a href="#KMP字符串" title="KMP字符串"></a> KMP字符串</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度</span></span><br><span class="line">求模式串的Next数组：</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= m; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++ ;</span><br><span class="line">    <span class="keyword">if</span> (j == m)</span><br><span class="line">    &#123;</span><br><span class="line">        j = ne[j];</span><br><span class="line">        <span class="comment">// 匹配成功后的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>手动模拟求next数组：</strong></p><p>p    a    b    c    a    b<br>下标    1    2    3    4    5<br>next[ ]    0    0    0    1    2</p><p>对next[ 1 ] ：前缀 = 空集—————后缀 = 空集—————next[ 1 ] = 0;</p><p>对next[ 2 ] ：前缀 = { a }—————后缀 = { b }—————next[ 2 ] = 0;</p><p>对next[ 3 ] ：前缀 = { a , ab }—————后缀 = { c , bc}—————next[ 3 ] = 0;</p><p>对next[ 4 ] ：前缀 = { a , ab , abc }—————后缀 = { a . ca , bca }—————next[ 4 ] = 1;</p><p>对next[ 5 ] ：前缀 = { a , ab , abc , abca }————后缀 = { b , ab , cab , bcab}————next[ 5 ] = 2;</p><p><strong><em>匹配操作：</em></strong></p><p> KMP主要分两步：求next数组、匹配字符串。个人觉得匹配操作容易懂一些，疑惑我一整天的是求next数组的思想。所以先把匹配字符串讲一下。</p><p> s串 和 p串都是从1开始的。i 从1开始，j 从0开始，每次s[ i ] 和p[ j + 1 ]比较</p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2020/06/12/31041_8e70c3eeac-%E5%8C%B9%E9%85%8D.PNG" alt="匹配.PNG"></p><p>当匹配过程到上图所示时，</p><p>s[ a , b ] = p[ 1, j ] &amp;&amp; s[ i ] != p[ j + 1 ] 此时要移动p串（不是移动1格，而是直接移动到下次能匹配的位置）</p><p>其中1串为[ 1, next[ j ] ]，3串为[ j - next[ j ] + 1 , j ]。由匹配可知 1串等于3串，3串等于2串。所以直接移动p串使1到3的位置即可。这个操作可由j = next[ j ]直接完成。 如此往复下去，当 j == m时匹配成功。</p><p><strong><em>next数组：</em></strong></p><p>next数组的求法是通过模板串自己与自己进行匹配操作得出来的（代码和匹配操作几乎一样）。</p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2020/06/12/31041_97225cdcac-next%E6%95%B0%E7%BB%84.PNG" alt="next数组.PNG" style="zoom:150%;" /><p>代码和匹配操作的代码几乎一样，关键在于每次移动 i 前，将 i 前面已经匹配的长度记录到next数组中。</p><p>思路：在做的时候可以模拟ababc等字符串，自己动手理解</p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,M = <span class="number">1000010</span>;<span class="comment">//N为匹配串长度，M模式串长度</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> ne[N];<span class="comment">//next[]数组，避免和头文件next冲突</span></span><br><span class="line"><span class="type">char</span> s[M],p[N];<span class="comment">//s为模式串， p为匹配串</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;<span class="comment">//下标从1开始</span></span><br><span class="line">    </span><br><span class="line">     <span class="comment">//求next[]数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i &lt;= n;i ++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];   </span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[j + <span class="number">1</span>]) j ++;</span><br><span class="line">        ne[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//匹配操作 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>,j = <span class="number">0</span>;i &lt;= m;i ++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; s[i] != p[j + <span class="number">1</span>])  j = ne[j];<span class="comment">//如果j有对应p串的元素， 且s[i] != p[j+1], 则失配， 移动p串</span></span><br><span class="line">    <span class="comment">//用while是由于移动后可能仍然失配，所以要继续移动直到匹配或整个p串移到后面（j = 0)</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == p[j + <span class="number">1</span>]) j ++; <span class="comment">//当前元素匹配，j移向p串下一位</span></span><br><span class="line">        <span class="keyword">if</span>(j == n)&#123;  <span class="comment">//满足匹配条件，打印开头下标, 从0开始</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,i - n);</span><br><span class="line">            j = ne[j];   <span class="comment">//再次继续匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何理解单-双-链表，Trie树和堆中的idx？"><a href="#如何理解单-双-链表，Trie树和堆中的idx？" class="headerlink" title=" 如何理解单(双)链表，Trie树和堆中的idx？"></a><a href="#如何理解单(双)链表，Trie树和堆中的idx？" title="如何理解单(双)链表，Trie树和堆中的idx？"></a> 如何理解单(双)链表，Trie树和堆中的idx？</h3><p><strong><em>题目描述</em></strong></p><p>在这一章节中，我们经常看到y总在实现各种数据结构中经常用到idx这个变量，这个变量到底有什么用呢？<br>为什么链表，Trie树和堆会用到idx来维护这个数据结构，而栈和队列就不用idx来维护，而是用hh和tt来维护呢？</p><p><strong><em>解答：</em></strong></p><p>可以看出不管是链表，Trie树还是堆，他们的基本单元都是一个个结点连接构成的，可以成为“链”式结构。这个结点包含两个基本的属性：本身的值和指向下一个结点的指针。按道理，应该按照结构体的方式来实现这些数据结构的，但是做算法题一般用数组模拟，主要是因为比较快。</p><p>那就有个问题，原来这两个属性都是以结构体的方式联系在一起的，现在如果用数组模拟，如何才能把这两个属性联系起来呢，如何区分各个结点呢？</p><p>这就需要用到idx这个东东啦！</p><p>从y总给出的代码可以看出，idx的操作总是idx++，这就保证了不同的idx值对应不同的结点。因此可以利用idx把结构体内两个属性联系在一起了。因此，idx可以理解为结点。</p><p>链表：<br>链表中会使用到这几个数组来模拟：</p><p>h, e[N], ne[N], idx;<br>h表示头结点指针，一开始初始化指向-1，每次插入x的操作idx++。利用idx联系结构体本身的值和next指针，因此e[idx]可以作为结点的值，ne[idx]可以作为next指针。同理可以理解双链表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span> <span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] =  x;</span><br><span class="line">    ne[idx] = h;</span><br><span class="line">    h = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//双链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a,  <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line"></span><br><span class="line">    l[idx] = a;</span><br><span class="line">    r[idx] = r[a];</span><br><span class="line"></span><br><span class="line">    l[r[a]] = idx;</span><br><span class="line">    r[a] = idx ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Trie树</strong><br>Trie树中有个二维数组son[N] [26]，表示当前结点的儿子，如果没有的话，可以等于++idx。Trie树本质上是一颗多叉树，对于字母而言最多有26个子结点。所以这个数组包含了两条信息。比如：son[1] [0]=2表示1结点的一个值为a的子结点为结点2。如果son[1] [0] = 0，则意味着没有值为a子结点。这里的son[N] [26]相当于链表中的ne[N]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>; <span class="comment">//从根结点开始遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u =str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx; <span class="comment">//没有该子结点就创建一个</span></span><br><span class="line">        p = son[p][u]; <span class="comment">//走到p的子结点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cnt[p] ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>堆</strong><br>堆中的每次插入都是在堆尾，但是堆中经常有up和down操作。所以结点与结点的关系并不是用一个ne[idx][2]可以很好地维护的。但是好在堆是个完全二叉树。子父节点的关系可以通过下标来联系（左儿子2n，右儿子2n+1）。就数组模拟来说知道数组的下标就知道结点在堆中的位置。所以核心就在于即使有down和up操作也能维护堆数组的下标（k）和结点（idx）的映射关系。比如说：h[k] = x, h数组存的是结点的值，按理来说应该h[idx]来存，但是结点位置总是在变的，因此维护k和idx的映射关系就好啦，比如说用ph数组来表示ph[idx] = k, 那么结点值为h[ph[idx]], 儿子为ph[idx] * 2和ph[idx] * 2 + 1, 这样值和儿子结点不就可以通过idx联系在一起了吗？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (op == <span class="string">&quot;I&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">    size ++ ;</span><br><span class="line">    idx ++ ;</span><br><span class="line">    ph[idx] = size, hp[size] = idx;<span class="comment">//每次插入都是在堆尾插入</span></span><br><span class="line">    h[size] = x;<span class="comment">//h[k], k是堆数组的下标，h存储的是结点的值，也就是链表中的e[idx]</span></span><br><span class="line">    <span class="built_in">up</span>(size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于idx只有在插入的时候才会更新为idx ++，自然idx也表示第idx插入的元素</p><h3 id="Trie字符串统计"><a href="#Trie字符串统计" class="headerlink" title=" Trie字符串统计"></a><a href="#Trie字符串统计" title="Trie字符串统计"></a> Trie字符串统计</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="comment">// 0号点既是根节点，又是空节点</span></span><br><span class="line"><span class="comment">// son[][]存储树中每个节点的子节点</span></span><br><span class="line"><span class="comment">// cnt[]存储以每个节点结尾的单词数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入一个字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询字符串出现的次数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; str[i]; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cqq144%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211226140816475.png" alt="image-20211226140816475"></p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2020/06/13/31041_aed49a42ad-Trie2.PNG" alt="Trie2.PNG"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Trie树快速存储字符集合和快速查询字符集合</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//son[][]存储子节点的位置，分支最多26条；</span></span><br><span class="line"><span class="comment">//cnt[]存储以某节点结尾的字符串个数（同时也起标记作用）</span></span><br><span class="line"><span class="comment">//idx表示当前要插入的节点是第几个,每创建一个节点值+1</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>],cnt[N],idx; </span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;   <span class="comment">//类似指针，指向当前节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;str[i];i ++)&#123;</span><br><span class="line">        <span class="type">int</span> u =  str[i] - <span class="string">&#x27;a&#x27;</span>;   <span class="comment">//将字母转化为数字</span></span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) son[p][u] = ++ idx;   <span class="comment">//该节点不存在，创建节点,其值为下一个节点位置</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p] ++;   <span class="comment">//结束时的标记，也是记录以此节点结束的字符串个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;str[i];i ++)&#123;</span><br><span class="line">        <span class="type">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//该节点不存在，即该字符串不存在</span></span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)&#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; str;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(str);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大异或对（Tire树的运用）"><a href="#最大异或对（Tire树的运用）" class="headerlink" title=" 最大异或对（Tire树的运用）"></a><a href="#最大异或对（Tire树的运用）" title="最大异或对（Tire树的运用）"></a> 最大异或对（Tire树的运用）</h3><p><strong>int &amp; ：</strong>C++里的引用，和指针类似，定义的变量和赋值的变量指向同一块内存，一个改变，另一个也会改变。</p><p>son的第一维度存的是trie数一共有多少节点，如果是存储一个数的话，确实开31个空间就好了，但是存储的是N = 100000个数，每个数循环31次，那就是31*100000 = 310w，因为会有复用的节点，用不上这么多，300w就可以了    </p><p><strong><em>暴力枚举（超时）：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,res;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) cin &gt;&gt; a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j ++)</span><br><span class="line">            res = <span class="built_in">max</span>(res,a[i] ^ a[j]);</span><br><span class="line">            </span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">3100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N],son[M][<span class="number">2</span>],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;i --)&#123; <span class="comment">//要从最高位开始枚举，如果高位可以得1，不管后面怎么样得出来的是多少，一定是最大的。</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> &amp;s = son[p][x &gt;&gt; i &amp; <span class="number">1</span>];  <span class="comment">//下面s改变的话左边对应的son也要改变</span></span><br><span class="line">        <span class="keyword">if</span>(!s) s = ++ idx;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*void insert(int x)&#123;</span></span><br><span class="line"><span class="comment">    int q = 0;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    for(int i = 30;i &gt;= 0;i --)&#123;</span></span><br><span class="line"><span class="comment">        int u = x &gt;&gt; i &amp; 1;</span></span><br><span class="line"><span class="comment">        if(!son[q][u]) son[q][u] = ++ idx;</span></span><br><span class="line"><span class="comment">        q = son[q][u];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>,res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">30</span>;i &gt;= <span class="number">0</span>;i --)&#123;</span><br><span class="line">        <span class="type">int</span> s = x &gt;&gt; i &amp; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(son[p][!s]) &#123;</span><br><span class="line">            res += <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            p = son[p][!s];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> p = son[p][s];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        <span class="built_in">insert</span>(a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">        res = <span class="built_in">max</span>(res,<span class="built_in">query</span>(a[i]));</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并集合"><a href="#合并集合" class="headerlink" title=" 合并集合"></a><a href="#合并集合" title="合并集合"></a> 合并集合</h3><p><strong><em>模板：</em></strong></p><p>(1)朴素并查集：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[N]; <span class="comment">//存储每个点的祖宗节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2020/08/25/652_f30d4a86e6-%E5%B9%B6%E6%9F%A5%E9%9B%861.png" alt="并查集1.png"></p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2020/08/25/652_f97c9610e6-%E5%B9%B6%E6%9F%A5%E9%9B%862.png" alt="并查集2.png"></p><p>为什么用fflush(stdin);更保险？<br>一个getchar()只能接收一个字符，如果缓冲区内还有其他的字符（比方说你在输入数字时多打了xyz），getchar()不能把xyz清除掉，而fflush(stdin)是把换行及后面的所有字符全部清掉，当然是更保险了。</p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N];  <span class="comment">//parent，每次找指向它的父节点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;  <span class="comment">//find(x) 是找会祖宗节点， p[x] 数组存放的是父节点</span></span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">getchar</span>();   <span class="comment">// 去除残留在键盘缓冲区内的换行符</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c%d%d&quot;</span>,&amp;op,&amp;a,&amp;b);   <span class="comment">//char op[2];可以把换行符给存进去</span></span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;M&#x27;</span>) p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="连通块中点的数量"><a href="#连通块中点的数量" class="headerlink" title=" 连通块中点的数量"></a><a href="#连通块中点的数量" title="连通块中点的数量"></a> 连通块中点的数量</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">2</span>)维护size的并查集：</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> p[N], size[N];</span><br><span class="line">    <span class="comment">//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回x的祖宗节点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        <span class="keyword">return</span> p[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        size[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">    size[<span class="built_in">find</span>(b)] += size[<span class="built_in">find</span>(a)];</span><br><span class="line">    p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/01/08/2675_5e4605b851-1.jpg" alt="1.jpg"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N],cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)&#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        cnt[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&quot;C&quot;</span>)&#123;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">                p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">                cnt[b] += cnt[a];  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;Q1&quot;</span>) &#123;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cin &gt;&gt; a;</span><br><span class="line">            a = <span class="built_in">find</span>(a);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,cnt[a]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="食物链（带权并差集）"><a href="#食物链（带权并差集）" class="headerlink" title=" 食物链（带权并差集）"></a><a href="#食物链（带权并差集）" title="食物链（带权并差集）"></a> 食物链（带权并差集）</h3><p><strong><em>模板：</em></strong></p><p>(3)维护到祖宗节点距离的并查集：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line"><span class="comment">//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回x的祖宗节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，假定节点编号是1~n</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    p[i] = i;</span><br><span class="line">    d[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并a和b所在的两个集合：</span></span><br><span class="line">p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);</span><br><span class="line">d[<span class="built_in">find</span>(a)] = distance; <span class="comment">// 根据具体问题，初始化find(a)的偏移量</span></span><br></pre></td></tr></table></figure><p>find函数第一个作用返回root<br>第二个作用在压缩路劲并且同时更新d[x]，也就是最后会计算出对应节点的d[x]<br>如果直观来看p[x] = find(p[x]) 然后d[x] += d[p[x]];<br>这样就错了，d[x]一定不会改变,因为d[p[x]] 一定是等于0的(p[x]==root,d[root]=0)<br>需要root = find(p[x])先保存起来返回的根节点，find(p[x])已经把d[p[x]]计算出来，<br>然后d[x]+= d[p[x]]这时候累加的是x的父节点而不是根节点d[root],最后在更新p[x]=root</p><p><strong><em>d[x]取模3：</em></strong></p><p>余1：可以吃根节点</p><p>余2：可以被根节点吃</p><p>余0：与根节点是同类</p><p>结合题意，画图</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cqq144%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211227110913071.png" alt="image-20211227110913071"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>  <span class="comment">//第一行首先要进行路径压缩，在路径压缩的过程中更新了当前节点的父节点，到根节点的距离，p[x]放在最后更新，是因为如果提前更新了 p[x] = find(p[x]) 的话，此时 p[x] 代表的是将 x 指向了根节点，所以 d[p[x]] = 0，这样就无法正确地存储当前节点到根节点的正确距离了，因此必须先算完距离，再更新p[x]。  变成每一个直接指向root（根节点）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2020/07/08/41774_bd485030c0-JIE.jpg" alt="JIE.jpg"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> p[N], d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">find</span>(p[x]);</span><br><span class="line">        d[x] += d[p[x]];</span><br><span class="line">        p[x] = u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t,x,y;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;t,&amp;x,&amp;y);</span><br><span class="line">        <span class="type">int</span> px = <span class="built_in">find</span>(x),py = <span class="built_in">find</span>(y);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(x &gt; n || y &gt; n) res ++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(t == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(px == py &amp;&amp; (d[x] - d[y]) % <span class="number">3</span>) res ++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(px != py)&#123;</span><br><span class="line">                p[px] = py;</span><br><span class="line">                d[px] = d[y] - d[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(px == py &amp;&amp; (d[x] - d[y] - <span class="number">1</span>) % <span class="number">3</span>) res ++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(px != py)&#123;</span><br><span class="line">                p[px] = py;</span><br><span class="line">                d[px] = d[y] + <span class="number">1</span> - d[x];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title=" 堆排序"></a><a href="#堆排序" title="堆排序"></a> 堆排序</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// O(n)建堆</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span>; i; i -- ) <span class="built_in">down</span>(i);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/01/13/2675_1720413655-7.jpg" alt="7.jpg"></p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/01/13/2675_19e4b24455-8.jpg" alt="8.jpg"></p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/02/03/13021_4e8b9d6e65-838%E5%A0%86%E6%8E%92%E5%BA%8F-1.png" alt="838堆排序-1.png"></p><p>堆的时间复杂度<br>操作所花的时间都和树的深度成正比 ,因此为O（logn）<br>初始化小根堆的时间复杂度<br>O（n）</p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2020/03/04/11802_155b32345d-O1%E7%9A%84%E5%B0%8F%E6%A0%B9%E5%A0%86%E5%BB%BA%E7%AB%8B.jpg" alt="img"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * u &lt;= cnt &amp;&amp; h[<span class="number">2</span> * u] &lt; h[t]) t = <span class="number">2</span> * u;      </span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * u + <span class="number">1</span> &lt;= cnt &amp;&amp; h[<span class="number">2</span> * u + <span class="number">1</span>] &lt; h[t]) t = <span class="number">2</span> * u  + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(t != u)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[t],h[u]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h[i]);</span><br><span class="line">    cnt = n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n/<span class="number">2</span>; i ;i --) <span class="built_in">down</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,h[<span class="number">1</span>]);</span><br><span class="line">        h[<span class="number">1</span>] = h[cnt];</span><br><span class="line">        cnt --;</span><br><span class="line">        <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟堆"><a href="#模拟堆" class="headerlink" title=" 模拟堆"></a><a href="#模拟堆" title="模拟堆"></a> 模拟堆</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1</span></span><br><span class="line"><span class="comment">// ph[k]存储第k个插入的点在堆中的位置</span></span><br><span class="line"><span class="comment">// hp[k]存储堆中下标是k的点是第几个插入的</span></span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个点，及其映射关系</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= size &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u, u / <span class="number">2</span>);</span><br><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cqq144%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20211227165751366.png" alt="image-20211227165751366"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N],ph[N],hp[N],cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a],hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a],h[b]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = u;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * u &lt;= cnt &amp;&amp; h[<span class="number">2</span> * u] &lt; h[t]) t = <span class="number">2</span> * u;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">2</span> * u + <span class="number">1</span> &lt;= cnt &amp;&amp; h[<span class="number">2</span> * u + <span class="number">1</span>] &lt; h[t]) t = <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(t != u)&#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(t,u);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u / <span class="number">2</span> &amp;&amp; h[u] &lt; h[u / <span class="number">2</span>])&#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u , u / <span class="number">2</span>);</span><br><span class="line">        <span class="built_in">up</span>(u / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    string op;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n --)&#123;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&quot;I&quot;</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            cnt ++;</span><br><span class="line">            m ++;<span class="comment">//记录第几次插入</span></span><br><span class="line">            ph[m] = cnt, hp[cnt] = m;<span class="comment">//每次插入都是在堆尾插入</span></span><br><span class="line">            h[cnt] = x;<span class="comment">//记录插入的值</span></span><br><span class="line">            <span class="built_in">up</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;PM&quot;</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,h[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;DM&quot;</span>)&#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>,cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op == <span class="string">&quot;D&quot;</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">            k = ph[k];  <span class="comment">//第k个点对应的下标</span></span><br><span class="line">            <span class="built_in">heap_swap</span>(k,cnt);</span><br><span class="line">            cnt --;</span><br><span class="line">            <span class="built_in">up</span>(k); <span class="comment">// 交换完，可能会变大、也可能变小，down和up各一遍，两个操作只有一个会支持</span></span><br><span class="line">            <span class="built_in">down</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;k,&amp;x);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            h[k] = x;</span><br><span class="line">            <span class="built_in">up</span>(k);</span><br><span class="line">            <span class="built_in">down</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟散列表"><a href="#模拟散列表" class="headerlink" title=" 模拟散列表"></a><a href="#模拟散列表" title="模拟散列表"></a> 模拟散列表</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) 拉链法</span><br><span class="line">    <span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向哈希表中插入一个数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">        e[idx] = x;</span><br><span class="line">        ne[idx] = h[k];</span><br><span class="line">        h[k] = idx ++ ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在哈希表中查询某个数是否存在</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">            <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>) 开放寻址法</span><br><span class="line">    <span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">        <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)</span><br><span class="line">        &#123;</span><br><span class="line">            t ++ ;</span><br><span class="line">            <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">100010</span>;i &gt; <span class="number">0</span>;i --)&#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>;j * j &lt;= i;j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="literal">true</span>) &#123;</span><br><span class="line">            cout &lt;&lt; i;    <span class="comment">//算出离100010最近的质数，在数学上这样会比较分散</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>拉链法：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span>   <span class="comment">//memset的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100003</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = (x % N + N) % N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[u];</span><br><span class="line">    h[u] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u];i != - <span class="number">1</span>;i = ne[i]) </span><br><span class="line">        <span class="keyword">if</span>(e[i] == x) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));<span class="comment">//函数原型：void *memset(void *s , int ch , size_t  n ) ;函数解释：将s中的前n个字节用ch替换并且返回s</span></span><br><span class="line">    <span class="keyword">while</span>(n --)&#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,&amp;op,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>开放寻址法：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200009</span> ,null = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> u = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">while</span>(h[u] != null &amp;&amp; h[u] != x)&#123;</span><br><span class="line">        u ++;</span><br><span class="line">        <span class="keyword">if</span>(u == N) u = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h,null,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)&#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,&amp;op,&amp;x);</span><br><span class="line">        <span class="type">int</span> t = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(*op == <span class="string">&#x27;I&#x27;</span>) h[t] = x;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(h[t] == null) <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title=" 字符串哈希"></a><a href="#字符串哈希" title="字符串哈希"></a> 字符串哈希</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">核心思想：将字符串看成P进制数，P的经验值是<span class="number">131</span>或<span class="number">13331</span>，取这两个值的冲突概率低</span><br><span class="line">小技巧：取模的数用<span class="number">2</span>^<span class="number">64</span>，这样直接用<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>存储，溢出的结果就是取模的结果</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line">ULL h[N], p[N]; <span class="comment">// h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子串 str[l ~ r] 的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>unsigned long long :<br>的范围是[0,264-1]。如果越界了以后就相当于是对2的64次幂-1求模了。</p><p>long long：是有符号类型它的范围是[-263-1,263+1]，因为有符号的第63位表示“正负”而不表示数值。但数据越界了以后就会从负数开始计数</p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/01/17/2675_59c20aec58-1.jpg" alt="1.jpg"></p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/01/17/2675_5cc1dc5458-2.jpg" alt="2.jpg"></p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/01/17/2675_6024b68258-3.jpg" alt="3.jpg"></p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/01/17/2675_63495d4a58-4.jpg" alt="4.jpg"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,P = <span class="number">131</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line">ULL h[N],p[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l - <span class="number">1</span>] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>,&amp;n,&amp;m,str + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) &#123;</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + str[i];  <span class="comment">//前缀和求整个字符串的哈希值</span></span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)&#123;</span><br><span class="line">        <span class="type">int</span> l1,r1,l2,r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;l1,&amp;r1,&amp;l2,&amp;r2);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">get</span>(l1,r1) == <span class="built_in">get</span>(l2,r2)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-STL简介"><a href="#C-STL简介" class="headerlink" title=" C++STL简介"></a><a href="#C++STL简介" title="C++STL简介"></a> C++STL简介</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">C++ STL简介</span><br><span class="line">vector, 变长数组，倍增的思想</span><br><span class="line">    <span class="built_in">size</span>()  返回元素个数</span><br><span class="line">    <span class="built_in">empty</span>()  返回是否为空</span><br><span class="line">    <span class="built_in">clear</span>()  清空</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    []</span><br><span class="line">    支持比较运算，按字典序</span><br><span class="line"></span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;</span><br><span class="line">    first, 第一个元素</span><br><span class="line">    second, 第二个元素</span><br><span class="line">    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</span><br><span class="line"></span><br><span class="line">string，字符串</span><br><span class="line">    <span class="built_in">size</span>()/<span class="built_in">length</span>()  返回字符串长度</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">substr</span>(起始下标，(子串长度))  返回子串</span><br><span class="line">    <span class="built_in">c_str</span>()  返回字符串所在字符数组的起始地址</span><br><span class="line"></span><br><span class="line">queue, 队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向队尾插入一个元素</span><br><span class="line">    <span class="built_in">front</span>()  返回队头元素</span><br><span class="line">    <span class="built_in">back</span>()  返回队尾元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出队头元素</span><br><span class="line"></span><br><span class="line">priority_queue, 优先队列，默认是大根堆</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回堆顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出堆顶元素</span><br><span class="line">    定义成小根堆的方式：priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line"></span><br><span class="line">stack, 栈</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">push</span>()  向栈顶插入一个元素</span><br><span class="line">    <span class="built_in">top</span>()  返回栈顶元素</span><br><span class="line">    <span class="built_in">pop</span>()  弹出栈顶元素</span><br><span class="line"></span><br><span class="line">deque, 双端队列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">front</span>()/<span class="built_in">back</span>()</span><br><span class="line">    <span class="built_in">push_back</span>()/<span class="built_in">pop_back</span>()</span><br><span class="line">    <span class="built_in">push_front</span>()/<span class="built_in">pop_front</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列</span><br><span class="line">    <span class="built_in">size</span>()</span><br><span class="line">    <span class="built_in">empty</span>()</span><br><span class="line">    <span class="built_in">clear</span>()</span><br><span class="line">    <span class="built_in">begin</span>()/<span class="built_in">end</span>()</span><br><span class="line">    ++, -- 返回前驱和后继，时间复杂度 <span class="built_in">O</span>(logn)</span><br><span class="line"></span><br><span class="line">    set/<span class="function">multiset</span></span><br><span class="line"><span class="function">        <span class="title">insert</span><span class="params">()</span>  插入一个数</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span>  查找一个数</span></span><br><span class="line"><span class="function">        <span class="title">count</span><span class="params">()</span>  返回某一个数的个数</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">1</span>)</span> 输入是一个数x，删除所有x   <span class="title">O</span><span class="params">(k + logn)</span></span></span><br><span class="line"><span class="function">            <span class="params">(<span class="number">2</span>)</span> 输入一个迭代器，删除这个迭代器</span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="title">lower_bound</span><span class="params">(x)</span>  返回大于等于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">            <span class="title">upper_bound</span><span class="params">(x)</span>  返回大于x的最小的数的迭代器</span></span><br><span class="line"><span class="function">    map/multimap</span></span><br><span class="line"><span class="function">        <span class="title">insert</span><span class="params">()</span>  插入的数是一个pair</span></span><br><span class="line"><span class="function">        <span class="title">erase</span><span class="params">()</span>  输入的参数是pair或者迭代器</span></span><br><span class="line"><span class="function">        <span class="title">find</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        []  注意multimap不支持此操作。 时间复杂度是 <span class="title">O</span><span class="params">(logn)</span></span></span><br><span class="line"><span class="function">        <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表</span></span><br><span class="line"><span class="function">    和上面类似，增删改查的时间复杂度是 <span class="title">O</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    不支持 <span class="title">lower_bound</span><span class="params">()</span>/<span class="title">upper_bound</span><span class="params">()</span>， 迭代器的++，--</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">bitset, 圧位</span></span><br><span class="line"><span class="function">    bitset&lt;10000&gt; s</span>;</span><br><span class="line">    ~, &amp;, |, ^</span><br><span class="line">    &gt;&gt;, &lt;&lt;</span><br><span class="line">    ==, !=</span><br><span class="line">    []</span><br><span class="line"></span><br><span class="line">    <span class="built_in">count</span>()  返回有多少个<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">any</span>()  判断是否至少有一个<span class="number">1</span></span><br><span class="line">    <span class="built_in">none</span>()  判断是否全为<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">set</span>()  把所有位置成<span class="number">1</span></span><br><span class="line">    <span class="built_in">set</span>(k, v)  将第k位变成v</span><br><span class="line">    <span class="built_in">reset</span>()  把所有位变成<span class="number">0</span></span><br><span class="line">    <span class="built_in">flip</span>()  等价于~</span><br><span class="line">    <span class="built_in">flip</span>(k) 把第k位取反</span><br></pre></td></tr></table></figure><h2 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a><a href="#搜索与图论" title="搜索与图论"></a>搜索与图论</h2><h3 id="排列数字（DFS）"><a href="#排列数字（DFS）" class="headerlink" title=" 排列数字（DFS）"></a><a href="#排列数字（DFS）" title="排列数字（DFS）"></a> 排列数字（DFS）</h3><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/02/20/55289_0cd4222d73-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86.png" alt="深度优先遍历.png"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> path[N];</span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">//标记</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;    </span><br><span class="line">    <span class="keyword">if</span>(u == n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,path[i]);</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            path[u] = i;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">            st[i] = <span class="literal">false</span>; <span class="comment">//回溯，恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="n-—皇后问题"><a href="#n-—皇后问题" class="headerlink" title="n —皇后问题"></a>n —皇后问题</h3><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/02/20/55289_3867c0be73-20160921182422515.jpg" alt="20160921182422515.jpg"></p><ol><li>反对角线 y=x+b, 截距 b=y−x，因为我们要把 b 当做数组下标来用，显然 b 不能是负的，所以我们加上 +n （实际上+n+4,+2n都行），来保证是结果是正的，即 y - x + n</li><li>而对角线  y=−x+b , 截距是 by+x，这里截距一定是正的，所以不需要加偏移量</li></ol><p>核心目的：找一些合法的下标来表示dg或udg是否被标记过，所以如果你愿意，你取 udg[n+n−u+i] 也可以，只要所有(u,i)对可以映射过去就行</p><p><strong><em>代码(第一种方法）按行枚举（比较好）：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bool数组用来判断搜索的下一个位置是否可行</span></span><br><span class="line"><span class="comment">// col列，dg对角线，udg反对角线</span></span><br><span class="line"><span class="comment">// path[N][N]用来存路径</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> path[N][N];</span><br><span class="line"><span class="type">bool</span> col[N],dg[N],udg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == n) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">puts</span>(path[i]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)&#123;</span><br><span class="line">        <span class="comment">//剪枝(对于不满足要求的点，不再继续往下搜索)</span></span><br><span class="line">        <span class="comment">// udg[n - u + i]，+n是为了保证下标非负</span></span><br><span class="line">        <span class="keyword">if</span>(!col[i] &amp;&amp; !dg[n + u - i] &amp;&amp; !udg[u + i])&#123;</span><br><span class="line">            path[u][i] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            col[i] = dg[n + u - i] = udg[u + i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(u + <span class="number">1</span>);</span><br><span class="line">            col[i] = dg[n + u - i] = udg[u + i] = <span class="literal">false</span>;<span class="comment">// 恢复现场</span></span><br><span class="line">            path[u][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j ++)</span><br><span class="line">            path[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);        </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码（第二种方法）一个一个枚举：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> path[N][N];</span><br><span class="line"><span class="type">bool</span> row[N],col[N],dg[N],udg[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y == n) y = <span class="number">0</span>,x ++;</span><br><span class="line">    <span class="keyword">if</span>(x == n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == n) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++ ) <span class="built_in">puts</span>(path[i]);</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//放皇后</span></span><br><span class="line">    <span class="keyword">if</span>(!row[x] &amp;&amp; !col[y] &amp;&amp; !dg[x - y + n] &amp;&amp; !udg[x + y])&#123;</span><br><span class="line">        path[x][y] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        row[x] = col[y] = dg[x - y + n] = udg[x + y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(x,y + <span class="number">1</span>,s + <span class="number">1</span>);</span><br><span class="line">        row[x] = col[y] = dg[x - y + n] = udg[x + y] = <span class="literal">false</span>;</span><br><span class="line">        path[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//不放皇后，直接进入下一个枚举</span></span><br><span class="line">    <span class="built_in">dfs</span>(x, y + <span class="number">1</span>,s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j ++)</span><br><span class="line">            path[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题单：</p><p>AcWing 842. 排列数字<br>AcWing 843. n-皇后问题<br>AcWing 1097. 池塘计数<br>AcWing 1098. 城堡问题<br>AcWing 1106. 山峰和山谷<br>AcWing 1112. 迷宫<br>AcWing 1113. 红与黑<br>AcWing 1116. 马走日<br>AcWing 1117. 单词接龙<br>AcWing 1118. 分成互质组<br>AcWing 165. 小猫爬山<br>AcWing 166. 数独<br>AcWing 167. 木棒<br>AcWing 168. 生日蛋糕</p><h3 id="走迷宫（BFS）"><a href="#走迷宫（BFS）" class="headerlink" title=" 走迷宫（BFS）"></a><a href="#走迷宫（BFS）" title="走迷宫（BFS）"></a> 走迷宫（BFS）</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码（直接自己创建队列）：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span><span class="comment">//使用memset()需要用到的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;<span class="comment">//地图的长宽</span></span><br><span class="line"><span class="type">int</span> g[N][N],d[N][N];<span class="comment">//存储地图        标记搜索到的点的距离</span></span><br><span class="line">PII q[N * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;; <span class="comment">//将第一个点入队</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="built_in">sizeof</span>(d)); <span class="comment">//初始化d数组</span></span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//左上角第一个点开始搜索</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;,dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;  <span class="comment">//四个方向，可走上下左右</span></span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q[hh ++];<span class="comment">//取队头元素，队头元素出队</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i ++)&#123; <span class="comment">//分别向四个方向扩展</span></span><br><span class="line">            <span class="type">int</span> x = t.first + dx[i], y = t.second + dy[i];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//扩展后的坐标</span></span><br><span class="line">            <span class="comment">//首先(x,y)不能越界, 然后g[x][y] == 0说明可以走(g[x][y] == 1说明是障碍物)</span></span><br><span class="line">            <span class="comment">//最后是只更新未被访问的点到源点的距离 (要求d[x][y] == -1（意思是未走过的点）)</span></span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span>)&#123;</span><br><span class="line">                d[x][y] = d[t.first][t.second] + <span class="number">1</span>;<span class="comment">//更新未被访问的点到源点的距离</span></span><br><span class="line">                q[++ tt] = &#123;x,y&#125;;  <span class="comment">//(x,y)进队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n - <span class="number">1</span>][m - <span class="number">1</span>];  <span class="comment">//返回右下角元素到源点的距离</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;g[i][j]);</span><br><span class="line">            </span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码（用队列完成）：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N][N],d[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue &lt;PII&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="built_in">sizeof</span>(d));</span><br><span class="line">    d[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;,dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i ++)&#123;</span><br><span class="line">            <span class="type">int</span> x = t.first + dx[i],y = t.second + dy[i];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; m &amp;&amp; g[x][y] == <span class="number">0</span> &amp;&amp; d[x][y] == <span class="number">-1</span>)&#123;</span><br><span class="line">                d[x][y] = d[t.first][t.second] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;x,y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j ++)  </span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;g[i][j]);</span><br><span class="line">            </span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八数码"><a href="#八数码" class="headerlink" title=" 八数码"></a><a href="#八数码" title="八数码"></a> 八数码</h3><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(string state)</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义队列和dist数组</span></span><br><span class="line">    queue&lt;string&gt; q;</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; d;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化队列和dist数组</span></span><br><span class="line">    q.<span class="built_in">push</span>(state);</span><br><span class="line">    d[state] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;,dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//转移方式</span></span><br><span class="line">    string end = <span class="string">&quot;12345678x&quot;</span>;<span class="comment">//定义目标状态</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        string t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//记录当前状态的距离，如果是最终状态则返回距离</span></span><br><span class="line">        <span class="type">int</span> distance = d[t];</span><br><span class="line">        <span class="keyword">if</span>(t == end) <span class="keyword">return</span> distance;</span><br><span class="line">        <span class="comment">//查询x在字符串中的下标，然后转换为在矩阵中的坐标</span></span><br><span class="line">        <span class="type">int</span> u = t.<span class="built_in">find</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> a = u / <span class="number">3</span>,b = u % <span class="number">3</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i ++)&#123;</span><br><span class="line">            <span class="type">int</span> x = a + dx[i],y = b + dy[i];<span class="comment">//求转移后的坐标</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; <span class="number">3</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; <span class="number">3</span>)&#123;<span class="comment">//当前坐标没有越界</span></span><br><span class="line">                <span class="built_in">swap</span>(t[x * <span class="number">3</span> + y],t[u]);<span class="comment">//转移x</span></span><br><span class="line">                <span class="keyword">if</span>(!d.<span class="built_in">count</span>(t))&#123;<span class="comment">//如果当前状态是第一次遍历，记录距离，入队</span></span><br><span class="line">                    d[t] = distance + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">swap</span>(t[x * <span class="number">3</span> + y],t[u]);<span class="comment">//还原状态，为下一种转换情况做准备</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    string state;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i ++)&#123;<span class="comment">//输入起始状态</span></span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        state += *op;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>(state) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码:</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string state;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    queue&lt;string&gt; q;</span><br><span class="line">    unordered_map&lt;string,<span class="type">int</span>&gt; d;</span><br><span class="line">    </span><br><span class="line">    q.<span class="built_in">push</span>(state);</span><br><span class="line">    d[state] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    string end = <span class="string">&quot;12345678x&quot;</span>;</span><br><span class="line">    <span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;,dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> distance = d[t];</span><br><span class="line">        <span class="keyword">if</span>(t == end) <span class="keyword">return</span> distance;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> u = t.<span class="built_in">find</span>(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">        <span class="type">int</span> a = u / <span class="number">3</span>,b = u % <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i ++)&#123;</span><br><span class="line">            <span class="type">int</span> x = a + dx[i],y = b + dy[i];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; <span class="number">3</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; <span class="number">3</span>)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(t[u],t[x * <span class="number">3</span> + y]);</span><br><span class="line">                <span class="keyword">if</span>(!d.<span class="built_in">count</span>(t))&#123;</span><br><span class="line">                    d[t] = distance + <span class="number">1</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">swap</span>(t[u],t[x * <span class="number">3</span> + y]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i ++)&#123;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        state += *op;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树与图的存储"><a href="#树与图的存储" class="headerlink" title=" 树与图的存储"></a><a href="#树与图的存储" title="树与图的存储"></a> 树与图的存储</h3><p>树与图的存储<br>树是一种特殊的图，与图的存储方式相同。<br>对于无向图中的边ab，存储两条有向边a-&gt;b, b-&gt;a。<br>因此我们可以只考虑有向图的存储。</p><p>(1) 邻接矩阵：g[a][b] 存储边a-&gt;b</p><p>(2) 邻接表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一条边a-&gt;b</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">idx = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br></pre></td></tr></table></figure><h3 id="树的重心"><a href="#树的重心" class="headerlink" title=" 树的重心"></a><a href="#树的重心" title="树的重心"></a> 树的重心</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度  <span class="built_in">O</span>(n+m) , n 表示点数，m 表示边数</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>; <span class="comment">// st[u] 表示点u已经被遍历过</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) <span class="built_in">dfs</span>(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2020/05/22/652_ab4f9f7c9b-1.png" alt="1.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,M = <span class="number">2</span> * N;<span class="comment">//以有向图的格式存储无向图，所以每个节点至多对应2n-2条边</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx;<span class="comment">//h(邻接表存储树，有n个节点，所以需要n个队列头节点),e(存储元素)ne(存储列表的next值),idx(单链表指针)</span></span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">//记录节点是否被访问过，访问过则标记为true</span></span><br><span class="line"><span class="type">int</span> ans = N; <span class="comment">//表示重心的所有的子树中，最大的子树的结点数目</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="comment">//a所对应的单链表中插入b  a作为根 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = h[a];</span><br><span class="line">    h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回以u为根的子树中节点的个数，包括u节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    st[u] = <span class="literal">true</span>;<span class="comment">// 标记一下，记录为已经被搜索过了，下面进行搜索过程</span></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>,sum = <span class="number">1</span>;<span class="comment">//存储 删掉某个节点之后，以下连接的最大的连通子图节点数  ;//存储 以u为根的树 的节点数, 包括u，如图中的4号节点</span></span><br><span class="line">    <span class="comment">//访问u的每个子节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u];i != <span class="number">-1</span>;i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="comment">//因为每个节点的编号都是不一样的，所以 用编号为下标 来标记是否被访问过</span></span><br><span class="line">        <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="built_in">dfs</span>(j);<span class="comment">// u节点的单棵子树节点数 如图中的size值</span></span><br><span class="line">            res = <span class="built_in">max</span>(res,s);<span class="comment">// 记录最大联通子图的节点数</span></span><br><span class="line">            sum += s;<span class="comment">//以j为根的树 的节点数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//n-sum 如图中的n-size值，不包括根节点4；</span></span><br><span class="line">    res = <span class="built_in">max</span>(res,n - sum);<span class="comment">// 选择u节点为重心，最大的 连通子图节点数</span></span><br><span class="line">    ans = <span class="built_in">min</span>(res,ans);<span class="comment">//遍历过的假设重心中，最小的最大联通子图的 节点数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));<span class="comment">//初始化h数组 -1表示尾节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i ++)<span class="comment">// 树中是不存在环的，对于有n个节点的树，必定是n-1条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);<span class="comment">//无向图</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);<span class="comment">//可以任意选定一个节点开始 u&lt;=n </span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图中点的层次"><a href="#图中点的层次" class="headerlink" title=" 图中点的层次"></a><a href="#图中点的层次" title="图中点的层次"></a> 图中点的层次</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度  <span class="built_in">O</span>(n+m) , n 表示点数，m 表示边数</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">st[<span class="number">1</span>] = <span class="literal">true</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>; <span class="comment">// 表示点j已经被遍历过</span></span><br><span class="line">            q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码（自己创建队列）：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> d[N],q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b,ne[idx] = h[a],h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">0</span>;</span><br><span class="line">    q[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="built_in">sizeof</span>(d));</span><br><span class="line">    </span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)&#123;<span class="comment">//当我们的队列不为空时</span></span><br><span class="line">        <span class="type">int</span> t = q[hh ++];<span class="comment">//取出队列头部节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t];i != <span class="number">-1</span>;i = ne[i])&#123;<span class="comment">//遍历t节点的每一个邻边</span></span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j] == <span class="number">-1</span>)&#123;<span class="comment">//如果j没有被扩展过</span></span><br><span class="line">                d[j] = d[t] + <span class="number">1</span>;<span class="comment">//d[j]存储j节点离起点的距离，并标记为访问过</span></span><br><span class="line">                q[++ tt] = j;<span class="comment">//把j结点 压入队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i ++)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b,ne[idx] = h[a],h[a] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">-1</span>,<span class="built_in">sizeof</span>(d));</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(d[j] == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                d[j] = d[t] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">bfs</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有向图的拓扑序列"><a href="#有向图的拓扑序列" class="headerlink" title=" 有向图的拓扑序列"></a><a href="#有向图的拓扑序列" title="有向图的拓扑序列"></a> 有向图的拓扑序列</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">时间复杂度 <span class="built_in">O</span>(n+m), n 表示点数，m 表示边数</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// d[i] 存储点i的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (!d[i])</span><br><span class="line">            q[ ++ tt] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++ ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (-- d[j] == <span class="number">0</span>)</span><br><span class="line">                q[ ++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。</span></span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2020/10/03/42785_69de790205-340CA66F0E58E3A09FB0A5C1295F64FD.jpg" alt="340CA66F0E58E3A09FB0A5C1295F64FD.jpg"></p><p><strong><em>代码（模拟队列）：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> q[N],d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b,ne[idx] = h[a],h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> hh = <span class="number">0</span>,tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">if</span>(!d[i]) </span><br><span class="line">            q[++ tt] = i;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">while</span>(hh &lt;= tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q[hh ++];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            d[j] --;</span><br><span class="line">            <span class="keyword">if</span>(!d[j]) </span><br><span class="line">                q[++ tt] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tt == n - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));   <span class="comment">//要注意，非常重要</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        d[b] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">topsort</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码（用队列）：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> d[N],g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b,ne[idx] = h[a],h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> tt = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">if</span>(!d[i])</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        g[++ tt] = t;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            d[j] --;</span><br><span class="line">            <span class="keyword">if</span>(!d[j])</span><br><span class="line">                q.<span class="built_in">push</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tt == n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        d[b] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">topsort</span>())</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,g[i]);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dijkstra求最短路-I（朴素版）"><a href="#dijkstra求最短路-I（朴素版）" class="headerlink" title="dijkstra求最短路 I（朴素版）"></a>dijkstra求最短路 I（朴素版）</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">朴素dijkstra算法 </span><br><span class="line">时间复杂是 <span class="built_in">O</span>(n2+m), n 表示点数，m 表示边数</span><br><span class="line"><span class="type">int</span> g[N][N];  <span class="comment">// 存储每条边</span></span><br><span class="line"><span class="type">int</span> dist[N];  <span class="comment">// 存储1号点到每个点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];   <span class="comment">// 存储每个点的最短路是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路，如果不存在则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;     <span class="comment">// 在还未确定最短路的点中，寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用t更新其他点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + g[t][j]);</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的第一个循环就是为了循环n - 1次，如果改成while也可以ac，但是记得先定义一下，后面n还要用的。</p><p>第一个for循环就是为了找到dist[]有值且最小的点，&amp;&amp;左边的条件自然就是为了过滤掉不在集合里面的点，右边的条件很好理解。先记住t == -1就是为了把第一个不在集合里面的点读进来，然后再与其他存在dist的点一个一个的比较。如果第一个点没有dist也没有关系，因为定义的没有dist是无限大，会被其他dist较小的数取代的。这样就保证第一个循环过滤出我们需要的点。</p><p>需要注意的是第二个循环，他不止把当前最小点t的dist改成了正确值，如果是这样的话只用写这一句话就够了，那就不需要循环了。这里还把t之前的数遍历了一遍（但是已经是最小值了，所以结果不变），t之后还存在dist的数如果由于t的值更新了也会更新成最新一版的最小值，这里是y总课上没强调但是很重要的地方。</p><p>Dijkstra<br>朴素版dijkstra适合稠密图<br>思路<br>集合S为已经确定最短路径的点集。</p><ol><li>初始化距离<br>一号结点的距离为零，其他结点的距离设为无穷大（看具体的题）。</li><li>循环n次，每一次将集合S之外距离最短X的点加入到S中去（这里的距离最短指的是距离1号点最近。点X的路径一定最短，基于贪心，严格证明待看）。然后用点X更新X邻接点的距离。<br>时间复杂度分析<br>寻找路径最短的点：O(n^2)</li></ol><p>加入集合S：O(n)</p><p>更新距离：O(m)</p><p>所以总的时间复杂度为O(n^2)</p><p>1、问题：为什么Dijkstra不能使用在含负权的图中？（在强大的网友指点下已进行修改）<br>（这是以前错误的分析，若看完这个例子分析觉得正确的说明对最短路理解得还不够透彻，这里不做删除）<br>分析：如图所示：<br>若通过Dijkstra算法可以求出从1号点到达4号点所需的步数为3 (每次选择离源点最短距离的点更新其他点)<br>但实际上从 1 号点到达 4 号点所需步数为 1 (1 –&gt; 2 –&gt; 3),因此不能使用 Dijkstra 解决含负权图的问题</p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2019/11/16/7416_7cf3c78208-200fb33caef2d3ce435369aaa777f83.png" alt="200fb33caef2d3ce435369aaa777f83.png"></p><p>正确的分析<br>Dijkstra算法的3个步骤</p><p>1、找到当前未标识的且离源点最近的点t<br>2、对t号点点进行标识<br>3、用t号点更新其他点的距离<br>反例</p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2020/11/27/7416_181359f430-8886031fd08869a6757d4c704c6f355.png" alt="8886031fd08869a6757d4c704c6f355.png"></p><p>结果：</p><p>dijkstra算法在图中走出来的最短路径是1 -&gt; 2 -&gt; 4 -&gt; 5，算出 1 号点到 5 号点的最短距离是2 + 2 + 1 = 5，然而还存在一条路径是1 -&gt; 3 -&gt; 4 -&gt; 5，该路径的长度是5 + (-2) + 1 = 4，因此 dijkstra 算法失效</p><p>dijkstra详细步骤</p><p>初始dist[1] = 0<br>找到了未标识且离源点1最近的结点1，标记1号点，用1号点更新其他所有点的距离，2号点被更新成dist[2] = 2，3号点被更新成dist[3] = 5<br>找到了未标识且离源点1最近的结点2，标识2号点，用2号点更新其他所有点的距离，4号点被更新成dist[4] = 4<br>找到了未标识且离源点1最近的结点4，标识4号点，用4号点更新其他所有点的距离，5号点被更新成dist[5] = 5<br>找到了未标识且离源点1最近的结点3，标识3号点，用3号点更新其他所有点的距离，4号点被更新成dist[4] = 3<br>结束<br>得到1号点到5号点的最短距离是5，对应的路径是1 -&gt; 2 -&gt; 4 -&gt; 5，并不是真正的最短距离</p><p>迪杰斯特拉算法干的事情是：<strong>给定一个有向图，有向图的各个边都是正数，指定一个源点，求出源点到其余各个节点的最短距离。</strong></p><p>上述问题中，宿舍为源点，其余节点有图书馆，食堂，教学楼，网吧。求出宿舍到其它各点的最短距离。</p><p>迪杰斯特拉算法采用的是一种贪心的策略。</p><p>我们将图中各个节点用数字 1~ n 编号，源点的编号为 1。</p><p><img src= "/img/loading.gif" data-src="https://mmbiz.qpic.cn/mmbiz_png/rdGjKhoHHK3XZK0Pcic68lt8ibGSBgTAdngXEOfJGyPSKRhFicvxyNhXZocxlCD4oHA3ZN4WDguOgW8gEGFgGich5Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>​    求源点到其余各点的最短距离步骤如下：</p><ol><li><p>用一个 dist 数组保存源点到其余各个节点的距离，dist[i] 表示源点到节点 i 的距离。初始时，dist 数组的各个元素为无穷大。</p><p>用一个状态数组 state 记录是否找到了源点到该节点的最短距离，state[i] 如果为真，则表示找到了源点到节点 i 的最短距离，state[i] 如果为假，则表示源点到节点 i 的最短距离还没有找到。初始时，state 各个元素为假。</p></li></ol><p><img src= "/img/loading.gif" data-src="https://mmbiz.qpic.cn/mmbiz_png/rdGjKhoHHK3XZK0Pcic68lt8ibGSBgTAdnc0TdZ8YIz1YvGY7pic4QRTvZPXpiaCAGmoujSic9WTDnMGU3iautwmxURA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>2、源点到源点的距离为 0。即dist[1] = 0。</p><p><img src= "/img/loading.gif" data-src="https://mmbiz.qpic.cn/mmbiz_png/rdGjKhoHHK3XZK0Pcic68lt8ibGSBgTAdnWrE5o5opj0x8lrvsbJNLp9DWsibdflbZYQnf9VIYVzZqXlegGIIWwmQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>3、遍历 dist 数组，找到一个节点，这个节点是：没有确定最短路径的节点中距离源点最近的点。假设该节点编号为 i。此时就找到了源点到该节点的最短距离，state[i] 置为 1。</p><p><img src= "/img/loading.gif" data-src="https://mmbiz.qpic.cn/mmbiz_png/rdGjKhoHHK3XZK0Pcic68lt8ibGSBgTAdnSXl0Y00YxLyVicE1Ga7IQUDrYv1ibndG89U04U6FUxubEMdUjCElMgsA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>4、遍历 i 所有可以到达的节点 j，如果 dist[j] 大于 dist[i] 加上 i -&gt; j 的距离，即 dist[j] &gt; dist[i] + w[i][j]（w[i][j] 为 i -&gt; j 的距离） ，则更新 dist[j] = dist[i] + w[i][j]。</p><p><img src= "/img/loading.gif" data-src="https://mmbiz.qpic.cn/mmbiz_png/rdGjKhoHHK3XZK0Pcic68lt8ibGSBgTAdnzVibnEibXdjhuFNicibCYv7UfMmZNOOSJCYd6MSliaRjnwcWaibgecW6tRicw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>5、重复 3 4 步骤，直到所有节点的状态都被置为 1。</p><p><img src= "/img/loading.gif" data-src="https://mmbiz.qpic.cn/mmbiz_png/rdGjKhoHHK3XZK0Pcic68lt8ibGSBgTAdniaSyoa4RIVOy3BDj4EaxKiaob6w5vfiaXUSrrLujpsE1EupribWDJ7lJag/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>6、此时 dist 数组中，就保存了源点到其余各个节点的最短距离。</p><p><img src= "/img/loading.gif" data-src="https://mmbiz.qpic.cn/mmbiz_png/rdGjKhoHHK3XZK0Pcic68lt8ibGSBgTAdnssn2iaQtQQ8Xn0yr8fickVrrme55YbZXRuich8bsdJxxQT6s5K3lGP3lg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N][N];<span class="comment">//为稠密阵所以用邻接矩阵存储</span></span><br><span class="line"><span class="type">int</span> dist[N];<span class="comment">//用于记录每一个点距离第一个点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];<span class="comment">//用于记录该点的最短距离是否已经确定</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">    </span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//第一个点到自身的距离为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)<span class="comment">//有n个点所以要进行n次 迭代</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;<span class="comment">//t存储当前访问的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j ++)<span class="comment">//这里的j代表的是从1号点开始</span></span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">                </span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j ++) <span class="comment">//依次更新每个点所到相邻的点路径值</span></span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j],dist[t] + g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        g[a][b] = <span class="built_in">min</span>(g[a][b],c); <span class="comment">//如果发生重边的情况则保留最短的一条边</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">dijkstra</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,t);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dijkstra求最短路II（堆优化版）"><a href="#dijkstra求最短路II（堆优化版）" class="headerlink" title=" dijkstra求最短路II（堆优化版）"></a><a href="#dijkstra求最短路II（堆优化版）" title="dijkstra求最短路II（堆优化版）"></a> dijkstra求最短路II（堆优化版）</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">堆优化版dijkstra</span><br><span class="line">时间复杂度 <span class="built_in">O</span>(mlogn), n 表示点数，m 表示边数</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;      <span class="comment">// 点的数量</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储所有点到1号点的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点的最短距离是否已确定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短距离，如果不存在，则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>, <span class="number">1</span>&#125;);      <span class="comment">// first存储距离，second存储节点编号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ver = t.second, distance = t.first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[ver]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[ver]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; distance + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = distance + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2019/11/14/7416_fcf5a06606-eac97a72da924b845002f98e1c727f3.png" alt="eac97a72da924b845002f98e1c727f3.png"></p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2019/11/14/7416_d82210b206-55fec2d8dd5e91cdc6f8b5d179a7d19.png" alt="55fec2d8dd5e91cdc6f8b5d179a7d19.png"></p><p>注意：若要求任意点i到任意个点j的最短距离，只需修改dijkstra方法中的起源位置dist[i] = 0，以及返回为dist[j]</p><p>时间复杂度 O(mlogn)<br>每次找到最小距离的点沿着边更新其他的点，若dist[j] &gt; distance + w[i]，表示可以更新dist[j]，更新后再把j点和对应的距离放入小根堆中。由于点的个数是n，边的个数是m，在极限情况下（稠密图m=n(n−1)2m=n(n−1)2）最多可以更新m回，每一回最多可以更新n个点（严格上是n - 1个点），有m回，因此最多可以把n2个点放入到小根堆中，因此每一次更新小根堆排序的情况是O(log(n2))O(log(n2))，一共最多m次更新，因此总的时间复杂度上限是O(mlog((n2)))=O(2mlogn)=O(mlogn)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; q;</span><br></pre></td></tr></table></figure><p>是将元素从小到大输出，其中第二个参数为容器类型，第三个参数为比较函数</p><p>​    continue主要是为了处理已经更新过的点进行重复更新。不写，continue答案也是正确的，但是会处理许多重复的数据。这样就和朴素的dijkstra一样了，反而还多了个维护堆的时间。</p><p>q.push{(0, 1)}改成q.push{(1,0)} 然后把后边的x换成y为啥是错的？</p><p>priority_queue 是按照pair的第一个进行排序的把，所以distance应该放在前面。</p><p>堆优化版dijkstra适合稀疏图<br>思路<br>堆优化版的dijkstra是对朴素版dijkstra进行了优化，在朴素版dijkstra中时间复杂度最高的寻找距离最短的点O(n^2)可以使用最小堆优化。</p><ol><li>一号点的距离初始化为零，其他点初始化成无穷大。</li><li>将一号点放入堆中。</li><li>不断循环，直到堆空。每一次循环中执行的操作为：<br> 弹出堆顶（与朴素版diijkstra找到S外距离最短的点相同，并标记该点的最短路径已经确定）。<br> 用该点更新临界点的距离，若更新成功就加入到堆中。<br> 时间复杂度分析<br> 寻找路径最短的点：O(n)</li></ol><p>加入集合S：O(n)</p><p>更新距离：O(mlogn)</p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">150010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],e[N],w[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b,w[idx] = c,ne[idx] = h[a],h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt; heap;</span><br><span class="line">    heap.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> distance = t.first,ver = t.second;</span><br><span class="line">        <span class="keyword">if</span>(st[ver])  <span class="keyword">continue</span>;</span><br><span class="line">        st[ver] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[ver] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[ver] + w[i];</span><br><span class="line">                heap.<span class="built_in">push</span>(&#123;dist[j],j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="built_in">dijkstra</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="“有边数限制的最短路（bellman-ford贝福曼—福特算法-”-有边数限制的最短路（bellman-ford贝福曼—福特算法"><a href="#“有边数限制的最短路（bellman-ford贝福曼—福特算法-”-有边数限制的最短路（bellman-ford贝福曼—福特算法" class="headerlink" title=" “有边数限制的最短路（bellman_ford贝福曼—福特算法)”) 有边数限制的最短路（bellman_ford贝福曼—福特算法)"></a><a href="#有边数限制的最短路（bellman_ford贝福曼—福特算法"></a> “有边数限制的最短路（bellman_ford贝福曼—福特算法)”) 有边数限制的最短路（bellman_ford贝福曼—福特算法)</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Bellman-Ford算法</span><br><span class="line">时间复杂度 <span class="built_in">O</span>(nm), n 表示点数，m 表示边数</span><br><span class="line">注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题。</span><br><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n表示点数，m表示边数</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// dist[x]存储1到x的最短路距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>     <span class="comment">// 边，a表示出点，b表示入点，w表示边的权重</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1到n的最短路距离，如果无法从1走到n，则返回-1。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;</span><br><span class="line">            <span class="keyword">if</span> (dist[b] &gt; dist[a] + w)</span><br><span class="line">                dist[b] = dist[a] + w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、什么是bellman - ford算法？<br>Bellman - ford 算法是求含负权图的单源最短路径的一种算法，效率较低，代码难度较小。其原理为连续进行松弛，在每次松弛时把每条边都更新一下，若在 n-1 次松弛后还能更新，则说明图中有负环，因此无法得出结果，否则就完成。<br>(通俗的来讲就是：假设 1 号点到 n 号点是可达的，每一个点同时向指向的方向出发，更新相邻的点的最短距离，通过循环 n-1 次操作，若图中不存在负环，则 1 号点一定会到达 n 号点，若图中存在负环，则在 n-1 次松弛后一定还会更新)</p><p>2、bellman - ford算法的具体步骤<br>for n次<br>for 所有边 a,b,w (松弛操作)<br>dist[b] = min(dist[b],back[a] + w)</p><p>注意：back[] 数组是上一次迭代后 dist[] 数组的备份，由于是每个点同时向外出发，因此需要对 dist[] 数组进行备份，若不进行备份会因此发生串联效应，影响到下一个点</p><p>3、在下面代码中，是否能到达n号点的判断中需要进行if(dist[n] &gt; INF/2)判断，而并非是if(dist[n] == INF)判断，原因是INF是一个确定的值，并非真正的无穷大，会随着其他数值而受到影响，dist[n]大于某个与INF相同数量级的数即可<br>4、bellman - ford算法擅长解决有边数限制的最短路问题<br>时间复杂度 O(nm)O(nm)<br>其中n为点数，m为边数</p><p>加入每条边去松弛每个点到起点的距离<br>dist[b] = min(dist[b], backup[a] + w);<br>为什么需要back[a]数组<br>为了避免如下的串联情况， 在边数限制为一条的情况下，节点3的距离应该是3，但是由于串联情况，利用本轮更新的节点2更新了节点3的距离，所以现在节点3的距离是2。</p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2020/06/02/652_8fb5d1dca4-2.PNG" alt="2.PNG"></p><p>正确做法是用上轮节点2更新的距离–无穷大，来更新节点3， 再取最小值，所以节点3离起点的距离是3。</p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2020/06/02/652_bf119614a4-3.PNG" alt="3.PNG"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>,M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> last[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; k;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(last,dist,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; m;j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            Edge t = edges[j];</span><br><span class="line">            dist[t.b] = <span class="built_in">min</span>(dist[t.b],last[t.a] + t.c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        edges[i] = &#123;a,b,c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">bellman_ford</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] &gt; <span class="number">0x3f3f3f3f</span> / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; dist[n] &lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="spfa求最短路"><a href="#spfa求最短路" class="headerlink" title=" spfa求最短路"></a><a href="#spfa求最短路" title="spfa求最短路"></a> spfa求最短路</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">spfa 算法（队列优化的Bellman-Ford算法）</span><br><span class="line">时间复杂度 平均情况下 <span class="built_in">O</span>(m)，最坏情况下 <span class="built_in">O</span>(nm), n 表示点数，m 表示边数</span><br><span class="line"><span class="type">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储每个点到1号点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span> (!st[j])     <span class="comment">// 如果队列中已存在j，则不需要将j重复插入</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bellman_ford算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新；因此考虑到这一点，我们将创建一个队列每一次加入距离被更新的结点。</p><p>值得注意的是</p><p>1) st数组的作用：判断当前的点是否已经加入到队列当中了；已经加入队列的结点就不需要反复的把该点加入到队列中了，就算此次还是会更新到源点的距离，那只用更新一下数值而不用加入到队列当中。<br>即便不使用st数组最终也没有什么关系，但是使用的好处在于可以提升效率。<br>2) SPFA算法看上去和Dijstra算法长得有一些像但是其中的意义还是相差甚远的:</p><p>1] Dijkstra算法中的st数组保存的是当前确定了到源点距离最小的点，且一旦确定了最小那么就不可逆了(不可标记为true后改变为false)；SPFA算法中的st数组仅仅只是表示的当前发生过更新的点，且spfa中的st数组可逆(可以在标记为true之后又标记为false)。顺带一提的是BFS中的st数组记录的是当前已经被遍历过的点。<br>2] Dijkstra算法里使用的是优先队列保存的是当前未确定最小距离的点，目的是快速的取出当前到源点距离最小的点；SPFA算法中使用的是队列(你也可以使用别的数据结构),目的只是记录一下当前发生过更新的点。</p><p>3) ⭐️Bellman_ford算法里最后return-1的判断条件写的是dist[n]&gt;0x3f3f3f3f/2;而spfa算法写的是dist[n]==0x3f3f3f3f;其原因在于Bellman_ford算法会遍历所有的边，因此不管是不是和源点连通的边它都会得到更新；但是SPFA算法不一样，它相当于采用了BFS，因此遍历到的结点都是与源点连通的，因此如果你要求的n和源点不连通，它不会得到更新，还是保持的0x3f3f3f3f。</p><p>4) ⭐️ Bellman_ford算法可以存在负权回路，是因为其循环的次数是有限制的因此最终不会发生死循环；但是SPFA算法不可以，由于用了队列来存储，只要发生了更新就会不断的入队，因此假如有负权回路请你不要用SPFA否则会死循环。</p><p>5) ⭐️由于SPFA算法是由Bellman_ford算法优化而来，在最坏的情况下时间复杂度和它一样即时间复杂度为 O(nm) ，假如题目时间允许可以直接用SPFA算法去解Dijkstra算法的题目。(好像SPFA有点小小万能的感觉?)</p><p>6) ⭐️求负环一般使用SPFA算法，方法是用一个cnt数组记录每个点到源点的边数，一个点被更新一次就+1，一旦有点的边数达到了n那就证明存在了负环。</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cqq144%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220107162051195.png" alt="image-20220107162051195"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[N],w[N],idx;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b,w[idx] = c,ne[idx] = h[a],h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">false</span>;<span class="comment">//从队列中取出来之后该节点st被标记为false,代表之后该节点如果发生更新可再次入队</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])<span class="comment">//当前已经加入队列的结点，无需再次加入队列，即便发生了更新也只用更新数值即可，重复添加降低效率</span></span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">spfa</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n] == <span class="number">0x3f3f3f3f</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; dist[n];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spfa判断负环"><a href="#spfa判断负环" class="headerlink" title=" spfa判断负环"></a><a href="#spfa判断负环" title="spfa判断负环"></a> spfa判断负环</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">spfa判断图中是否存在负环 </span><br><span class="line">时间复杂度是 <span class="built_in">O</span>(nm), n 表示点数，m 表示边数</span><br><span class="line"><span class="type">int</span> n;      <span class="comment">// 总点数</span></span><br><span class="line"><span class="type">int</span> h[N], w[N], e[N], ne[N], idx;       <span class="comment">// 邻接表存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];        <span class="comment">// dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否在队列中</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果存在负环，则返回true，否则返回false。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不需要初始化dist数组</span></span><br><span class="line">    <span class="comment">// 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。</span></span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h[t]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span> (dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;       <span class="comment">// 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环</span></span><br><span class="line">                <span class="keyword">if</span> (!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/29/2675_b6ceb1e090-1.jpg" alt="1.jpg"></p><p>使用spfa算法解决是否存在负环问题</p><p>求负环的常用方法，基于SPFA，一般都用方法 2（该题也是用方法 2）：</p><p>方法 1：统计每个点入队的次数，如果某个点入队n次，则说明存在负环<br>方法 2：统计当前每个点的最短路中所包含的边数，如果某点的最短路所包含的边数大于等于n，则也说明存在环<br>y总的原话<br>每次做一遍spfa()一定是正确的，但时间复杂度较高，可能会超时。初始时将所有点插入队列中可以按如下方式理解：<br>在原图的基础上新建一个虚拟源点，从该点向其他所有点连一条权值为0的有向边。那么原图有负环等价于新图有负环。此时在新图上做spfa，将虚拟源点加入队列中。然后进行spfa的第一次迭代，这时会将所有点的距离更新并将所有点插入队列中。执行到这一步，就等价于视频中的做法了。那么视频中的做法可以找到负环，等价于这次spfa可以找到负环，等价于新图有负环，等价于原图有负环。得证。</p><p>1、dist[x] 记录虚拟源点到x的最短距离</p><p>2、cnt[x] 记录当前x点到虚拟源点最短路的边数，初始每个点到虚拟源点的距离为0 ，只要他能再走n步，即cnt[x] &gt;= n，则表示该图中一定存在负环，由于从虚拟源点到x至少经过n条边时，则说明图中至少有n + 1个点，表示一定有点是重复使用</p><p>3、若dist[j] &gt; dist[t] + w[i],则表示从t点走到j点能够让权值变少，因此进行对该点j进行更新，并且对应cnt[j] = cnt[t] + 1,往前走一步</p><p>注意：该题是判断是否存在负环，并非判断是否存在从1开始的负环，因此需要将所有的点都加入队列中，更新周围的点</p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2019/11/17/7416_c07bce6a08-af80e800140cbcf01e93d657d712a60.png" alt="af80e800140cbcf01e93d657d712a60.png"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2010</span>,M = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],w[M],idx;</span><br><span class="line"><span class="type">int</span> dist[N],cnt[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b,w[idx] = c,ne[idx] = h[a],h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">        st[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[t];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; dist[t] + w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j] = dist[t] + w[i];</span><br><span class="line">                cnt[j] = cnt[t] + <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(cnt[j] &gt;= n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">spfa</span>()) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="floyd求最短路"><a href="#floyd求最短路" class="headerlink" title=" floyd求最短路"></a><a href="#floyd求最短路" title="floyd求最短路"></a> floyd求最短路</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">floyd算法</span><br><span class="line">时间复杂度是 <span class="built_in">O</span>(n3)<span class="built_in">O</span>(n3), nn 表示点数</span><br><span class="line">初始化：</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 算法结束后，d[a][b]表示a到b的最短距离</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​       <strong>f[i, j, k]表示从i走到j的路径上除i和j点外只经过1到k的点的所有路径的最短距离。那么f[i, j, k] = min(f[i, j, k - 1), f[i, k, k - 1] + f[k, j, k - 1]。</strong><br><strong>因此在计算第k层的f[i, j]的时候必须先将第k - 1层的所有状态计算出来，所以需要把k放在最外层。</strong></p><p>f[k] [i] [j]可以从两种情况转移而来：<br>    【1】从f[k−1] [i] [j]转移而来，表示i到j的最短路径不经过k这个节点<br>    【2】从f[k−1] [i] [k]+f[k−1] [k] [j]转移而来，表示i到j的最短路径经过k这个节点</p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>,INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,Q;</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt;= n;k ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j],d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;Q);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j ++)</span><br><span class="line">            <span class="keyword">if</span>(i == j) d[i][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j] = INF;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">        </span><br><span class="line">        d[a][b] = <span class="built_in">min</span>(d[a][b],c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">floyd</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(Q --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(d[a][b] &gt; INF / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,d[a][b]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最短路问题"><a href="#最短路问题" class="headerlink" title=" 最短路问题"></a><a href="#最短路问题" title="最短路问题"></a> 最短路问题</h3><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2019/12/13/1833_db6dffa81d-37ff39642fd8f74476ddcd99944d1b4.png" alt="37ff39642fd8f74476ddcd99944d1b4.png"></p><p>文字性复习<br>Dijkstra-朴素O(n^2)</p><p>1、初始化距离数组, dist[1] = 0, dist[i] = inf;<br>2、for n次循环 每次循环确定一个min加入S集合中，n次之后就得出所有的最短距离<br>3、将不在S中dist_min的点-&gt;t<br>4、t-&gt;S加入最短路集合<br>5、用t更新到其他点的距离<br>Dijkstra-堆优化O(mlogm)</p><p>1、利用邻接表，优先队列<br>2、在priority_queue[HTML_REMOVED], greater[HTML_REMOVED] &gt; heap;中将返回堆顶<br>3、利用堆顶来更新其他点，并加入堆中类似宽搜<br>Bellman_fordO(nm)</p><p>1、注意连锁想象需要备份, struct Edge{inta,b,c} Edge[M];<br>2、初始化dist, 松弛dist[x.b] = min(dist[x.b], backup[x.a]+x.w);<br>3、松弛k次，每次访问m条边<br>Spfa O(n)~O(nm)</p><p>1、利用队列优化仅加入修改过的地方<br>2、for k次<br>3、for 所有边利用宽搜模型去优化bellman_ford算法<br>4、更新队列中当前点的所有出边<br>Floyd O(n^3)</p><p>1、初始化d<br>2、k, i, j 去更新d</p><h3 id="Prim求最小生成树"><a href="#Prim求最小生成树" class="headerlink" title=" Prim求最小生成树"></a><a href="#Prim求最小生成树" title="Prim求最小生成树"></a> Prim求最小生成树</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">朴素版prim算法 </span><br><span class="line">时间复杂度是 <span class="built_in">O</span>(n2+m), n 表示点数，m 表示边数</span><br><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> g[N][N];        <span class="comment">// 邻接矩阵，存储所有边</span></span><br><span class="line"><span class="type">int</span> dist[N];        <span class="comment">// 存储其他点到当前最小生成树的距离</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 存储每个点是否已经在生成树中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dist);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ )</span><br><span class="line">            <span class="keyword">if</span> (!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i) res += dist[t];</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++ ) dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prim 算法干的事情是：给定一个无向图，在图中选择若干条边把图的所有节点连起来。要求边长之和最小。在图论中，叫做求最小生成树。</p><p>prim 算法采用的是一种贪心的策略。</p><p>每次将离连通部分的最近的点和点对应的边加入的连通部分，连通部分逐渐扩大，最后将整个图连通起来，并且边长之和最小。</p><p>我们将图中各个节点用数字 1 ~ n 编号。</p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/04/55289_508d58977c-05.png" alt="05.png"></p><p>要将所有景点连通起来，并且边长之和最小，步骤如下：</p><p>1、用一个 state 数组表示节点是否已经连通。state[i] 为真，表示已经连通，state[i] 为假，表示还没有连通。初始时，state 各个元素为假。即所有点还没有连通。<br>用一个 dist 数组保存各个点到连通部分的最短距离，dist[i] 表示 i 节点到连通部分的最短距离。初始时，dist 数组的各个元素为无穷大。<br>用一个 pre 数组保存节点的是和谁连通的。pre[i] = k 表示节点 i 和节点 k 之间需要有一条边。初始时，pre 的各个元素置为 -1。</p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/04/55289_3e1d300c7c-06.png" alt="06.png"></p><p>2、从 1 号节点开始扩充连通的部分，所以 1 号节点与连通部分的最短距离为 0，即disti[1] 置为 0。</p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/04/55289_86b312a17c-07.png" alt="07.png"></p><p>3、遍历 dist 数组，找到一个还没有连通起来，但是距离连通部分最近的点，假设该节点的编号是 i。i节点就是下一个应该加入连通部分的节点，stata[i] 置为 1。<br>用青色点表示还没有连通起来的点，红色点表示连通起来的点。<br>这里青色点中距离最小的是 dist[1]，因此 state[1] 置为 1。</p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/04/55289_23b31ed37c-08.png" alt="08.png"></p><p>遍历所有与 i 相连但没有加入到连通部分的点 j，如果 j 距离连通部分的距离大于 i j 之间的距离，即 dist[j] &gt; w[i][j]（w[i][j] 为 i j 节点之间的距离），则更新 dist[j] 为 w[i][j]。这时候表示，j 到连通部分的最短方式是和 i 相连，因此，更新pre[j] = i。<br>与节点 1 相连的有 2， 3， 4 号节点。1-&gt;2 的距离为 100，小于 dist[2]，dist[2] 更新为 100，pre[2] 更新为1。1-&gt;4 的距离为 140，小于 dist[4]，dist[4] 更新为 140，pre[2] 更新为1。1-&gt;3 的距离为 150，小于 dist[3]，dist[3] 更新为 150，pre[3] 更新为1。</p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/04/55289_370887c27c-09.png" alt="09.png"></p><p>5、重复 3 4步骤，直到所有节点的状态都被置为 1.<br>这里青色点中距离最小的是 dist[2]，因此 state[2] 置为 1。</p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/04/55289_48eb08287c-10.png" alt="10.png"></p><p>与节点 2 相连的有 5， 4号节点。2-&gt;5 的距离为 80，小于 dist[5]，dist[5] 更新为 80，pre[5] 更新为 2。2-&gt;4 的距离为 80，小于 dist[4]，dist[4] 更新为 80，pre[4] 更新为2。</p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/04/55289_51ea62357c-11.png" alt="11.png"></p><p>选dist[4]，更新dist[3]，dist[5]，pre[3]，pre[5]。</p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/04/55289_5d199a9e7c-12.png" alt="12.png"></p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/04/55289_616a0f7a7c-13.png" alt="13.png"></p><p>选dist[5]，没有可更新的。</p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/04/55289_68115c167c-14.png" alt="14.png"></p><p>选dist[3]，没有可更新的。</p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/04/55289_6f7001247c-15.png" alt="15.png"></p><p>6、此时 dist 数组中保存了各个节点需要修的路长，加起来就是。pre 数组中保存了需要选择的边。</p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/03/04/55289_740316f47c-16.png" alt="16.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> g[N][N];<span class="comment">//存储图</span></span><br><span class="line"><span class="type">int</span> dt[N];<span class="comment">//存储各个节点到生成树的距离</span></span><br><span class="line"><span class="type">int</span> st[N];<span class="comment">//节点是否被加入到生成树中</span></span><br><span class="line"><span class="type">int</span> pre[N];<span class="comment">//节点的前去节点</span></span><br><span class="line"><span class="type">int</span> n, m;<span class="comment">//n 个节点，m 条边</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dt,<span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dt));<span class="comment">//初始化距离数组为一个很大的数（10亿左右）</span></span><br><span class="line">    <span class="type">int</span> res= <span class="number">0</span>;</span><br><span class="line">    dt[<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">//从 1 号节点开始生成 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)<span class="comment">//每次循环选出一个点加入到生成树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//每个节点一次判断</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dt[j] &lt; dt[t]))<span class="comment">//如果没有在树中，且到树的距离最短，则选择该点</span></span><br><span class="line">                t = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        st[t] = <span class="number">1</span>;<span class="comment">// 选择该点</span></span><br><span class="line">        res += dt[t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//更新生成树外的点到生成树的距离</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(dt[i] &gt; g[t][i] &amp;&amp; !st[i])<span class="comment">//从 t 到节点 i 的距离小于原来距离，则更新。</span></span><br><span class="line">            &#123;</span><br><span class="line">                dt[i] = g[t][i];<span class="comment">//更新距离</span></span><br><span class="line">                pre[i] = t;<span class="comment">//从 t 到 i 的距离更短，i 的前驱变为 t.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getPath</span><span class="params">()</span><span class="comment">//输出各个边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt; <span class="number">1</span>; i--)<span class="comment">//n 个节点，所以有 n-1 条边。</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; pre[i] &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; endl;<span class="comment">// i 是节点编号，pre[i] 是 i 节点的前驱节点。他们构成一条边。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(g));<span class="comment">//各个点之间的距离初始化成很大的数</span></span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;<span class="comment">//输入节点数和边数</span></span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, w;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;<span class="comment">//输出边的两个顶点和权重</span></span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b],w);<span class="comment">//存储权重</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">prim</span>();<span class="comment">//求最下生成树</span></span><br><span class="line">    <span class="comment">//getPath();//输出路径</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何判断稠密图还是稀疏图？</p><p>看m（边）是不是n的平方级别的，如果是，就是稠密图，否则就是稀疏图</p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>,INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j ++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span>(i &amp;&amp; dist[t] == INF) <span class="keyword">return</span> INF;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i) res += dist[t];</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j ++)</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j],g[t][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">        g[u][v] = g[v][u] =<span class="built_in">min</span>(g[u][v],w);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">prim</span>();</span><br><span class="line">    <span class="keyword">if</span>(t == INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kruskal求最小生成树（稀疏图）"><a href="#Kruskal求最小生成树（稀疏图）" class="headerlink" title=" Kruskal求最小生成树（稀疏图）"></a><a href="#Kruskal求最小生成树（稀疏图）" title="Kruskal求最小生成树（稀疏图）"></a> Kruskal求最小生成树（稀疏图）</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Kruskal算法</span><br><span class="line">时间复杂度是 <span class="built_in">O</span>(mlogm), n 表示点数，m 表示边数</span><br><span class="line"><span class="type">int</span> n, m;       <span class="comment">// n是点数，m是边数</span></span><br><span class="line"><span class="type">int</span> p[N];       <span class="comment">// 并查集的父节点数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span>     <span class="comment">// 存储边</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span>     <span class="comment">// 并查集核心操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);<span class="comment">//将边的权重按照大小一一排序</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) p[i] = i;    <span class="comment">// 初始化并查集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;</span><br><span class="line"></span><br><span class="line">        a = <span class="built_in">find</span>(a), b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span> (a != b)     <span class="comment">// 如果两个连通块不连通，则将这两个连通块合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; n - <span class="number">1</span>) <span class="keyword">return</span> INF;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2020/02/18/7416_09dce69452-d87215b6df3bbf95de3a123d64be7bd.png" alt="d87215b6df3bbf95de3a123d64be7bd.png"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,M = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b,w;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Edge &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(edges,edges + m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>,cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = edges[i].a,b = edges[i].b,w = edges[i].w;</span><br><span class="line">        </span><br><span class="line">        a = <span class="built_in">find</span>(a),b = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(a != b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += w;</span><br><span class="line">            cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cnt &lt; n - <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; m;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">        edges[i] = &#123;a,b,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">kruskal</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="染色法判定二分图"><a href="#染色法判定二分图" class="headerlink" title=" 染色法判定二分图"></a><a href="#染色法判定二分图" title="染色法判定二分图"></a> 染色法判定二分图</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">染色法判别二分图 —— 模板题 AcWing <span class="number">860.</span> 染色法判定二分图</span><br><span class="line">时间复杂度是 <span class="built_in">O</span>(n+m), n 表示点数，m 表示边数</span><br><span class="line"><span class="type">int</span> n;      <span class="comment">// n表示点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="type">int</span> color[N];       <span class="comment">// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数：u表示当前节点，c表示当前点的颜色</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[u]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (color[j] == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(j, !c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(color, <span class="number">-1</span>, <span class="keyword">sizeof</span> color);</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (color[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">dfs</span>(i, <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>染色法</em></strong><br>将所有点分成两个集合，使得所有边只出现在集合之间，就是二    分图<br>二分图：一定不含有奇数环，可能包含长度为偶数的环， 不一定是连通图<br><strong><em>dfs版本</em></strong><br>代码思路：<br>染色可以使用1和2区分不同颜色，用0表示未染色<br>遍历所有点，每次将未染色的点进行dfs, 默认染成1或者2<br>由于某个点染色成功不代表整个图就是二分图,因此只有某个点染色失败才能立刻break/return<br>染色失败相当于存在相邻的2个点染了相同的颜色</p><p><strong><em>代码（dfs）：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,M = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> color[N];</span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b,ne[idx] = h[a],h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!color[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(j,<span class="number">3</span> - c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!color[i])</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i,<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>bfs版本</em></strong><br>代码思路<br>颜色 1 和 2 表示不同颜色, 0 表示 未染色<br>定义queue是存PII，表示 &lt;点编号, 颜色&gt;,<br>同理，遍历所有点, 将未染色的点都进行bfs<br>队列初始化将第i个点入队, 默认颜色可以是1或2<br>while (队列不空)<br>每次获取队头t, 并遍历队头t的所有邻边<br>若邻边的点未染色则染上与队头t相反的颜色，并添加到队列<br>若邻边的点已经染色且与队头t的颜色相同, 则返回false</p><p><strong><em>代码（bfs）：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>,M = <span class="number">200010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="type">int</span> color[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b,ne[idx] = h[a],h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;PII&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;u,<span class="number">1</span>&#125;);</span><br><span class="line">    color[u] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        PII t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> ver = t.first,c = t.second;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = h[ver];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(!color[j])</span><br><span class="line">            &#123;</span><br><span class="line">                color[j] = <span class="number">3</span> - c;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;j,<span class="number">3</span> - c&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b),<span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!color[i])</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">bfs</span>(i))</span><br><span class="line">            &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分图的最大匹配"><a href="#二分图的最大匹配" class="headerlink" title=" 二分图的最大匹配"></a><a href="#二分图的最大匹配" title="二分图的最大匹配"></a> 二分图的最大匹配</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">匈牙利算法 —— 模板题 AcWing <span class="number">861.</span> 二分图的最大匹配</span><br><span class="line">时间复杂度是 <span class="built_in">O</span>(nm)<span class="built_in">O</span>(nm), nn 表示点数，mm 表示边数</span><br><span class="line"><span class="type">int</span> n1, n2;     <span class="comment">// n1表示第一个集合中的点数，n2表示第二个集合中的点数</span></span><br><span class="line"><span class="type">int</span> h[N], e[M], ne[M], idx;     <span class="comment">// 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span></span><br><span class="line"><span class="type">int</span> match[N];       <span class="comment">// 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个</span></span><br><span class="line"><span class="type">bool</span> st[N];     <span class="comment">// 表示第二个集合中的每个点是否已经被遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j])</span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span></span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i ++ )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/04/07/2675_afd49f7697-3.jpg" alt="3.jpg"></p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/04/07/2675_b4b68f2f97-5.jpg" alt="5.jpg"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>,M = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n1,n2,m;</span><br><span class="line"><span class="type">int</span> h[N],e[M],ne[M],idx;</span><br><span class="line"><span class="type">int</span> match[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b,ne[idx] = h[a],h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个函数的作用是用来判断,如果加入x来参与模拟配对,会不会使匹配数增多</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[x];i != <span class="number">-1</span>;i = ne[i])<span class="comment">//遍历自己喜欢的女孩</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!st[j])<span class="comment">//如果在这一轮模拟匹配中,这个女孩尚未被预定</span></span><br><span class="line">        &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;<span class="comment">//那x就预定这个女孩了</span></span><br><span class="line">            <span class="comment">//如果女孩j没有男朋友，或者她原来的男朋友能够预定其它喜欢的女孩。配对成功,更新match</span></span><br><span class="line">            <span class="keyword">if</span>(!match[j] || <span class="built_in">find</span>(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//自己中意的全部都被预定了。配对失败。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n1,&amp;n2,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;<span class="comment">//记录最大匹配</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n1;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st,<span class="literal">false</span>,<span class="built_in">sizeof</span>(st)); <span class="comment">//因为每次模拟匹配的预定情况都是不一样的所以每轮模拟都要初始化</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(i)) res ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a><a href="#数学知识" title="数学知识"></a>数学知识</h2><h3 id="试除法判定质数"><a href="#试除法判定质数" class="headerlink" title=" 试除法判定质数"></a><a href="#试除法判定质数" title="试除法判定质数"></a> 试除法判定质数</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">试除法判定质数 </span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个数的因数都是成对出现的：例如12的因数有3和4,2和6<br>所以我们可以只枚举较小的那一个，即根下n，假设较小的为d，较大的为n/d；</p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2019/08/13/1606_90142d60bd-%E6%8D%95%E8%8E%B719.PNG" alt="捕获19.PNG"></p><p>注意：sqrt(n)运行速度较慢不推荐；ii&lt;=n不推荐 因为如果long long int -&gt;n而i只是int 有可能ii溢出为负数 所以可以（LL）i*i</p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prime</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= x / i;i ++)</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">is_prime</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分解质因数"><a href="#分解质因数" class="headerlink" title=" 分解质因数"></a><a href="#分解质因数" title="分解质因数"></a> 分解质因数</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">试除法分解质因数 </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) x /= i, s ++ ;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据算术基本定理，不考虑排列顺序的情况下，每个正整数都能够以唯一的方式表示成它的质因数的乘积。<br>n=p1^a1 * p2^a2 *p3^a3…..pn^an<br>比如一个数16 在分解时先找到2这个质因子，然后由于16/2后还可以/2，所以会在2这个质因子上产生次方<br>不优化版本：从2~n 找到能整除的因子然后算次方<br>这里有个性质：n中最多只含有一个大于sqrt(n)的因子。证明通过反证法：如果有两个大于sqrt(n)的因子，那么相乘会大于n，矛盾。证毕<br>于是我们发现最多只有一个大于sqrt(n)的因子，对其进行优化。先考虑比sqrt(n)小的，代码和质数的判定类似<br>最后如果n还是&gt;1，说明这就是大于sqrt(n)的唯一质因子，输出即可。</p><p>在枚举到i之前已经把n中2到i-1的质因子除干净了，此时n中不含2到i-1的质因子，由于n为i的倍数，所以i中也不包含2到i-1的质因子。</p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= x / i;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,i,cnt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d 1\n&quot;</span>,x);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="built_in">divide</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="筛质数"><a href="#筛质数" class="headerlink" title=" 筛质数"></a><a href="#筛质数" title="筛质数"></a> 筛质数</h3><p>质数a×质数b=c<br>那么c的因数一定有1，a，b，c。所以为合数</p><p>100中有25个质数，74个合数，两个质数的乘积一定是合数</p><p>1.最普通的筛法 O(n log n) </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!st[i]) primes[cnt++]=i;<span class="comment">//把素数存起来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j+=i)&#123;<span class="comment">//不管是合数还是质数，都用来筛掉后面它的倍数</span></span><br><span class="line">            st[j]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.诶氏筛法 O(nloglogn)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            primes[cnt++]=i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j+=i) st[j]=<span class="literal">true</span>;<span class="comment">//可以用质数就把所有的合数都筛掉；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">朴素筛法求素数</span><br><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + i; j &lt;= n; j += i)</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">线性筛法求素数</span><br><span class="line"><span class="type">int</span> primes[N], cnt;     <span class="comment">// primes[]存储所有素数</span></span><br><span class="line"><span class="type">bool</span> st[N];         <span class="comment">// st[x]存储x是否被筛掉</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> primes[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//外层从2~n迭代，因为这毕竟算的是1~n中质数的个数，而不是某个数是不是质数的判定</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) primes[cnt++]=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;primes[j]&lt;=n/i;j++)&#123;<span class="comment">//primes[j]&lt;=n/i:变形一下得到——primes[j]*i&lt;=n,把大于n的合数都筛了就</span></span><br><span class="line">        <span class="comment">//没啥意义了，这样就不会去使得大于n的数true，也就是说，减少了不必要的计算。</span></span><br><span class="line">            st[primes[j]*i]=<span class="literal">true</span>;<span class="comment">//用最小质因子去筛合数</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//1)当i%primes[j]!=0时,说明此时遍历到的primes[j]不是i的质因子，那么只可能是此时的primes[j]&lt;i的</span></span><br><span class="line">            <span class="comment">//最小质因子,所以primes[j]*i的最小质因子就是primes[j];</span></span><br><span class="line">            <span class="comment">//2)当有i%primes[j]==0时,说明i的最小质因子是primes[j],因此primes[j]*i的最小质因子也就应该是</span></span><br><span class="line">            <span class="comment">//prime[j]，之后接着用st[primes[j+1]*i]=true去筛合数时，就不是用最小质因子去更新了,因为i有最小</span></span><br><span class="line">            <span class="comment">//质因子primes[j]&lt;primes[j+1],此时的primes[j+1]不是primes[j+1]*i的最小质因子，此时就应该</span></span><br><span class="line">            <span class="comment">//退出循环，避免之后重复进行筛选。</span></span><br><span class="line">            <span class="keyword">if</span>(i%primes[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">get_primes</span>();</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="试除法求约数"><a href="#试除法求约数" class="headerlink" title=" 试除法求约数"></a><a href="#试除法求约数" title="试除法求约数"></a> 试除法求约数</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">试除法求所有约数 —— 模板题 AcWing <span class="number">869.</span> 试除法求约数</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= x / i; i ++ )</span><br><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (i != x / i) res.<span class="built_in">push_back</span>(x / i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码（动态数组）：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisor</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= x / i;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(i != x / i) </span><br><span class="line">                res.<span class="built_in">push_back</span>(x / i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">get_divisor</span>(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t : res) cout &lt;&lt; t &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in">sizeof</span>(d));</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= x / i;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            d[cnt ++] = i;</span><br><span class="line">            <span class="keyword">if</span>(i != x / i) d[cnt ++] = x / i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(d,d + cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; cnt;i ++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,d[i]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        <span class="built_in">get_divisors</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="约数个数"><a href="#约数个数" class="headerlink" title=" 约数个数"></a><a href="#约数个数" title="约数个数"></a> 约数个数</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">约数个数和约数之和 </span><br><span class="line">如果 N = p1^c1 * p2^c2 * ... *pk^ck</span><br><span class="line">约数个数： (c1 + <span class="number">1</span>) * (c2 + <span class="number">1</span>) * ... * (ck + <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cqq144%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220109231233565.png" alt="image-20220109231233565"></p><blockquote><p>24=2 * 2 * 2 * 3=2³ * 3<br>再用各个质数的指数加一后再相乘即为此数的约数个数，<br>比如 (3+1)<em>(1+1)=4</em>2=8， 即表示24有8个约数。<br>24的约数:1、2、3、4、6、8、1 2、24</p></blockquote><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; primes;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= x / i;i ++)</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                primes[i] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">1</span>) primes[x] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;    <span class="comment">// res在int的范围里，但是res*(p.second+1)不一定在int的范围里面，所以要用longlong</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : primes) res = res * (p.second + <span class="number">1</span>) % mod;  </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="约数之和"><a href="#约数之和" class="headerlink" title=" 约数之和"></a><a href="#约数之和" title="约数之和"></a> 约数之和</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">约数之和： (p1^<span class="number">0</span> + p1^<span class="number">1</span> + ... + p1^c1) * ... * (pk^<span class="number">0</span> + pk^<span class="number">1</span> + ... + pk^ck)</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cqq144%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220110104245820.png" alt="image-20220110104245820"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; primes;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= x / i;i ++)</span><br><span class="line">            <span class="keyword">while</span>(x % i == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                primes[i] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; <span class="number">1</span>) primes[x] ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : primes)</span><br><span class="line">    &#123;</span><br><span class="line">        LL a = p.first,b = p.second;</span><br><span class="line">        LL t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(b --) t = (t * a + <span class="number">1</span>) % mod;</span><br><span class="line">        res = res * t % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大公约数"><a href="#最大公约数" class="headerlink" title=" 最大公约数"></a><a href="#最大公约数" title="最大公约数"></a> 最大公约数</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">欧几里得算法 </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/04/05/2675_16c71c3a95-1.jpg" alt="">8 </p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/04/05/2675_18fa15fc95-2.jpg" alt="2.jpg"></p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/04/05/2675_1c072a1395-3.jpg" alt="3.jpg"></p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/04/05/2675_1fd7186e95-4.jpg" alt="4.jpg"></p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/04/05/2675_21ce169b95-7.jpg" alt="7.jpg"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b,a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">gcd</span>(a,b));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速幂"><a href="#快速幂" class="headerlink" title=" 快速幂"></a><a href="#快速幂" title="快速幂"></a> 快速幂</h3><p><strong><em>模板：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">快速幂</span><br><span class="line">求 m^k mod p，时间复杂度 <span class="built_in">O</span>(logk)。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qmi</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k, <span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span> % p, t = m;</span><br><span class="line">    <span class="keyword">while</span> (k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k&amp;<span class="number">1</span>) res = res * t % p;</span><br><span class="line">        t = t * t % p;</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/04/06/2675_7e3d705896-1.jpg" alt="1.jpg"></p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/04/06/2675_80e23b5f96-2.jpg" alt="2.jpg"></p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/04/06/2675_835f262496-3.jpg" alt="3.jpg"></p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/04/06/2675_851701fc96-4.jpg" alt="4.jpg"></p><p>(a + b) % p = (a % p + b % p) % p</p><p>(a - b) % p = (a % p - b % p) % p</p><p>(a * b) % p = (a % p * b % p) % p</p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qmi</span><span class="params">(LL a,<span class="type">int</span> b,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = res * a % p;</span><br><span class="line">        </span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        a = a * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;p);</span><br><span class="line">        </span><br><span class="line">        LL res = <span class="built_in">qmi</span>(a,b,p);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速幂求逆元"><a href="#快速幂求逆元" class="headerlink" title=" 快速幂求逆元"></a><a href="#快速幂求逆元" title="快速幂求逆元"></a> 快速幂求逆元</h3><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2020/07/15/35805_78ef12a4c6-%E5%BF%AB%E9%80%9F%E5%B9%82%E6%B1%82%E9%80%86%E5%85%83.jpg" alt="快速幂求逆元.jpg"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">qmi</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b &amp; <span class="number">1</span>) res = res * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = a * (LL)a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;p);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(a % p == <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>); <span class="comment">// 因为p是质数，除了p的倍数，p与其他数都互质，所以可以写a%p</span></span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">qmi</span>(a,p - <span class="number">2</span>,p));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a><a href="#动态规划" title="动态规划"></a>动态规划</h2><h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title=" 01背包问题"></a><a href="#01背包问题" title="01背包问题"></a> 01背包问题</h3><ol><li>题目介绍<br>有 N 件物品和一个容量为 V 的背包，每件物品有各自的价值且只能被选择一次，要求在有限的背包容量下，装入的物品总价值最大。</li></ol><p>「0-1 背包」是较为简单的动态规划问题，也是其余背包问题的基础。</p><p>动态规划是不断决策求最优解的过程，「0-1 背包」即是不断对第 i 个物品的做出决策，「0-1」正好代表不选与选两种决定。</p><ol start="2"><li>题解代码（C++）</li><li>1 版本1 二维<br>（1）状态f [i] [j]定义：前 i 个物品，背包容量 j 下的最优解（最大价值）：</li></ol><p>当前的状态依赖于之前的状态，可以理解为从初始状态f[0] [0] = 0开始决策，有 N 件物品，则需要 N 次决 策，每一次对第 i 件物品的决策，状态f [ i ] [ j ]不断由之前的状态更新而来。<br>（2）当前背包容量不够（j &lt; v[i]），没得选，因此前 i 个物品最优解即为前 i−1 个物品最优解：</p><p>对应代码：f[i] [j] = f[i - 1] [j]。<br>（3）当前背包容量够，可以选，因此需要决策选与不选第 i 个物品：</p><p>选：f[i] [j] = f[i - 1] [j - v[i]] + w[i]。<br>不选：f[i] [j] = f[i - 1] [j] 。<br>我们的决策是如何取到最大价值，因此以上两种情况取 max() 。</p><p><strong><em>代码（二维）：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[N][N];<span class="comment">// f[i][j], j体积下前i个物品的最大价值 </span></span><br><span class="line"><span class="type">int</span> v[N],w[N];<span class="comment">// 体积// 价值 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) </span><br><span class="line">        cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; v[i]) <span class="comment">//  当前背包容量装不进第i个物品，则价值等于前i-1个物品</span></span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">// 能装，需进行决策是否选择第i个物品</span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j],f[i - <span class="number">1</span>][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.2 版本2 一维<br>将状态f[i] [j]优化到一维f[j]，实际上只需要做一个等价变形。</p><p>为什么可以这样变形呢？我们定义的状态f[i] [j]可以求得任意合法的i与j最优解，但题目只需要求得最终状态f[n] [m]，因此我们只需要一维的空间来更新状态。</p><p>（1）状态f[j]定义：N 件物品，背包容量j下的最优解。</p><p>（2）注意枚举背包容量j必须从m开始。</p><p>（3）为什么一维情况下枚举背包容量需要逆序？在二维情况下，状态f[i] [j]是由上一轮i - 1的状态得来的，f[i] [j]与f[i - 1] [j]是独立的。而优化到一维后，如果我们还是正序，则有f[较小体积]更新到f[较大体积]，则有可能本应该用第i-1轮的状态却用的是第i轮的状态。</p><p>（4）例如，一维状态第i轮对体积为 3 的物品进行决策，则f[7]由f[4]更新而来，这里的f[4]正确应该是f[i - 1] [4]，但从小到大枚举j这里的f[4]在第i轮计算却变成了f[i] [4]。当逆序枚举背包容量j时，我们求f[7]同样由f[4]更新，但由于是逆序，这里的f[4]还没有在第i轮计算，所以此时实际计算的f[4]仍然是f[i - 1] [4]。</p><p>（5）简单来说，一维情况正序更新状态f[j]需要用到前面计算的状态已经被「污染」，逆序则不会有这样的问题。</p><p>状态转移方程为：f[j] = max(f[j], f[j - v[i]] + w[i] 。</p><p>只有当枚举的背包容量 &gt;= v[i] 时才会更新状态，因此我们可以修改循环终止条件进一步优化。</p><p>​    </p><p>关于状态f[j]的补充说明<br>二维下的状态定义f[i] [j]是前 i 件物品，背包容量 j 下的最大价值。一维下，少了前 i 件物品这个维度，我们的代码中决策到第 i 件物品（循环到第i轮），f[j]就是前i轮已经决策的物品且背包容量 j 下的最大价值。</p><p>因此当执行完循环结构后，由于已经决策了所有物品，f[j]就是所有物品背包容量 j 下的最大价值。即一维f[j]等价于二维f[n] [j]。</p><p><strong><em>代码（一维）优化：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m;j &gt;= v[i];j --)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j],f[j - v[i]] + w[i]);</span><br><span class="line">            </span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title=" 完全背包问题"></a><a href="#完全背包问题" title="完全背包问题"></a> 完全背包问题</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cqq144%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220111230604798.png" alt="image-20220111230604798"></p><p><img src= "/img/loading.gif" data-src="https://gitee.com/chzarles/images/raw/master/imgs/006eb5E0gy1g7yyd0jjcyj30wk0fpdhc.jpg" alt="image.png"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cqq144%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220111233231511.png" alt="image-20220111233231511"></p><p><strong><em>代码（二维）：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= v[i]) f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j],f[i][j - v[i]] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码（一维）优化：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> v[N],w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) cin &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = v[i];j &lt;= m;j ++)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j],f[j - v[i]] + w[i]);</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背包问题-I"><a href="#多重背包问题-I" class="headerlink" title="多重背包问题 I"></a>多重背包问题 I</h3><p><strong><em>代码（二维）：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> v[N],w[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt;= s[i] &amp;&amp; k* v[i] &lt;= j;k ++)</span><br><span class="line">            &#123;</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j],f[i - <span class="number">1</span>][j - k * v[i]] + k * w[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码（一维）优化：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> v[N],w[N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m;j &gt;= v[i];j --)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt;= s[i] &amp;&amp; k* v[i] &lt;= j;k ++)</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j],f[j - k * v[i]] + k * w[i]);</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背包问题-II"><a href="#多重背包问题-II" class="headerlink" title="多重背包问题 II"></a>多重背包问题 II</h3><p><img src= "/img/loading.gif" data-src="https://gitee.com/chzarles/images/raw/master/imgs/006eb5E0gy1g7z0e5ghloj31150fw0ub.jpg" alt="image.png"></p><p>思路和多重背包问题I一样，但这题的数据范围变成1000了，非优化写法时间复杂度O(n^3) 接近 1e9</p><p>必超时。</p><p>优化多重背包的优化<br>首先，我们不能用完全背包的优化思路来优化这个问题，因为每组的物品的个数都不一样，是不能像之前一样推导不优化递推关系的。（详情看下面引用的博文）</p><p>引用我之前写的博客：动态规划-完全背包问题</p><p>我们列举一下更新次序的内部关系：</p><p>f[i , j ] = max( f[i-1,j] , f[i-1,j-v]+w , f[i-1,j-2v]+2w , f[i-1,j-3v]+3w , …..)<br>f[i , j-v]= max( f[i-1,j-v] , f[i-1,j-2v] + w , f[i-1,j-2v]+2*w , …..)<br>由上两式，可得出如下递推关系：<br>f[i] [j]=max(f[i,j-v]+w , f[i-1] [j])<br>接下来，我介绍一个二进制优化的方法，假设有一组商品，一共有11个。我们知道，十进制数字 11 可以这样表示<br>11=1011(B)=0111(B)+(11−0111(B))=0111(B)+0100(B)</p><p>正常背包的思路下，我们要求出含这组商品的最优解，我们要枚举12次（枚举装0，1，2….12个）。</p><p>现在，如果我们把这11个商品分别打包成含商品个数为1个，2个，4个，4个（分别对应0001,0010,0100,0100）的四个”新的商品 “, 将问题转化为01背包问题，对于每个商品，我们都只枚举一次，那么我们只需要枚举四次 ，就可以找出这含组商品的最优解。 这样就大大减少了枚举次数。</p><p>这种优化对于大数尤其明显，例如有1024个商品，在正常情况下要枚举1025次 ， 二进制思想下转化成01背包只需要枚举10次。</p><p>优化的合理性的证明<br>先讲结论：上面的1，2，4，4是可以通过组合来表示出0~11中任何一个数的，还是拿11证明一下（举例一下）：</p><p>首先，11可以这样分成两个二进制数的组合：<br>11=0111(B)+(11−0111(B))=0111(B)+0100(B)</p><p>其中0111通过枚举这三个1的取或不取（也就是对0001(B)，0010(B)，0100(B)的组合），可以表示十进制数0<del>7( 刚好对应了 1，2，4 可以组合出 0</del>7 ) , 0<del>7的枚举再组合上0100(B)( 即 十进制的 4 ) ，可以表示十进制数 0</del>11。其它情况也可以这样证明。这也是为什么，这个完全背包问题可以等效转化为01背包问题，有木有觉得很奇妙</p><p>怎么合理划分一个十进制数?<br>上面我把11划分为<br>11=0111(B)+(11−0111(B))=0111(B)+0100(B)<br>是因为 0111(B)刚好是小于11的最大的尾部全为1的二进制 ( 按照上面的证明，这样的划分没毛病 ) , 然后那个尾部全为1的数又可以 分解为 0000….1 , 0000….10 , 0000….100 等等。</p><p>7 分成 1，2，4</p><p>10分成1，2，4，3</p><p>11分成1，2，4，4</p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">11010</span>,M = <span class="number">2010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[M];<span class="comment">// 体积&lt;M</span></span><br><span class="line"><span class="type">int</span> v[N],w[N];<span class="comment">//逐一枚举最大是N*logS</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;<span class="comment">//分组的组别</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,s;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;<span class="comment">// 组别里面的个数</span></span><br><span class="line">        <span class="keyword">while</span>(k &lt;= s)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++;<span class="comment">//组别先增加</span></span><br><span class="line">            v[cnt] = a * k;<span class="comment">//整体体积</span></span><br><span class="line">            w[cnt] = b * k;<span class="comment">// 整体价值</span></span><br><span class="line">            s -= k;<span class="comment">// s要减小</span></span><br><span class="line">            k = <span class="number">2</span> * k;<span class="comment">// 组别里的个数增加</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">0</span>)  <span class="comment">//剩余的一组</span></span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++;</span><br><span class="line">            v[cnt] = a * s;</span><br><span class="line">            w[cnt] = b * s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    n = cnt;<span class="comment">//枚举次数正式由个数变成组别数</span></span><br><span class="line">    <span class="comment">//01背包一维优化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m;j &gt;= v[i];j --)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j],f[j - v[i]] + w[i]);</span><br><span class="line">            </span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title=" 分组背包问题"></a><a href="#分组背包问题" title="分组背包问题"></a> 分组背包问题</h3><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2019/08/06/1606_ecd551d6b7-%E6%8D%95%E8%8E%B7.PNG" alt="捕获.PNG"></p><p><strong><em>代码（二维）：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">int</span> v[N][N],w[N][N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= s[i];j ++)</span><br><span class="line">            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt;= s[i];k ++)</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= v[i][k]) f[i][j] = <span class="built_in">max</span>(f[i][j],f[i - <span class="number">1</span>][j - v[i][k]] + w[i][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码（一维）优化：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"><span class="type">int</span> v[N][N],w[N][N],s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= s[i];j ++)</span><br><span class="line">            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m;j &gt;= <span class="number">1</span>;j --)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt;= s[i];k ++)</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= v[i][k]) </span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j],f[j - v[i][k]] + w[i][k]);</span><br><span class="line">                </span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title=" 数字三角形"></a><a href="#数字三角形" title="数字三角形"></a> 数字三角形</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cqq144%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220113114457826.png" alt="image-20220113114457826"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>,INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= i;j ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= i + <span class="number">1</span>;j ++)</span><br><span class="line">            f[i][j] = -INF;   <span class="comment">//因为有负数，所以应该将两边也设为-INF</span></span><br><span class="line">        </span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>];    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= i;j ++)</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j],f[i - <span class="number">1</span>][j] + a[i][j]);</span><br><span class="line">            </span><br><span class="line">    <span class="type">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) res = <span class="built_in">max</span>(res,f[n][i]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码（去掉a数组）优化：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>,INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= i + <span class="number">1</span>;j ++)</span><br><span class="line">            f[i][j] = -INF;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= i;j ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;f[i][j]);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= i;j ++)</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i][j],f[i - <span class="number">1</span>][j] + f[i][j]);</span><br><span class="line">            </span><br><span class="line">    <span class="type">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) res = <span class="built_in">max</span>(res,f[n][i]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码（一维）优化：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>,INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= i;j ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;= i + <span class="number">1</span>;j ++)</span><br><span class="line">            f[j] = -INF;</span><br><span class="line">        </span><br><span class="line">    f[<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>];    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i;j &gt;= <span class="number">1</span>;j --)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j - <span class="number">1</span>] + a[i][j],f[j] + a[i][j]);</span><br><span class="line">            </span><br><span class="line">    <span class="type">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) res = <span class="built_in">max</span>(res,f[i]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码（倒序dp，不需要考虑边界问题）：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= i;j ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;f[i][j]);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>;i &gt;= <span class="number">1</span>;i --)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j ++)</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i + <span class="number">1</span>][j],f[i + <span class="number">1</span>][j + <span class="number">1</span>]) + f[i][j];</span><br><span class="line">            </span><br><span class="line">    cout &lt;&lt; f[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title=" 最长上升子序列"></a><a href="#最长上升子序列" title="最长上升子序列"></a> 最长上升子序列</h3><p>(动态规划) O(n2)<br>状态表示：f[i]表示从第一个数字开始算，以w[i]结尾的最大的上升序列。(以w[i]结尾的所有上升序列中属性为最大值的那一个)</p><p>状态计算（集合划分）：j∈(0,1,2,..,i-1), 在w[i] &gt; w[j]时，<br>f[i] = max(f[i], f[j] + 1)。<br>有一个边界，若前面没有比i小的，f[i]为1（自己为结尾）。</p><p>最后在找f[i]的最大值。</p><p>时间复杂度<br>O(n2) 状态数(n) * 转移数(n)</p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cqq144%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220113150836711.png" alt="image-20220113150836711"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N],a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        f[i] = <span class="number">1</span>;<span class="comment">// 设f[i]默认为1，自己是一个</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= i;j ++)</span><br><span class="line">            <span class="keyword">if</span>(a[i] &gt; a[j])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i],f[j] + <span class="number">1</span>);<span class="comment">// 前一个小于自己的数结尾的最大上升子序列加上自己，即+1</span></span><br><span class="line">                </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) res = <span class="built_in">max</span>(res,f[i]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长上升子序列-II"><a href="#最长上升子序列-II" class="headerlink" title="最长上升子序列 II"></a>最长上升子序列 II</h3><p>(动态规划 + 二分) O(nlogn)<br>状态表示：f[i]表示长度为i的最长上升子序列，末尾最小的数字。(长度为i的最长上升子序列所有结尾中，结尾最小min的) 即长度为i的子序列末尾最小元素是什么。</p><p>状态计算：对于每一个w[i], 如果大于f[cnt-1] (下标从0开始，cnt长度的最长上升子序列，末尾最小的数字)，那就cnt+1，使得最长上升序列长度+1，当前末尾最小元素为w[i]。 若w[i]小于等于f[cnt-1],说明不会更新当前的长度，但之前末尾的最小元素要发生变化，找到第一个 大于或等于 (这里不能是大于) w[i]，更新以那时候末尾的最小元素。</p><p>f[i]一定以一个单调递增的数组，所以可以用二分法来找第一个大于或等于w[i]的数字。</p><p>时间复杂度<br>O(nlogn) 状态数(n) * 转移数(logn)</p><p>题解中最难理解的地方在于栈中序列虽然递增，但是每个元素在原串中对应的位置其实可能是乱的，那为什么这个栈还能用于计算最长子序列长度？<br>实际上这个栈【不用于记录最终的最长子序列】，而是【以stk[i]结尾的子串长度最长为i】或者说【长度为i的递增子串中，末尾元素最小的是stk[i]】。理解了这个问题以后就知道为什么新进来的元素要不就在末尾增加，要不就替代第一个大于等于它元素的位置。<br>这里的【替换】就蕴含了一个贪心的思想，对于同样长度的子串，我当然希望它的末端越小越好，这样以后我也有更多机会拓展。</p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>,r = len;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(q[mid] &lt; a[i]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len = <span class="built_in">max</span>(len,r + <span class="number">1</span>);</span><br><span class="line">        q[r + <span class="number">1</span>] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,len);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title=" 最长公共子序列"></a><a href="#最长公共子序列" title="最长公共子序列"></a> 最长公共子序列</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cqq144%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220113232237893.png" alt="image-20220113232237893"></p><p><strong><em>或者：</em></strong></p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2020/02/06/28466_6610da5048-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90.PNG" alt="问题分析.PNG"></p><p>如果两个字符相等，就可以直接转移到f[i-1] [j-1]，不相等的话，两个字符一定有一个可以抛弃，可以对f[i-1] [j],f[i] [j-1]两种状态取max来转移。</p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2020/02/06/28466_e2c0e13048-%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB.PNG" alt="状态转移.PNG"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,a + <span class="number">1</span>,b + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j],f[i][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j]) f[i][j] = <span class="built_in">max</span>(f[i][j],f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title=" 最短编辑距离"></a><a href="#最短编辑距离" title="最短编辑距离"></a> 最短编辑距离</h3><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2020/03/26/13039_be6480146f-%E9%97%AB%E5%BC%8Fdp.jpg" alt="闫式dp.jpg"></p><p>1.状态表示 ：f[i] [j]<br>集合：将a[1<del>i]变成b[1</del>j]的操作方式<br>属性：min<br>2.状态计算 ：从最后一步考虑<br>有三种操作，所以有三个子集<br>ok子集划分完了<br>考虑状态转移的时候<br>先考虑如果我没有进行这个操作应该是什么状态<br>然后考虑你进行这一步操作之后会对你下一个状态造成什么影响<br>然后再加上之前状态表示中你决策出来的那个DP属性<br>这样就可以自然而然地搞出来转移方程啦</p><p>1)删除操作：把a[i]删掉之后a[1<del>i]和b[1</del>j]匹配<br>            所以之前要先做到a[1<del>(i-1)]和b[1</del>j]匹配<br>            f[i-1] [j] + 1<br>2)插入操作：插入之后a[i]与b[j]完全匹配，所以插入的就是b[j]<br>            那填之前a[1<del>i]和b[1</del>(j-1)]匹配<br>            f[i] [j-1] + 1<br>3)替换操作：把a[i]改成b[j]之后想要a[1<del>i]与b[1</del>j]匹配<br>            那么修改这一位之前，a[1<del>(i-1)]应该与b[1</del>(j-1)]匹配<br>            f[i-1] [j-1] + 1<br>            但是如果本来a[i]与b[j]这一位上就相等，那么不用改，即<br>            f[i-1] [j-1] + 0</p><p>好的那么f[i] [j]就由以上三个可能状态转移过来，取个min<br>细节问题：初始化怎么搞<br>先考虑有哪些初始化嘛<br>1.你看看在for遍历的时候需要用到的但是你事先没有的<br>（往往就是什么0啊1啊之类的）就要预处理<br>2.如果要找min的话别忘了INF<br>  要找有负数的max的话别忘了-INF</p><p>ok对应的：<br>1.f[0] [i]如果a初始长度就是0，那么只能用插入操作让它变成b<br>  f[i] [0]同样地，如果b的长度是0，那么a只能用删除操作让它变成b<br>2.f[i] [j] = INF //虽说这里没有用到，但是把考虑到的边界都写上还是保险</p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> a[N],b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;n,a + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>,&amp;m,b + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n;i ++) f[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= m;i ++) f[<span class="number">0</span>][i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i][j - <span class="number">1</span>] + <span class="number">1</span>,f[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j]) f[i][j] = <span class="built_in">min</span>(f[i][j],f[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> f[i][j] = <span class="built_in">min</span>(f[i][j],f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; f[n][m] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编辑距离"><a href="#编辑距离" class="headerlink" title=" 编辑距离"></a><a href="#编辑距离" title="编辑距离"></a> 编辑距离</h3><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/04/20/2675_3277465ea1-1.jpg" alt="1.jpg"></p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2021/04/20/2675_35f9336ca1-2.jpg" alt="2.jpg"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">15</span>,M = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"><span class="type">char</span> str[M][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">distance</span><span class="params">(<span class="type">char</span> a[],<span class="type">char</span> b[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> la = <span class="built_in">strlen</span>(a + <span class="number">1</span>),lb = <span class="built_in">strlen</span>(b + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= la;i ++) f[i][<span class="number">0</span>] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= lb;i ++) f[<span class="number">0</span>][i] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= la;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= lb;j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j] + <span class="number">1</span>,f[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j]) f[i][j] = <span class="built_in">min</span>(f[i][j],f[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> f[i][j] = <span class="built_in">min</span>(f[i][j],f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> f[la][lb];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str[i] + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> s[N];</span><br><span class="line">        <span class="type">int</span> limit;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>,s + <span class="number">1</span>,&amp;limit);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">distance</span>(str[i],s) &lt;= limit) </span><br><span class="line">                res ++;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="石子合并（区间合并）"><a href="#石子合并（区间合并）" class="headerlink" title=" 石子合并（区间合并）"></a><a href="#石子合并（区间合并）" title="石子合并（区间合并）"></a> 石子合并（区间合并）</h3><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2019/08/06/1606_bf26e786b8-%E6%8D%95%E8%8E%B72.PNG" alt="捕获2.PNG"></p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2019/08/06/1606_c2db3d28b8-%E6%8D%95%E8%8E%B71.PNG" alt="捕获1.PNG"></p><p>核心：最后一次合并一定是左边连续的一部分和右边连续的一部分进行合并</p><p>状态表示：f[i] [j] 表示将 i 到 j 合并成一堆的方案的集合，属性 Min</p><p>状态计算：<br>(1) i&lt;j 时，f[i] [j]=min（i≤k≤j−1）f[i] [k]+f[k+1] [j]+s[j]−s[i−1]<br>(2) i=j 时， f[i] [i]=0 （合并一堆石子代价为 0）</p><p>问题答案： f[1] [n]</p><p>区间 DP 常用模版<br>所有的区间dp问题，第一维都是枚举区间长度，一般 len = 1 用来初始化，枚举从 len = 2 开始，第二维枚举起点 i （右端点 j 自动获得，j = i + len - 1）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i][i] = 初始值</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">2</span>; len &lt;= n; len++)           <span class="comment">//区间长度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + len - <span class="number">1</span> &lt;= n; i++) &#123; <span class="comment">//枚举起点</span></span><br><span class="line">        <span class="type">int</span> j = i + len - <span class="number">1</span>;                 <span class="comment">//区间终点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; j; k++) &#123;        <span class="comment">//枚举分割点，构造状态转移方程</span></span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i][j], dp[i][k] + dp[k + <span class="number">1</span>][j] + w[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2020/08/15/42937_8ba34a42de-%E6%95%B4%E6%95%B0%E5%88%92%E5%88%86-%E4%BC%98%E5%8C%96%E5%89%8D.jpg" alt="整数划分-优化前.jpg"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> s[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) s[i] += s[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 区间 DP 枚举套路：长度+左端点 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">2</span>;len &lt;= n;len ++)<span class="comment">// len表示i和j堆下标的差值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i + len - <span class="number">1</span> &lt;= n;i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = i,r = i + len - <span class="number">1</span>;  <span class="comment">// 自动得到右端点</span></span><br><span class="line">            f[l][r] = <span class="number">1e9</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = l;k &lt; r;k ++) <span class="comment">// k &lt; r ,k可以到达r的话，就只剩下一堆了</span></span><br><span class="line">                f[l][r] = <span class="built_in">min</span>(f[l][r],f[i][k] + f[k + <span class="number">1</span>][r] + s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; f[<span class="number">1</span>][n] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="整数划分（计数类DP）"><a href="#整数划分（计数类DP）" class="headerlink" title=" 整数划分（计数类DP）"></a><a href="#整数划分（计数类DP）" title="整数划分（计数类DP）"></a> 整数划分（计数类DP）</h3><p><strong><em>代码（dfs）：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//会TLE（超时）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">1</span> || m == n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">dfs</span>(n - m,m) + <span class="built_in">dfs</span>(n - <span class="number">1</span>,m - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        res += <span class="built_in">dfs</span>(n,i);</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：把1,2,3, … n分别看做n个物体的体积，这n个物体均无使用次数限制，问恰好能装满总体积为n的背包的总方案数（完全背包问题变形）</p><p>初值问题：<br>求最大值时，当都不选时，价值显然是 0<br>而求方案数时，当都不选时，方案数是 1（即前 i 个物品都不选的情况也是一种方案），所以需要初始化为 1<br>即：for (int i = 0; i &lt;= n; i ++) f[i] [0] = 1;<br>等价变形后： f[0] = 1</p><p>状态计算：</p><p>f[i] [j] 表示前i个整数（1,2…,i）恰好拼成j的方案数<br>求方案数：把集合选0个i，1个i，2个i，…全部加起来<br>f[i] [j] = f[i - 1] [j] + f[i - 1] [j - i] + f[i - 1] [ j - 2 * i] + …;<br>f[i] [j - i] = f[i - 1] [j - i] + f[i - 1] [j - 2 * i] + …;<br>因此 f[i] [j]=f[i−1] [j]+f[i] [j−i]; (这一步类似完全背包的推导）</p><p><strong><em>代码（朴素）：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>,mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= n;i ++) f[i][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">// 容量为0时，前 i 个物品全不选也是一种方案</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= i) f[i][j] = (f[i - <span class="number">1</span>][j] + f[i][j - i]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    cout &lt;&lt; f[n][n] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码（一维）优化：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>,mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i;j &lt;= n;j ++)</span><br><span class="line">            f[j] = (f[j] + f[j - i]) % mod;</span><br><span class="line">            </span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码（另一种解法）：</em></strong></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cqq144%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220114181211069.png" alt="image-20220114181211069"></p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2020/08/15/42937_d5f9941cde-%E8%AE%A1%E6%95%B0%E7%B1%BBDP.jpg" alt="计数类DP.jpg"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>,mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= i;j ++)</span><br><span class="line">            f[i][j] = (f[i - <span class="number">1</span>][j - <span class="number">1</span>] + f[i - j][j]) % mod;</span><br><span class="line">            </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) res = (res + f[n][i]) % mod;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计数问题（数位统计DP）"><a href="#计数问题（数位统计DP）" class="headerlink" title=" 计数问题（数位统计DP）"></a><a href="#计数问题（数位统计DP）" title="计数问题（数位统计DP）"></a> 计数问题（数位统计DP）</h3><p>求1<del>n中，x出现的次数：<br>例如：n=abcdefg ， 求x在第4位出现的次数<br>分类讨论：<br>①前三位：000</del>abc-1,x,后三位000<del>999. 方案数:abc*1000<br>②前三位：abc,x<br>……………..2.1 d &lt; x , 后三位：无解. 方案数：0<br>……………..2.2 d = x , 后三位：000</del>dfg. 方案数:efg+1<br>……………..2.3 d &gt; x , 后三位：000~999. 方案数:1000</p><p>注意：<br>1.当判断x在第1位出现的次数时，不存在情况①</p><p>2.当x=0且在分类①时，因为不能前导全0，因此得从001开始，（这一步特判即可）</p><p>3.0 也不可以出现在最高位</p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(vector&lt;<span class="type">int</span>&gt; num,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l;i &gt;= r;i --) res = res * <span class="number">10</span> + num[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power10</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(x --) res *= <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        num.<span class="built_in">push_back</span>(n % <span class="number">10</span>);</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    n = num.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span> - !x;i &gt;= <span class="number">0</span>;i --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; n - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res += <span class="built_in">get</span>(num,n - <span class="number">1</span>,i + <span class="number">1</span>) * <span class="built_in">power10</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(!x) res -= <span class="built_in">power10</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(num[i] == x) res += <span class="built_in">get</span>(num,i - <span class="number">1</span>,<span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(num[i] &gt; x) res += <span class="built_in">power10</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a &gt;&gt; b,a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a &gt; b) <span class="built_in">swap</span>(a,b);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i ++)</span><br><span class="line">            cout &lt;&lt; <span class="built_in">count</span>(b,i) - <span class="built_in">count</span>(a - <span class="number">1</span>,i) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="蒙德里安的梦想"><a href="#蒙德里安的梦想" class="headerlink" title=" 蒙德里安的梦想"></a><a href="#蒙德里安的梦想" title="蒙德里安的梦想"></a> 蒙德里安的梦想</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cqq144%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220115174711957.png" alt="image-20220115174711957"></p><p><strong><em>代码（朴素）：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>,M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[N][M];</span><br><span class="line"><span class="type">bool</span> st[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m,n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1</span> &lt;&lt; n;i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        st[i] = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>) st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        </span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">1</span> &lt;&lt; n;j ++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; <span class="number">1</span> &lt;&lt; n;k ++)</span><br><span class="line">                    <span class="keyword">if</span>((j &amp; k) == <span class="number">0</span> &amp;&amp; st[j | k])</span><br><span class="line">                        f[i][j] += f[i - <span class="number">1</span>][k];</span><br><span class="line">                        </span><br><span class="line">        cout &lt;&lt; f[m][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码（优化）：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12</span>,M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[N][M];</span><br><span class="line"><span class="type">bool</span> st[M];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; state[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m,n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1</span> &lt;&lt; n;i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j ++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        st[i] = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cnt &amp; <span class="number">1</span>) st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1</span> &lt;&lt; n;i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            state[i].<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">1</span> &lt;&lt; n;j ++)</span><br><span class="line">                <span class="keyword">if</span>((i &amp; j) == <span class="number">0</span> &amp;&amp; st[i | j])</span><br><span class="line">                    state[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; <span class="number">1</span> &lt;&lt; n;j ++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> k : state[j])</span><br><span class="line">                    f[i][j] += f[i - <span class="number">1</span>][k];</span><br><span class="line">                    </span><br><span class="line">        cout &lt;&lt; f[m][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目分析:<br>摆放方块的时候，先放横着的，再放竖着的。<strong>总方案数等于只放横着的小方块的合法方案数（把横的摆好，竖的自然直接放进去就可以了）。</strong></p><p>如何判断，当前方案数是否合法？ 所有剩余位置能否填充满竖着的小方块。可以按列来看，每一列内部所有连续的空着的小方块需要是偶数个。</p><p>这是一道动态规划的题目，并且是一道 状态压缩的dp：用一个N位的二进制数，每一位表示一个物品，0/1表示不同的状态。因此可以用0 → 2 N − 1 （ N 二 进 制 对 应 的 十 进 制 数 ） 0 →2^N-1（N二进制对应的十进制数）中的所有数来枚举全部的状态。</p><p>状态表示<br>状态表示：f [ i ] [ j ] 表示已经将前 i -1 列摆好，且从第i − 1 列，伸出到第 i  列的状态是 j  的所有方案。其中j是一个二进制数，用来表示哪一行的小方块是横着放的，其位数和棋盘的行数一致。</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20210116151930714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXpoZW5nX0xp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>解释：上图中 i=2，j =10101（二进制数，但是存的时候用十进制） 所以这里的f[i] [j ] 表示的是 所有前i列摆完之后，从第 i-1列伸到 第i列的状态是10101（第1行伸出来，第3行伸出来，第5行伸出来，其他行没伸出来）的方案数。</p><p>状态转移<br>状态转移<br>既然第 i 列固定了，我们需要看 第i-2 列是怎么转移到到第 i-1列的（看最后转移过来的状态）。假设此时对应的状态是k（第i-2列到第i-1列伸出来的二进制数，比如00100），k也是一个二进制数，1表示哪几行小方块是横着伸出来的，0表示哪几行不是横着伸出来的。</p><p>它对应的方案数是 f [ i − 1 , k ] f[i-1,k]f[i−1,k] ，即前i-2列都已摆完，且从第i-2列伸到第i-1列的状态为 k 的所有方案数。</p><p>这个k需要满足什么条件呢?</p><p>首先k不能和 j在同一行（如下图）：因为从i-1列到第i列是横着摆放的1*2的方块，那么i-2列到i-1列就不能是横着摆放的，否则就是1 *3的方块了！这与题意矛盾。所以 k和j不能位于同一行。</p><p>既然不能同一行伸出来，那么对应的代码为(k &amp; j ) ==0 ，表示两个数相与，如果有1位相同结果就不是0， (k &amp; j ) ==0表示 k和j没有1位相同， 即没有1行有冲突。<br><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20210116152108127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXpoZW5nX0xp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdnimg.cn/20210116153004248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaXpoZW5nX0xp,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>既然从第i-1列到第i列横着摆的，和第i-2列到第i-1列横着摆的都确定了，那么第i-1列 空着的格子就确定了，这些空着的格子将来用作竖着放。如果 某一列有这些空着的位置，那么该列所有连续的空着的位置长度必须是偶数。</p><p>总共m列，我们假设列下标从0开始，即第0列，第1列……，第m-1列。根据状态表示f[i ] [j] 的定义，我们答案是什么呢？ 请读者返回定义处思考一下。答案是f[m] [0]， 意思是 前m-1列全部摆好,且从第m-1列到m列状态是0（意即从第m-1列到第m列没有伸出来的）的所有方案，即整个棋盘全部摆好的方案。<br><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cqq144%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220115182341324.png" alt="image-20220115182341324"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">12</span>, M = <span class="number">1</span>&lt;&lt; N;  </span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[N][M] ;<span class="comment">// 第一维表示列， 第二维表示所有可能的状态</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> st[M];  <span class="comment">//存储每种状态是否有奇数个连续的0，如果奇数个0是无效状态，如果是偶数个零置为true。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//vector&lt;int &gt; state[M];  //二维数组记录合法的状态</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">state</span>(M);  <span class="comment">//两种写法等价:二维数组</span></span><br><span class="line"><span class="type">int</span> m , n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m, n||m)&#123; <span class="comment">//读入n和m，并且不是两个0即合法输入就继续读入</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第一部分：预处理1</span></span><br><span class="line">        <span class="comment">//对于每种状态，先预处理每列不能有奇数个连续的0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; <span class="number">1</span>&lt;&lt;n; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> cnt =<span class="number">0</span> ;<span class="comment">//记录连续的0的个数</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">bool</span> isValid = <span class="literal">true</span>; <span class="comment">// 某种状态没有奇数个连续的0则标记为true</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123; <span class="comment">//遍历这一列，从上到下</span></span><br><span class="line">                 </span><br><span class="line">                 <span class="keyword">if</span>( i&gt;&gt;j &amp;<span class="number">1</span>)&#123;  <span class="comment">//i&gt;&gt;j位运算，表示i（i在此处是一种状态）的二进制数的第j位； &amp;1为判断该位是否为1，如果为1进入if</span></span><br><span class="line">                    <span class="keyword">if</span>(cnt &amp;<span class="number">1</span>) &#123; <span class="comment">//这一位为1，看前面连续的0的个数，如果是奇数（cnt &amp;1为真）则该状态不合法</span></span><br><span class="line">                        isValid =<span class="literal">false</span>;<span class="keyword">break</span>;</span><br><span class="line">                    &#125; </span><br><span class="line">                    cnt=<span class="number">0</span>; <span class="comment">// 既然该位是1，并且前面不是奇数个0（经过上面的if判断），计数器清零。//其实清不清零没有影响</span></span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">else</span> cnt++; <span class="comment">//否则的话该位还是0，则统计连续0的计数器++。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &amp;<span class="number">1</span>)  isValid =<span class="literal">false</span>; <span class="comment">//最下面的那一段判断一下连续的0的个数</span></span><br><span class="line">            </span><br><span class="line">            st[i]  = isValid; <span class="comment">//状态i是否有奇数个连续的0的情况,输入到数组st中</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二部分：预处理2</span></span><br><span class="line">        <span class="comment">// 经过上面每种状态 连续0的判断，已经筛掉一些状态。</span></span><br><span class="line">        <span class="comment">//下面来看进一步的判断：看第i-2列伸出来的和第i-1列伸出去的是否冲突</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt; <span class="number">1</span>&lt;&lt;n;j++)&#123; <span class="comment">//对于第i列的所有状态</span></span><br><span class="line">            state[j].<span class="built_in">clear</span>(); <span class="comment">//清空上次操作遗留的状态，防止影响本次状态。</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt; <span class="number">1</span>&lt;&lt;n;k++)&#123; <span class="comment">//对于第i-1列所有状态</span></span><br><span class="line">                <span class="keyword">if</span>((j&amp;k )==<span class="number">0</span> &amp;&amp; st[ j| k] ) <span class="comment">// 第i-2列伸出来的 和第i-1列伸出来的不冲突(不在同一行) </span></span><br><span class="line">                <span class="comment">//解释一下st[j | k] </span></span><br><span class="line">                <span class="comment">//已经知道st[]数组表示的是这一列没有连续奇数个0的情况，</span></span><br><span class="line">                <span class="comment">//我们要考虑的是第i-1列（第i-1列是这里的主体）中从第i-2列横插过来的，还要考虑自己这一列（i-1列）横插到第i列的</span></span><br><span class="line">                <span class="comment">//比如 第i-2列插过来的是k=10101，第i-1列插出去到第i列的是 j =01000，</span></span><br><span class="line">                <span class="comment">//那么合在第i-1列，到底有多少个1呢？自然想到的就是这两个操作共同的结果：两个状态或。 j | k = 01000 | 10101 = 11101</span></span><br><span class="line">                <span class="comment">//这个 j|k 就是当前 第i-1列的到底有几个1，即哪几行是横着放格子的</span></span><br><span class="line">                </span><br><span class="line">                    state[j].<span class="built_in">push_back</span>(k);  <span class="comment">//二维数组state[j]表示第j行， </span></span><br><span class="line">                    <span class="comment">//j表示 第i列“真正”可行的状态，如果第i-1列的状态k和j不冲突则压入state数组中的第j行。</span></span><br><span class="line">                    <span class="comment">//“真正”可行是指：既没有前后两列伸进伸出的冲突；又没有连续奇数个0。</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第三部分：dp开始</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);  <span class="comment">//全部初始化为0，因为是连续读入，这里是一个清空操作。类似上面的state[j].clear()</span></span><br><span class="line">        </span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span> ;<span class="comment">// 这里需要回忆状态表示的定义，按定义这里是：前第-1列都摆好，且从-1列到第0列伸出来的状态为0的方案数。</span></span><br><span class="line">        <span class="comment">//首先，这里没有-1列，最少也是0列。其次，没有伸出来，即没有横着摆的。即这里第0列只有竖着摆这1种状态。</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;= m;i++)&#123; <span class="comment">//遍历每一列:第i列合法范围是(0~m-1列)</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt; <span class="number">1</span>&lt;&lt;n; j++)&#123;  <span class="comment">//遍历当前列（第i列）所有状态j</span></span><br><span class="line">                <span class="keyword">for</span>( <span class="keyword">auto</span> k : state[j])    <span class="comment">//如果 第i列的状态j“真正”可行，就转移</span></span><br><span class="line">                    f[i][j] += f[i<span class="number">-1</span>][k];    <span class="comment">// 当前列的方案数就等于之前的第i-1列所有状态k的累加。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//最后答案是什么呢？</span></span><br><span class="line">        <span class="comment">//f[m][0]表示 前m-1列都处理完，并且第m-1列没有伸出来的所有方案数。</span></span><br><span class="line">        <span class="comment">//即整个棋盘处理完的方案数</span></span><br><span class="line">    </span><br><span class="line">        cout&lt;&lt; f[m][<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="最短Hamilton路径"><a href="#最短Hamilton路径" class="headerlink" title=" 最短Hamilton路径"></a><a href="#最短Hamilton路径" title="最短Hamilton路径"></a> 最短Hamilton路径</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cqq144%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220115232247851.png" alt="image-20220115232247851"></p><p>f[i] [j] 第一维代表着是一个方案集合，其中每一个位置1和0，代表着这个点经过还是没有经过，第二维表示从0 走到 j</p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">21</span>,M = <span class="number">1</span> &lt;&lt; N;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[M][N];</span><br><span class="line"><span class="type">int</span> w[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i][j]);</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));<span class="comment">// 由于要求最小值，所以这里将 f 初始化为正无穷会更好处理一些</span></span><br><span class="line">    </span><br><span class="line">    f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//这里的1，是二进制下的1，也就是第0位为1,f[i][j]表示二进制状态为i，最后一次节点是j</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">1</span> &lt;&lt; n;i ++)<span class="comment">// 从 0 到 111...11 枚举所有状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; n;j ++)<span class="comment">//枚举当前到了哪一个点</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;&gt; j &amp; <span class="number">1</span>)<span class="comment">//如果i集合中第j位是1，也就是到达过这个点</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; n;k ++)<span class="comment">//枚举到达j的点k</span></span><br><span class="line">                    <span class="keyword">if</span>((i - (<span class="number">1</span> &lt;&lt; j)) &gt;&gt; k &amp; <span class="number">1</span>) <span class="comment">//集合i 包含k，但不包含j了，i - (1 &lt;&lt; j)其实可以去掉，因为取的是最小，无影响</span></span><br><span class="line">                        f[i][j] = <span class="built_in">min</span>(f[i][j],f[i - (<span class="number">1</span> &lt;&lt; j)][k] + w[k][j]);<span class="comment">//选择最小值，也就是判断，k点到j点最优，还是以前的方案最优</span></span><br><span class="line">                        </span><br><span class="line">    cout &lt;&lt; f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][n - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="没有上司的舞会"><a href="#没有上司的舞会" class="headerlink" title=" 没有上司的舞会"></a><a href="#没有上司的舞会" title="没有上司的舞会"></a> 没有上司的舞会</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cqq144%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220116112350508.png" alt="image-20220116112350508"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">6010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> happy[N];</span><br><span class="line"><span class="type">bool</span> has_father[N];</span><br><span class="line"><span class="type">int</span> e[N],ne[N],h[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = b,ne[idx] = h[a],h[a] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[u][<span class="number">1</span>] = happy[u];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u];i != <span class="number">-1</span>;i = ne[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = e[i];</span><br><span class="line">        <span class="built_in">dfs</span>(j);  <span class="comment">//遍历到最下，从下往上保证后续可以计算到</span></span><br><span class="line">        </span><br><span class="line">        f[u][<span class="number">1</span>] += f[j][<span class="number">0</span>];</span><br><span class="line">        f[u][<span class="number">0</span>] += <span class="built_in">max</span>(f[j][<span class="number">0</span>],f[j][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;happy[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - <span class="number">1</span>;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);  <span class="comment">//b 是 a的父节点</span></span><br><span class="line">        has_father[a] = <span class="literal">true</span>;  <span class="comment">//a有父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> root = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(has_father[root]) root ++;  <span class="comment">//找到根节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(root);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">max</span>(f[root][<span class="number">0</span>],f[root][<span class="number">1</span>]));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="滑雪（记忆化搜索）"><a href="#滑雪（记忆化搜索）" class="headerlink" title=" 滑雪（记忆化搜索）"></a><a href="#滑雪（记忆化搜索）" title="滑雪（记忆化搜索）"></a> 滑雪（记忆化搜索）</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cqq144%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220116144856989.png" alt="image-20220116144856989"></p><p><strong><em>代码（dfs会TLE）：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> path[N][N];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> maxlen,res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(res &gt; maxlen) maxlen = res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = a + dx[i],y = b + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= m &amp;&amp; path[x][y] &lt; path[a][b])</span><br><span class="line">        &#123;</span><br><span class="line">            res ++;</span><br><span class="line">            <span class="built_in">dfs</span>(x,y);</span><br><span class="line">            res --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;path[i][j]);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j ++)</span><br><span class="line">            <span class="built_in">dfs</span>(i,j);</span><br><span class="line">            </span><br><span class="line">    cout &lt;&lt; maxlen + <span class="number">1</span>&lt;&lt; endl;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前面走过的，计算过的就记录下来，下次就不用再走一次，很省时间，所以也叫记忆化搜索</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">310</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> path[N][N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> &amp;v = f[a][b]; <span class="comment">//v改变f[a][b]也改变，除了加速函数参数传递效率，也可以缩短代码长度，比如某个变量名太长，可以用引用换个短点的名字。</span></span><br><span class="line">    <span class="keyword">if</span>(v != <span class="number">-1</span>) <span class="keyword">return</span> v; <span class="comment">//被计算过了</span></span><br><span class="line">    </span><br><span class="line">    v = <span class="number">1</span>; <span class="comment">//每一个至少经过它自己</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = a + dx[i],y = b + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= <span class="number">1</span> &amp;&amp; x &lt;= n &amp;&amp; y &gt;= <span class="number">1</span> &amp;&amp; y &lt;= m &amp;&amp; path[a][b] &gt; path[x][y])</span><br><span class="line">            v = <span class="built_in">max</span>(v,<span class="built_in">dp</span>(x,y) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;path[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;        </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j ++)</span><br><span class="line">            res = <span class="built_in">max</span>(res,<span class="built_in">dp</span>(i,j));</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a><a href="#贪心" title="贪心"></a>贪心</h2><h3 id="区间选点"><a href="#区间选点" class="headerlink" title=" 区间选点"></a><a href="#区间选点" title="区间选点"></a> 区间选点</h3><p>ans为所有方案中的最小值，cnt为此算法得出的方案。易证cnt为合法方案。<br>我们需要证明 ans = cnt</p><p>若要证明 A = B，我们需要证明</p><ol><li>A &gt;= B</li><li>A &lt;= B</li></ol><p>因为ans为所有方案的最小值，所以天然地，ans &lt;= cnt</p><p>重点证明：ans &gt;= cnt</p><p>对于一个区间，我们可以选此区间的右端点或者不选，具体如下：如果和前面的区间重叠，则不选，否则，选。<br>重点来了：</p><ol><li>根据此算法，我们可以得到x个不相交的区间，且选了cnt个点。在算法中，一个区间只会选其右端点，也就是说一个区间只选一个点。因此，我们选了cnt不相交的区间。</li><li>在cnt个不相交的区间，“选择尽量少的点，使得每个区间内至少包含一个选出的点”，最少的方案是每个区间选一个点，即cnt个点</li><li>所以，所有的方案 &gt;= cnt</li><li>因为ans是所有方案的一种</li><li>所以，ans &gt;= cnt (3, 4, 5是三段论证明)</li></ol><p><strong><em>代码（右端点排序，用这种）：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Range &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; t.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        range[i] = &#123;l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(range,range + n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>,ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">        <span class="keyword">if</span>(ed &lt; range[i].l)</span><br><span class="line">        &#123;</span><br><span class="line">            res ++;</span><br><span class="line">            ed = range[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>代码（左端点排序）拓展一下思维就好：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Range &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; t.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        range[i] = &#123;l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(range,range + n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>,ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ed &lt; range[i].l)</span><br><span class="line">        &#123;</span><br><span class="line">            res ++;</span><br><span class="line">            ed = range[i].r;    <span class="comment">//画图思考</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">min</span>(ed,range[i].r);   <span class="comment">// 因为左端点排序的话，一个大区间会存在多个小区间那么要想点数竟可能少，那么就选择小区间的右端点作为覆盖点，小区间可以覆盖大区间，但是不能覆盖大区间内另一个没有重复区域的小区间，所以要维护最右端点值，来因此缩小公共子区间的范围</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大不相交区间"><a href="#最大不相交区间" class="headerlink" title=" 最大不相交区间"></a><a href="#最大不相交区间" title="最大不相交区间"></a> 最大不相交区间</h3><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Range &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> r &lt; t.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        range[i] = &#123;l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(range,range + n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>,ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ed &lt; range[i].l)</span><br><span class="line">        &#123;</span><br><span class="line">            res ++;</span><br><span class="line">            ed = range[i].r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间分组"><a href="#区间分组" class="headerlink" title=" 区间分组"></a><a href="#区间分组" title="区间分组"></a> 区间分组</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cqq144%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220117140723650.png" alt="image-20220117140723650"></p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Range &amp;t)<span class="type">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; t.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        range[i] = &#123;l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(range,range + n);</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        Range t = range[i];</span><br><span class="line">        <span class="keyword">if</span>(heap.<span class="built_in">empty</span>() || heap.<span class="built_in">top</span>() &gt;= t.l) heap.<span class="built_in">push</span>(t.r);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">            heap.<span class="built_in">push</span>(t.r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; heap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间覆盖"><a href="#区间覆盖" class="headerlink" title=" 区间覆盖"></a><a href="#区间覆盖" title="区间覆盖"></a> 区间覆盖</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cqq144%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220117161602142.png" alt="image-20220117161602142"></p><p><img src= "/img/loading.gif" data-src="https://cdn.acwing.com/media/article/image/2020/10/26/652_1a48e6a417-QQ%E5%9B%BE%E7%89%8720201026093918.jpg" alt="QQ图片20201026093918.jpg"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Range</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Range &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l &lt; t.l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;range[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> st,ed;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;st,&amp;ed);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        range[i] = &#123;l,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(range,range + n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> success = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = i,r = <span class="number">-2e9</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; range[j].l &lt;= st)</span><br><span class="line">        &#123;</span><br><span class="line">            r = <span class="built_in">max</span>(r,range[j].r);</span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res ++;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; st)</span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r &gt;= ed)</span><br><span class="line">        &#123;</span><br><span class="line">            success = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        st = r;</span><br><span class="line">        i = j - <span class="number">1</span> <span class="comment">//因为有i ++，所以要先减一后加一保持平衡</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!success) res = <span class="number">-1</span>;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并果子"><a href="#合并果子" class="headerlink" title=" 合并果子"></a><a href="#合并果子" title="合并果子"></a> 合并果子</h3><p>经典哈夫曼树的模型，每次合并重量最小的两堆果子即可。</p><p>时间复杂度<br>使用小根堆维护所有果子，每次弹出堆顶的两堆果子，并将其合并，合并之后将两堆重量之和再次插入小根堆中。</p><p>每次操作会将果子的堆数减一，一共操作 n−1 次即可将所有果子合并成1堆。每次操作涉及到2次堆的删除操作和1次堆的插入操作，计算量是 O(logn)。因此总时间复杂度是 O(nlogn)。</p><p><strong><em>代码：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        heap.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = heap.<span class="built_in">top</span>();heap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> b = heap.<span class="built_in">top</span>();heap.<span class="built_in">pop</span>();</span><br><span class="line">        res += a + b;</span><br><span class="line">        heap.<span class="built_in">push</span>(a + b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排队打水"><a href="#排队打水" class="headerlink" title=" 排队打水"></a><a href="#排队打水" title="排队打水"></a> 排队打水</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt;&gt; heap;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">        heap.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span> <span class="comment">//注意要用long long</span></span><br><span class="line">    <span class="keyword">while</span>(heap.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = heap.<span class="built_in">top</span>();</span><br><span class="line">        heap.<span class="built_in">pop</span>();</span><br><span class="line">        res += t * heap.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;g[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(g,g + n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) res += g[i] * (n - i - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;g[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(g,g + n);</span><br><span class="line">    <span class="built_in">reverse</span>(g,g + n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) res += g[i] * i;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="货仓选址"><a href="#货仓选址" class="headerlink" title=" 货仓选址"></a><a href="#货仓选址" title="货仓选址"></a> 货仓选址</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cqq144%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220118102114808.png" alt="image-20220118102114808"></p><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cqq144%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220118102204930.png" alt="image-20220118102204930"></p><p><strong><em>代码（一）：</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;g[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(g,g + n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) res += <span class="built_in">abs</span>(g[i] - g[n / <span class="number">2</span>]);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> g[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;g[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(g,g + n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++) res += g[i] - g[i / <span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="耍杂技的牛"><a href="#耍杂技的牛" class="headerlink" title=" 耍杂技的牛"></a><a href="#耍杂技的牛" title="耍杂技的牛"></a> 耍杂技的牛</h3><p><img src= "/img/loading.gif" data-src="C:%5CUsers%5Cqq144%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220118145047690.png" alt="image-20220118145047690"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">50010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">PII cow[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> w,s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;w,&amp;s);</span><br><span class="line">        cow[i] = &#123;w + s,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(cow,cow + n);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = <span class="number">-2e9</span>,sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> w = cow[i].second,s = cow[i].first - w;</span><br><span class="line">        res = <span class="built_in">max</span>(res,sum - s);</span><br><span class="line">        sum += w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PDF处理工具推荐</title>
      <link href="/posts/520503/"/>
      <url>/posts/520503/</url>
      
        <content type="html"><![CDATA[<p><strong>💡 文章转自<a href="https://lin64850.github.io/">Eureka</a>——PDF处理工具推荐</strong></p><h2 id="📕-PDF处理工具推荐"><a href="#📕-PDF处理工具推荐" class="headerlink" title="📕 PDF处理工具推荐"></a><strong>📕 PDF处理工具推荐</strong></h2><blockquote><p>集合了很多 PDF 处理工具支持格式转换、PDF 编辑、合并、分割、加水印、OCR 识别、压缩、签名、加密/解密、旋转等，功能非常丰富</p></blockquote><p>1、smallPDF：<br><a href="https://smallpdf.com/">https://smallpdf.com/</a><br>2、Online OCR：<br><a href="https://www.onlineocr.net/">https://www.onlineocr.net/</a><br>3、PDF to Word Converter：<br><a href="https://www.pdftoword.com/">https://www.pdftoword.com/</a><br>4、加加PDF：<br><a href="https://www.addpdf.cn/pdf-to-word">https://www.addpdf.cn/pdf-to-word</a><br>5、ilovePDF：<br><a href="https://www.ilovepdf.com/">https://www.ilovepdf.com/</a><br>6、PDFconverter：<br><a href="https://www.pdfconverter.com/">https://www.pdfconverter.com</a><br>7、PDFbao：<br><a href="http://www.pdfbao.com/">http://www.pdfbao.com/</a><br>8、LightPDF - 免费在线编辑、转换PDF文件<br><a href="https://lightpdf.com/zh/">https://lightpdf.com/zh/</a><br>9、cloudconvert：<br><a href="https://cloudconvert.com/pdf-to-doc">https://cloudconvert.com/pdf-to-doc</a><br>10、迅捷PDF转换器：<br><a href="https://app.xunjiepdf.com/">https://app.xunjiepdf.com/</a><br>11、UPDF正文编辑、注释、PDF 转换、页面管理<br><a href="https://www.updf.cn/updf/">https://www.updf.cn/updf/</a><br>12、PDF2go：<br><a href="https://www.pdf2go.com/zh/">https://www.pdf2go.com/zh/</a><br>13、ABBYY FineReader：<br><a href="https://ocr.abbyy.cn/">https://ocr.abbyy.cn/</a><br>14、PDF.IO：<br><a href="https://pdf.io/tw/">https://pdf.io/tw/</a><br>15、PDFtodoc：<br><a href="http://pdf2doc.com/zh/">http://pdf2doc.com/zh/</a><br>16、pdfcandy：<br><a href="https://pdfcandy.com/cn/">https://pdfcandy.com/cn/</a><br>17、记灵工具<br><a href="https://remeins.com/">https://remeins.com/</a><br>18、超级PDF<br><a href="https://xpdf.cn/">https://xpdf.cn/</a><br>19、PDF24 Tools<br><a href="https://tools.pdf24.org/zh/">https://tools.pdf24.org/zh/</a><br>20、ALL TO ALL<br><a href="https://www.alltoall.net/">https://www.alltoall.net/</a><br>21、TinyWow<br><a href="https://tinywow.com/">https://tinywow.com/</a><br>22、免费的即时PDF转换器 (2022)<br><a href="https://www.pdfwordconvert.com/zh/">https://www.pdfwordconvert.com/zh/</a><br>23、PDF转换<br><a href="https://www.onlinepdftoimage.com/zh/">https://www.onlinepdftoimage.com/zh/</a><br>24、免费在线PDF分配器<br><a href="https://www.splitapdf.com/zh/">https://www.splitapdf.com/zh/</a><br>25、文件格式转换工具<br><a href="https://www.aconvert.com/">https://www.aconvert.com/</a><br>26、ZAMZAR<br><a href="https://www.zamzar.com/">https://www.zamzar.com/</a><br>27、CAJ 转 PDF 转换器（GUI 版本）<br><a href="https://caj2pdf-qt.sainnhe.dev/">https://caj2pdf-qt.sainnhe.dev/</a><br>28、Web Apps by 123apps<br><a href="https://123apps.com/">https://123apps.com/</a><br>29、立即翻译任何文档格式为任意语言，并保持排版不变。免费<br><a href="https://www.onlinedoctranslator.com/zh-CN/">https://www.onlinedoctranslator.com/zh-CN/</a><br>30、docsmall<br><a href="https://docsmall.com/">https://docsmall.com/</a><br>31、HiPDF让PDF变得简单高效<br><a href="https://www.hipdf.cn/">https://www.hipdf.cn/</a><br>32、PDF派几十个强大的PDF在线工具，无限次使用，永久免费<br><a href="https://www.pdfpai.com/">https://www.pdfpai.com/</a><br>33、PDF和图像（JPG，BMP，TIFF，GIF）中提取文本，并转换为可编辑的Word<br><a href="https://www.onlineocr.net/">https://www.onlineocr.net/</a><br>34、rightpdf<br><a href="https://online.rightpdf.com/cn/office-to-pdf">https://online.rightpdf.com/cn/office-to-pdf</a><br>35、PDF格式转换<br><a href="http://www.pdfbao.com/pdf2word.html">http://www.pdfbao.com/pdf2word.html</a><br>36、免费的在线工具将DOC/DOCX文档转换成PDF<br><a href="https://doctopdf.com/zh/">https://doctopdf.com/zh/</a><br>37、PDF Burger<br><a href="https://pdfburger.com/combine-to-pdf">https://pdfburger.com/combine-to-pdf</a><br>38、PDF转换器<br><a href="https://pdf.to/">https://pdf.to/</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发JUC</title>
      <link href="/posts/520502/"/>
      <url>/posts/520502/</url>
      
        <content type="html"><![CDATA[<h1 id="Java并发JUC"><a href="#Java并发JUC" class="headerlink" title="Java并发JUC"></a>Java并发JUC</h1><h2 id="1、进程与线程"><a href="#1、进程与线程" class="headerlink" title="1、进程与线程"></a>1、进程与线程</h2><blockquote><ul><li><p>进程：系统进行系统进行资源分配和调度的基本单位</p><ul><li>狭义定义：进程是正在运行的程序的实例</li><li>广义定义：进程是一个具有一定独立功能的系统对于某个数据集合的一种运行活动</li></ul></li><li><p>线程：操作系统能够运算调度的最小单位，是进程中的实际运作单位</p></li></ul></blockquote><h2 id="2、创建线程的三种方式"><a href="#2、创建线程的三种方式" class="headerlink" title="2、创建线程的三种方式"></a>2、创建线程的三种方式</h2><blockquote><p>2.1实现Runnable接口来创建Thread线程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TheardCreateDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SomeRunnable</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        <span class="comment">//lamda表达式方式</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;使用lamda表达式方式&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:: 通过实现Runnable接口来创建Thread线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.2继承Thread类创建线程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TheardCreateDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SomeThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SomeThread</span>();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过继承Thread类来创建一个线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.3实现Callable接口来创建Thread线程，通过FutureTask可以获取线程返回值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TheardCreateDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        </span><br><span class="line">        FutureTask&lt;Object&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Object&gt;(<span class="keyword">new</span> <span class="title class_">SomeCallable</span>&lt;Object&gt;());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">oneThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        </span><br><span class="line">        oneThread.start();</span><br><span class="line">        <span class="comment">// 这里可以在运行之后获得 返回值</span></span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SomeCallable</span>&lt;Object&gt; <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Object&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;通过实现Callable接口来创建Thread线程&quot;</span>);</span><br><span class="line">        <span class="comment">// 这个是可以返回数据的 这里就随便返回个 1024 哈</span></span><br><span class="line">        <span class="keyword">return</span> (Object)<span class="string">&quot; 这个是可以返回数据的 这里就随便返回个哈&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3、并发与并行"><a href="#3、并发与并行" class="headerlink" title="3、并发与并行"></a>3、并发与并行</h2><ul><li><p>并行：当系统有一个核以上CPU时，多个CPU执行不同的进程，互不抢占资源，可以同时进行，称为并行</p></li><li><p>并发：同一处理器同时处理多个任务，通过上下文快速切换营造一种同时运行多个进程的假象</p></li></ul><h2 id="4、用户线程与守护线程"><a href="#4、用户线程与守护线程" class="headerlink" title="4、用户线程与守护线程"></a>4、用户线程与守护线程</h2><ul><li>用户线程：默认情况下我们创建的线程或线程池都是用户线程，所以用户线程也被称之为普通线程</li><li>守护线程：在程序运行的时候在后台提供一种通用服务的线程，服务于用户线程，当程序中的用户线程全部执      行结束之后，守护线程也会随之结束</li></ul><h2 id="5、synchronized的作用范围"><a href="#5、synchronized的作用范围" class="headerlink" title="5、synchronized的作用范围"></a>5、synchronized的作用范围</h2><blockquote><p>synchronized是Java中的关键字，是一种同步锁</p></blockquote><p>1、修饰某一处代码块，被修饰的代码块称为同步语句块。作用范围是{}之间，作用的对象是调用该代码块的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;同步代码块 &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、修饰在方法上，被修饰的方法称为同步方法。作用范围是整个方法，作用对象是调用该方法的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>！注：synchronized关键字不能被继承，如果父类中某方法使用了synchronized关键字，子类又正巧覆盖了，此时子类该方法默认是不同步的，必须显示在子类的方法上加上才可。当然，如果在子类方法中调用父类中的同步方法，虽然子类没有同步方法，但调用父类的同步方法也相当于同步了。</p></blockquote><p>3、修饰静态方法，作用范围是整个静态方法，作用对象是该类的所有对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、修饰某个类，其作用范围是synchronized后面括号中的部分，作用对象是该类的所有对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (Ticket.class) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、案例(sale方法被synchronized关键字修饰，所以线程调用sale方法需要等上一个线程释放锁)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Ticket</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Ticket</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">                ticket.sale();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;C&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Ticket</span> &#123;</span><br><span class="line">    <span class="comment">//票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//操作方法：卖票</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sale</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//判断：是否有票</span></span><br><span class="line">        <span class="keyword">if</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; : &quot;</span> + (number--) + <span class="string">&quot; &quot;</span> + number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、总结</p><p>synchronized 的同步效率非常低，因为一个如果某一块代码被synchronized 修饰了，当某一个线程进入了synchronized 修饰的代码块，那么其他线程只能一直等待，等待获取锁的线程释放锁，才能进入再次进入同步代码块。</p><p>获取锁的线程释放锁的情况只有两种：</p><ol><li>正常执行完，然后释放锁。</li><li>执行过程中，发生异常，JVM让线程自动释放锁。</li></ol><p>那么你试想一个如果获取到锁的这个线程，由于一些等待ＩＯ原因或其他原因被堵住了，但是又不能释放锁，其他线程就只能在synchronized的门口看着啦，你想一下这个效率吧，出现一次，可能就把人心态玩没啦哈。😂</p><p>因此非常需要有一种机制能够不让等待的线程一直无限期的等待下去，比如改成等待一段时间或者响应中断，该怎么做呢？我们可以通过Lock来做这件事情。</p><h2 id="6、Lock锁机制详解"><a href="#6、Lock锁机制详解" class="headerlink" title="6、Lock锁机制详解"></a>6、Lock锁机制详解</h2><blockquote><p>显式锁，完全用Java写成，在Java这个层面上是无关JVM实现的。虽然Lock缺少了(synchronized块或者方法所提供的)隐式获取/释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断获取锁以及超时获取锁等多种synchronized关键字不具备的同步特性。</p></blockquote><h3 id="6-1锁的类型"><a href="#6-1锁的类型" class="headerlink" title="6.1锁的类型"></a>6.1锁的类型</h3><ul><li>可重入锁：在执行对象中所有同步方法不用再次获得锁</li><li>可中断锁：在等待获取锁的过程中可中断</li><li>公平锁：按照请求获取锁的顺序进行获取，即等待时间长的具有优先获取锁的权力</li><li>读写锁：对资源读取和写入的时候拆分为两部分处理<ul><li>读锁为共享锁，读的时候可以多线程一起读</li><li>写锁为排它锁(独占锁)，写的时候必须同步的写</li></ul></li></ul><h3 id="6-2Lock接口"><a href="#6-2Lock接口" class="headerlink" title="6.2Lock接口"></a>6.2Lock接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>; <span class="comment">//获得锁。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    除非当前线程被中断，否则获取锁。</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">如果可用，则获取锁并立即返回。</span></span><br><span class="line"><span class="comment">如果锁不可用，则当前线程将出于线程调度目的而被禁用并处于休眠状态，直到发生以下两种情况之一：</span></span><br><span class="line"><span class="comment">锁被当前线程获取； </span></span><br><span class="line"><span class="comment">要么其他一些线程中断当前线程，支持中断获取锁。</span></span><br><span class="line"><span class="comment">如果当前线程：</span></span><br><span class="line"><span class="comment">在进入此方法时设置其中断状态； </span></span><br><span class="line"><span class="comment">要么获取锁时中断，支持中断获取锁，</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    仅在调用时空闲时才获取锁。</span></span><br><span class="line"><span class="comment">如果可用，则获取锁并立即返回值为true 。 如果锁不可用，则此方法将立即返回false值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//比上面多一个等待时间 </span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;  </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//返回绑定到此Lock实例的新Condition实例。</span></span><br><span class="line">    Condition <span class="title function_">newCondition</span><span class="params">()</span>;  。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、lock()是最常用的方法之一，作用就是获取锁，如果锁已经被其他线程获取，则当前线程将被禁用以进行线程调度，并处于休眠状态，等待，直到获取锁。</p><blockquote><p><strong>！注：使用lock的话，不管有没有发生异常，都必须去主动释放锁，因为lock并不会像synchronized一样被自动释放。所以使用lock的话，必须是在try{}catch{}中进行，并将释放锁的操作unlock()放在finally{}代码块中，确保锁一定会被释放，避免发生死锁的现象。</strong></p></blockquote><p>2、unlock()的作用就是主动释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    System.out.println(<span class="string">&quot;上锁了&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">    System.out.println(<span class="string">&quot;解锁了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-3Condition类实现等待-通知"><a href="#6-3Condition类实现等待-通知" class="headerlink" title="6.3Condition类实现等待/通知"></a>6.3Condition类实现等待/通知</h3><p>关键字 synchronized 与 wait()/notify()这两个方法一起使用可以实现等待/通知模式， <strong>Lock 锁的 newContition()方法返回 Condition 对象，Condition 类 也可以实现等待/通知模式</strong>。 用 notify()通知时，JVM 会随机唤醒某个等待的线程， 使用 Condition 类可以 进行选择性通知， Condition 比较常用的两个方法：</p><ul><li><strong>await()</strong>：会使当前线程等待,同时会释放锁,当等到其他线程调用<code>signal()</code>方法时,此时这个沉睡线程会重新获得锁并继续执行代码（在哪里沉睡就在哪里唤醒）。</li><li><strong>signal()</strong>：用于唤醒一个等待的线程。</li></ul><p><code>注意</code>：在调用 Condition 的 await()/signal()方法前，也需要线程持有相关 的 Lock 锁，调用 await()后线程会释放这个锁，在调用singal()方法后会从当前 Condition对象的等待队列中，唤醒一个线程，后被唤醒的线程开始尝试去获得锁， 一旦成功获得锁就继续往下执行。</p><p>在这个地方我们举个例子来用代码写一下：</p><p>例子：我们有两个线程，实现对一个初始值是0的number变量，一个线程当number = =0时 对number值+1，另外一个线程当number = = 1时对number-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Share</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">newCondition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// +1 的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">incr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(); <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">0</span>) &#123;</span><br><span class="line">                newCondition.await();<span class="comment">//沉睡</span></span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;::&quot;</span> + number);</span><br><span class="line">            newCondition.signal(); <span class="comment">//唤醒另一个沉睡的线程 </span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -1 的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                newCondition.await();</span><br><span class="line">            &#125;</span><br><span class="line">            number--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;::&quot;</span> + number);</span><br><span class="line">            newCondition.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Share</span> <span class="variable">share</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Share</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">                share.incr();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;AA&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">                share.decr();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;BB&quot;</span>).start();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * AA::1</span></span><br><span class="line"><span class="comment">         * BB::0</span></span><br><span class="line"><span class="comment">         * AA::1</span></span><br><span class="line"><span class="comment">         * BB::0</span></span><br><span class="line"><span class="comment">         * .....</span></span><br><span class="line"><span class="comment">         */</span>     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-4ReentrantLock-可重入锁"><a href="#6-4ReentrantLock-可重入锁" class="headerlink" title="6.4ReentrantLock(可重入锁)"></a>6.4ReentrantLock(可重入锁)</h3><blockquote><p>ReentrantLock是可重入锁，是唯一实现了Lock接口的类，并且提供了更多方法</p><p>可重入锁：某个线程已经获得某个锁之后，可以再次获取锁而不会出现死锁现象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.lock();</span><br><span class="line">                    System.out.println(<span class="string">&quot;第1次获取锁，这个锁是：&quot;</span> + lock);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i&lt;=<span class="number">11</span>;i++)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.lock();</span><br><span class="line">                            System.out.println(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次获取锁，这个锁是：&quot;</span> + lock);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">200</span>));</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                           lock.unlock();<span class="comment">// 如果把这里注释掉的话，那么程序就会陷入死锁当中。</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();<span class="comment">//使用Lock必须手动解锁</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line">                    System.out.println(<span class="string">&quot;这里是为了测试死锁而多写一个的线程&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第1次获取锁，这个锁是：java.util.concurrent.locks.ReentrantLock@6b5fde1f[Locked by thread Thread-0]</span></span><br><span class="line"><span class="comment"> * 第2次获取锁，这个锁是：java.util.concurrent.locks.ReentrantLock@6b5fde1f[Locked by thread Thread-0]</span></span><br><span class="line"><span class="comment"> * 第3次获取锁，这个锁是：java.util.concurrent.locks.ReentrantLock@6b5fde1f[Locked by thread Thread-0]</span></span><br><span class="line"><span class="comment"> * ...</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="6-5ReadWriteLock读写锁"><a href="#6-5ReadWriteLock读写锁" class="headerlink" title="6.5ReadWriteLock读写锁"></a>6.5ReadWriteLock读写锁</h3><blockquote><p>ReadWriteLock也是一个接口，在它里面只定义了两个接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadWriteLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取读锁</span></span><br><span class="line">    Lock <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取写锁</span></span><br><span class="line">    Lock <span class="title function_">writeLock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分为一个读锁一个写锁，将读写进行分离，使多个线程可以同时进行读操作，提高效率</p><p>ReentrantReadWriteLock实现了ReadWriteLock接口，提供了更丰富的方法，当然最主要的还是获取读写锁</p><blockquote><p>使用synchronized实现多个线程共同读操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">SynchronizedDemo2</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedDemo2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            test.get(Thread.currentThread());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            test.get(Thread.currentThread());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span>(System.currentTimeMillis() - start &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">&quot;正在进行读操作&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(thread.getName()+<span class="string">&quot;读操作完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出</span></span><br><span class="line"><span class="comment"> * Thread-0正在进行读操作</span></span><br><span class="line"><span class="comment"> * Thread-0读操作完毕</span></span><br><span class="line"><span class="comment"> * Thread-1正在进行读操作</span></span><br><span class="line"><span class="comment"> * Thread-1正在进行读操作</span></span><br><span class="line"><span class="comment"> * Thread-1正在进行读操作</span></span><br><span class="line"><span class="comment"> * ....</span></span><br><span class="line"><span class="comment"> * Thread-1读操作完毕</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><blockquote><p>使用读写锁实现多个线程共同读操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rwl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">SynchronizedDemo2</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedDemo2</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            test.get2(Thread.currentThread());</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            test.get2(Thread.currentThread());</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get2</span><span class="params">(Thread thread)</span> &#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">while</span>(System.currentTimeMillis() - start &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(thread.getName()+<span class="string">&quot;正在进行读操作&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">&quot;读操作完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 输出</span></span><br><span class="line"><span class="comment"> * Thread-0正在进行读操作</span></span><br><span class="line"><span class="comment"> * Thread-1正在进行读操作</span></span><br><span class="line"><span class="comment"> * Thread-0读操作完毕</span></span><br><span class="line"><span class="comment"> * Thread-1读操作完毕</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>！！！注意：</strong></p><p><strong>1、若此时已经有一个线程占用了读锁，此时其他线程申请读锁是可以的，但如果想申请写锁，则必须等待读锁释放，才能成功获得</strong></p><p><strong>2、若此时已经有一个线程占用了写锁，此时其他线程申请读锁还是写锁都是不允许的，只有等待持有写锁的线程释放锁，才能成功获得</strong></p></blockquote><h3 id="6-6synchronized与Lock的区别"><a href="#6-6synchronized与Lock的区别" class="headerlink" title="6.6synchronized与Lock的区别"></a>6.6synchronized与Lock的区别</h3><p><img src= "/img/loading.gif" data-src="https://qiniu.azkk.top/typora/image-20240310142432950.png" alt="image-20240310142432950"></p><h2 id="7、集合的线程安全问题"><a href="#7、集合的线程安全问题" class="headerlink" title="7、集合的线程安全问题"></a>7、集合的线程安全问题</h2><blockquote><p>问题引入：这段程序能看出问题吗？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString());</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;, <span class="string">&quot;线程&quot;</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：ArrayList的add方法并非线程同步的，在读取list的时候刚好遇到写操作，这里没有同步代码块以及加锁，会报<code>ConcurrentModificationException</code>的异常，中文名为：并发修改异常</p><blockquote><p>解决方法：</p></blockquote><blockquote><p>方式一：使用vector集合来代替ArrayList</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString());</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;, <span class="string">&quot;线程&quot;</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vector源代码中add方法是有synchronized关键字的，是同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    add(e, elementData, elementCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>方式二：使用Collections</p></blockquote><p>Collections提供了方法synchronizedList保证List是同步的，线程安全的</p><p>Collections仅包含对集合进行操作或返回集合的静态方法，也称为集合的工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString());</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;, <span class="string">&quot;线程&quot;</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Collections源码中add方法包含一个同步代码块，块中调用list集合的add方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;list.add(index, element);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>方式三：使用CopyOnWriteArrayList代替ArrayList</p></blockquote><blockquote><p>CopyOnWriteArrayList 是一个线程安全的 List 集合，它采用了读写分离的思想，即在写操作时，先复制当前数组，然后在新数组上进行写操作，最后通过指向新数组的方式完成对象的引用。由于读操作无需加锁，因此读写操作并不冲突。</p></blockquote><p>CopyOnWriteArrayList有以下几个特点：</p><ul><li>更新操作开销大（add、set、remove），因为要复制整个数组</li><li>读写分离，写操作加锁，读操作无须加锁，适用于读多写少的场景</li><li>在迭代时可能存在数据不一致问题，在迭代过程中应该避免对集合进行修改</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            list.add(UUID.randomUUID().toString());</span><br><span class="line">            System.out.println(list);</span><br><span class="line">        &#125;, <span class="string">&quot;线程&quot;</span> + i).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么CopyOnWriteArrayList不会出现线程安全问题？</p><p>答：</p><p>1、在涉及到更新操作时，都会复制当前数组，在新数组上做更新，最后将引用指向新数组</p><p>2、由volatile数组来保存原数组的引用，保证读线程可以读取到写线程最新更新完成的数据，即更新之后数据的地址已经改变，所以必须使用volalite关键字使得读线程可以通过valolite数组得到数据最新的引用</p><p>3、在更新操作时，都会率先去获取互斥锁， 在修改完毕之后，先将数据更新到“volatile 数组”中，然后再“释放互斥锁”，这样就能够保证数据的安全</p><h2 id="8、Callable接口"><a href="#8、Callable接口" class="headerlink" title="8、Callable接口"></a>8、Callable接口</h2><blockquote><p>Callable类似于Runnable接口，但Runnable接口中的run()方法不会返回结果，并且也无法抛出经过检查的异常，但是Callable接口中的call()方法能够返回计算结果，并且也能够抛出经过检查的异常。</p></blockquote><h3 id="8-1Callable接口"><a href="#8-1Callable接口" class="headerlink" title="8.1Callable接口"></a>8.1Callable接口</h3><p><strong>通过实现Callable接口创建线程详细步骤</strong>：</p><ol><li><p>创建实现Callable接口的类SomeCallable</p></li><li><p>创建一个类对象：Callable oneCallable = new SomeCallable();</p></li><li><p>由Callable创建一个FutureTask对象：FutureTask futureTask= new FutureTask(oneCallable);</p><p>注释：FutureTask是一个包装器，它通过接受Callable来创建，它同时实现了Future和Runnable接口。</p></li><li><p>由FutureTask创建一个Thread对象：Thread oneThread = new Thread(futureTask);</p></li><li><p>启动线程：oneThread.start();</p></li></ol><p>这里之所以要转成 FutureTask 放进 Thread中去，是因为Callable 本身与Thread没有关系，通过FutureTask 才能和Thread产生联系。</p><h3 id="8-2Future接口"><a href="#8-2Future接口" class="headerlink" title="8.2Future接口"></a>8.2Future接口</h3><blockquote><p>Future接口提供方法来检测任务是否被执行完，等待任务执行完获得结果，也可以设置任务的超时时间。这个设置超时的方法就是实现Java程序执行超时的关键。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Future</span>&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">cancel</span><span class="params">(<span class="type">boolean</span> mayInterruptIfRunning)</span>; <span class="comment">//尝试取消此任务的执行。</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isCancelled</span><span class="params">()</span>;<span class="comment">//如果此任务在正常完成之前被取消，则返回true </span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isDone</span><span class="params">()</span>; <span class="comment">//如果此任务完成，则返回true 。 完成可能是由于正常终止、异常或取消——在所有这些情况下，此方法将返回true </span></span><br><span class="line"></span><br><span class="line">    V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException; <span class="comment">//获得任务计算结果</span></span><br><span class="line"></span><br><span class="line">    V <span class="title function_">get</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> </span><br><span class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;<span class="comment">//可等待多少时间去获得任务计算结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Future模式通俗点来描述就是：我有一个任务，提交给了Future，Future替我完成这个任务。期间我自己可以去做任何想做的事情。一段时间之后，我就便可以<strong>从Future那儿取出结果</strong>。</p><h3 id="8-3FutureTask"><a href="#8-3FutureTask" class="headerlink" title="8.3FutureTask"></a>8.3FutureTask</h3><blockquote><p>FutureTask类提供Future的基本实现，具有启动和取消计算，查看计算是否完成以及检索计算结果的方法。计算完成后才可以检索结果；如果计算尚未完成，get方法将阻塞。一旦计算完成，就不能重新开始或取消计算（除非调用runAndReset方法调用计算）</p></blockquote><p><img src= "/img/loading.gif" data-src="https://qiniu.azkk.top/typora/image-20240310142459690.png" alt="image-20240310142459690"></p><p><strong>FutureTask实现了 Runnable 和 Future接口，并方便地将两种功能组合在一起。并且通过构造函数提供Callable来创建FutureTask，就可以提供给Thread来创建线程啦。</strong></p><p>FutureTask有以下三种状态：</p><ol><li>未启动状态：还未执行run（）方法。</li><li>已启动状态：已经在执行run（）方法。</li><li>完成状态：已经执行完run()方法，或者被取消了，亦或者方法中发生异常而导致中断结束。</li></ol><p><strong>应用场景：</strong></p><p>1、在主线程执行比较耗时的操作，但同时又不能去阻塞主线程时，就可以将这样的任务交给FutureTask对象在后台完成，然后等待之后主线程需要的时候，再直接通过get()方法来获得返回数据或者通过isDone()获得任务状态。</p><p>2、一般FutureTask多应用于耗时的计算，这样主线程就可以把一个耗时的任务交给FutureTask，然后等到完成自己的任务后，再去获取计算结果。</p><p><strong>注意</strong>：</p><ul><li>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。</li><li>一旦计 算完成，就不能再重新开始或取消计算。</li><li>get 方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常。</li><li>因为只会计算一次,因此通常get方法放到最后。</li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语学习</title>
      <link href="/posts/520505/"/>
      <url>/posts/520505/</url>
      
        <content type="html"><![CDATA[<p><strong>💡 文章转自<a href="https://lin64850.github.io/">Eureka</a>——收集汇总英语学习方面的插件，文档，经验等资源</strong></p><hr><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a><a href="#注意" title="注意"></a>注意</h1><ol><li><strong>本文链接字样<code>项目</code>为Github链接，国内用户访问不了GitHub可通过镜像网站访问.</strong></li></ol><blockquote><p>🌐 GitHub镜像网站 <a href="https://www.library.ac.cn/">镜像源</a></p><p>💥 GitHub加速网站 <a href="https://github.com/dotnetcore/FastGithub">FastGithub</a> <a href="https://mirror.ghproxy.com/">GitHubProxyMirror</a> <a href="https://gh.api.99988866.xyz/">GitHub文件加速</a> <a href="https://ghproxy.com/">GitHubProxy</a></p></blockquote><ol start="2"><li><strong>以下 辅助插件 所有涉及软件均打包在此链接</strong></li></ol><blockquote><p>🔰 辅助插件软件打包 <a href="%5Bhttps://pan.baidu.com/s/1miKzGBLUywF3jJNbnF83SA?pwd=tck2%5D(https://pan.baidu.com/s/1miKzGBLUywF3jJNbnF83SA?pwd=tck2)">链接</a> 提取码：tck2</p></blockquote><h1 id="辅助软件"><a href="#辅助软件" class="headerlink" title="辅助软件"></a><a href="#辅助软件" title="辅助软件"></a>辅助软件</h1><table><thead><tr><th>名称</th><th><strong>Pot跨平台的划词翻译软件</strong> 【更新：2023-04-22】</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://pot-app.com/">https://pot-app.com/</a></td></tr><tr><td><strong>下载</strong></td><td><a href="https://github.com/Pylogmon/pot/releases">https://github.com/Pylogmon/pot/releases</a></td></tr><tr><td><strong>平台</strong></td><td>Linux /Windows /MacOS</td></tr><tr><td><strong>简介</strong></td><td>一个跨平台的划词翻译软件</td></tr></tbody></table><table><thead><tr><th>名称</th><th><strong>沉浸式双语网页翻译扩展</strong> 【更新：2023-04-22】</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://immersive-translate.owenyoung.com/">https://immersive-translate.owenyoung.com/</a></td></tr><tr><td><strong>下载</strong></td><td><a href="https://github.com/immersive-translate/immersive-translate/releases">https://github.com/immersive-translate/immersive-translate/releases</a></td></tr><tr><td><strong>平台</strong></td><td>Linux /Windows /MacOS /IOS /Android</td></tr><tr><td><strong>简介</strong></td><td>1，智能识别网页主内容区进行翻译，与同类插件翻译整个网页不同，降低对原网页的“侵入性”，提升阅读体验，因此得名“沉浸式翻译”。 2，双语显示，中英文对照。 3，针对常见主流网站进行定制优化，如 Twitter，Reddit，Discord, Gmail, Telegram, Youtube, Hacker News 等。 4，支持 10 余种常用翻译服务，包括 Deepl，OpenAI(ChatGPT 3.5)，谷歌，彩云小译，腾讯翻译君，百度翻译，火山翻译等。 5，支持 PDF 文件，EPUB 电子书双语翻译，制作与导出。 6，全平台浏览器支持，包括桌面端、移动端，iOS 端，Chrome、Edge、Firefox，Safari 等。 7，提供多种译文样式选择，如弱化、模糊、下划线、分隔线等样式，个性化定制翻译体验</td></tr></tbody></table><table><thead><tr><th><strong>名称</strong></th><th>幕境 MuJing 【更新：2023-02-20】</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://github.com/tangshimin/typing-learner">https://github.com/tangshimin/MuJing</a></td></tr><tr><td><strong>下载</strong></td><td><a href="https://github.com/tangshimin/MuJing/releases/tag/v2.0-beta02">https://github.com/tangshimin/MuJing/releases/tag/v2.0-beta02</a></td></tr><tr><td><strong>平台</strong></td><td>Win MacOS</td></tr><tr><td><strong>简介</strong></td><td>沉浸式学英语,使用自己感兴趣的电影、美剧或文档，生成词库（单词本）。在记忆单词时，可以练习拼写并观看相关的视频片段，以便更好的理解和记忆单词。播放电影时，以弹幕的形式复习词库中的单词，使得单词记忆不再是一件乏味的事</td></tr></tbody></table><table><thead><tr><th><strong>名称</strong></th><th>BlueSea</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://github.com/jiangqizheng/BlueSea">https://github.com/jiangqizheng/BlueSea</a></td></tr><tr><td><strong>下载</strong></td><td><a href="https://www.yuque.com/attachments/yuque/0/2022/zip/2661861/1658993295786-9175ab76-d207-423a-9326-438411b0e73b.zip?_lake_card=%7B%22src%22:%22https://www.yuque.com/attachments/yuque/0/2022/zip/2661861/1658993295786-9175ab76-d207-423a-9326-438411b0e73b.zip%22,%22name%22:%22BlueSea-main.zip%22,%22size%22:6309342,%22type%22:%22application/x-zip-compressed%22,%22ext%22:%22zip%22,%22source%22:%22%22,%22status%22:%22done%22,%22mode%22:%22title%22,%22download%22:true,%22taskId%22:%22u6ed905cc-35fd-43ab-b20c-2bd9de1cab0%22,%22taskType%22:%22upload%22,%22__spacing%22:%22both%22,%22id%22:%22udc91c22b%22,%22margin%22:%7B%22top%22:true,%22bottom%22:true%7D,%22card%22:%22file%22%7D">BlueSea-main.zip</a></td></tr><tr><td><strong>平台</strong></td><td>浏览器插件</td></tr><tr><td><strong>简介</strong></td><td>一个有趣的英语学习扩展，支持划词翻译、单词高亮、单词弹幕、记忆曲线复习、词频统计，单词到复习时间，自动创建单词弹幕在页面内出现，选择认识或不认识，动态调整复习计划</td></tr></tbody></table><table><thead><tr><th><strong>名称</strong></th><th>深蓝英文字幕助手</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://github.com/studyzy/LearnEnglishBySubtitle">https://github.com/studyzy/LearnEnglishBySubtitle</a></td></tr><tr><td><strong>下载</strong></td><td><a href="https://github.com/studyzy/LearnEnglishBySubtitle/releases/download/v1.0/Release_1.0.zip">https://github.com/studyzy/LearnEnglishBySubtitle/releases/download/v1.0/Release_1.0.zip</a></td></tr><tr><td><strong>平台</strong></td><td>Win</td></tr><tr><td><strong>简介</strong></td><td>是一款学习英语的辅助工具，可以通过记录用户的词汇量，然后对英文字幕中不认识的单词进行注释，做到摆脱中文字幕看懂美剧英剧</td></tr></tbody></table><table><thead><tr><th><strong>名称</strong></th><th>vscode 插件</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://github.com/mqycn/huile8">https://github.com/mqycn/huile8</a></td></tr><tr><td><strong>下载</strong></td><td><a href="https://marketplace.visualstudio.com/items?itemName=mqycn.huile8">https://marketplace.visualstudio.com/items?itemName=mqycn.huile8</a></td></tr><tr><td><strong>平台</strong></td><td>VsCode</td></tr><tr><td><strong>简介</strong></td><td>英语差等生必备的 vscode 插件，解决 单词不会读、单词不认识的痛点</td></tr></tbody></table><table><thead><tr><th><strong>名称</strong></th><th>English Buoy</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://github.com/bigzhu/EbuoyDoc">https://github.com/bigzhu/EbuoyDoc</a></td></tr><tr><td><strong>下载</strong></td><td><a href="https://ebuoydoc.bigzhu.net/#/">https://ebuoydoc.bigzhu.net/#/</a></td></tr><tr><td><strong>平台</strong></td><td>安卓</td></tr><tr><td><strong>简介</strong></td><td>将 YouTube 字幕生成文章, 看视频时标记单词, 娱乐兼顾英语提升</td></tr></tbody></table><table><thead><tr><th><strong>名称</strong></th><th>Qwerty Learner</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://github.com/Kaiyiwing/qwerty-learner">https://github.com/Kaiyiwing/qwerty-learner</a></td></tr><tr><td><strong>下载</strong></td><td><a href="https://kaiyiwing.gitee.io/qwerty-learner/">https://kaiyiwing.gitee.io/qwerty-learner/</a></td></tr><tr><td><strong>平台</strong></td><td>VsCode 网页</td></tr><tr><td><strong>简介</strong></td><td>为键盘工作者设计的单词记忆与英语肌肉记忆锻炼软件</td></tr></tbody></table><table><thead><tr><th><strong>名称</strong></th><th>Language Reactor</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://www.languagereactor.com/">https://www.languagereactor.com/</a></td></tr><tr><td><strong>下载</strong></td><td><a href="https://www.appinn.com/language-reactor/">https://www.appinn.com/language-reactor/</a></td></tr><tr><td><strong>平台</strong></td><td>浏览器插件</td></tr><tr><td><strong>简介</strong></td><td>一款 Chrome 扩展，专门用来在看剧的时候学外语，比如在线视频、本地视频，支持任何带有字幕的视频，甚至 .txt 文本文件也可以，它会将字幕列出来，支持每播放完一句台词就暂停，让你思考或者重复播放，鼠标停留在字幕上还会显示单词具体信息，让你能够在轻松的环境下学习一门地道的外语</td></tr></tbody></table><table><thead><tr><th><strong>名称</strong></th><th>linguix</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://linguix.com/">https://linguix.com/</a></td></tr><tr><td><strong>下载</strong></td><td><a href="https://linguix.com/apps">https://linguix.com/apps</a></td></tr><tr><td><strong>平台</strong></td><td>浏览器插件 MacOSWin</td></tr><tr><td><strong>简介</strong></td><td>检查拼写及语法错误，并结合上下文为同学提供最适合的语法、风格建议等.你也可以在Linguix上学习到关于如何增强商务邮件/学术邮件/个人英文写作项目阅读效果的建议.</td></tr></tbody></table><table><thead><tr><th><strong>名称</strong></th><th>庖丁解语-查词句收集背单词造句划词翻译扩展</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://wordcard.app/">https://wordcard.app/</a></td></tr><tr><td><strong>下载</strong></td><td><a href="https://www.appinn.com/word-search-translate/">https://www.appinn.com/word-search-translate/</a></td></tr><tr><td><strong>平台</strong></td><td>浏览器插件</td></tr><tr><td><strong>简介</strong></td><td>一款打通了从单词收集到背单词整个环节的 Chrome 扩展</td></tr><tr><td><strong>功能包括</strong></td><td>网页取词，自动收集例句，根据 cocoa 20000 词汇打标签并保存为词条，单词编辑管理，常用词根查询，分级式背单词单词库导出，支持双击取词，可以为单词打标签、分级，对收集的单词进行分类测验。</td></tr></tbody></table><table><thead><tr><th><strong>名称</strong></th><th>沙拉查词-网页划词翻译</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://saladict.crimx.com/">https://saladict.crimx.com/</a></td></tr><tr><td><strong>下载</strong></td><td><a href="https://saladict.crimx.com/download.html">https://saladict.crimx.com/download.html</a></td></tr><tr><td><strong>平台</strong></td><td>浏览器插件</td></tr><tr><td><strong>简介</strong></td><td>功能一览：多词典支持，英汉、英英、俚语、词源、权威例句、汉语、释义分布图、谷歌翻译全包。支持四种划词方式，支持 iframe 划词。支持 PDF 划词。支持三按 ctrl 快速查词。右键支持谷歌网页翻译，支持更多词典页面。查词面板可钉住可拖动可输入。查词结果支持导出图片。各个词典面板支持个性化调整。点击图标可查看当前页面二维码。</td></tr></tbody></table><table><thead><tr><th><strong>名称</strong></th><th>Burning Vocabulary 【有免费版，付费插件】</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://burningvocabulary.com/">https://burningvocabulary.com/</a></td></tr><tr><td><strong>下载</strong></td><td><a href="https://www.appinn.com/burning-vocabulary/">https://www.appinn.com/burning-vocabulary/</a></td></tr><tr><td><strong>平台</strong></td><td>浏览器插件</td></tr><tr><td><strong>简介</strong></td><td>它可以在 Chrome 系浏览器页面上，标记不认识的单词。之后会生成生词卡片，便于复习，增加词汇量</td></tr></tbody></table><table><thead><tr><th><strong>名称</strong></th><th>Grammarly 【付费插件】</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://app.grammarly.com/">https://app.grammarly.com/</a></td></tr><tr><td><strong>下载</strong></td><td><a href="https://app.grammarly.com/">https://app.grammarly.com/</a></td></tr><tr><td><strong>平台</strong></td><td>浏览器插件</td></tr><tr><td><strong>简介</strong></td><td>它能够检查单词拼写、纠正标点符号、修正语法错误、调整语气以及给出风格建议等；对学术写作来说，Grammarly还可以帮助查重</td></tr></tbody></table><table><thead><tr><th><strong>名称</strong></th><th>DWords</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://github.com/luyuhuang/DWords">https://github.com/luyuhuang/DWords</a></td></tr><tr><td><strong>下载</strong></td><td><a href="https://github.com/luyuhuang/DWords/releases/tag/v0.2.0">https://github.com/luyuhuang/DWords/releases/tag/v0.2.0</a></td></tr><tr><td><strong>平台</strong></td><td>Win MacOS</td></tr><tr><td><strong>简介</strong></td><td>把单词变成屏幕上的弹幕来帮助你记住单词</td></tr></tbody></table><table><thead><tr><th><strong>名称</strong></th><th>Copy Translator-划词翻译软件</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://github.com/zu1k/copy-translator">https://github.com/zu1k/copy-translator</a></td></tr><tr><td><strong>下载</strong></td><td><a href="https://github.com/zu1k/copy-translator/releases">https://github.com/zu1k/copy-translator/releases</a></td></tr><tr><td><strong>平台</strong></td><td>Win Linux</td></tr><tr><td><strong>简介</strong></td><td>简单、轻量、好用的划词翻译软件，利用DeepL翻译，无需注册api token</td></tr></tbody></table><table><thead><tr><th><strong>名称</strong></th><th>火山翻译 - 划词和网页翻译</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://github.com/waynecz/dadda-translate-crx">https://github.com/waynecz/dadda-translate-crx</a></td></tr><tr><td><strong>下载</strong></td><td><a href="https://github.com/waynecz/dadda-translate-crx/releases">https://github.com/waynecz/dadda-translate-crx/releases</a></td></tr><tr><td><strong>平台</strong></td><td>浏览器插件</td></tr><tr><td><strong>简介</strong></td><td>简单、轻量、好用的划词翻译软件，利用DeepL翻译，无需注册api 🐱 比较好看的 Chrome 划词翻译(搜狗)插件，自带生词簿及吐司弹词记忆，可与有道、扇贝单词同步</td></tr></tbody></table><table><thead><tr><th><strong>名称</strong></th><th>ToastFish</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://github.com/Uahh/ToastFish">https://github.com/Uahh/ToastFish</a></td></tr><tr><td><strong>下载</strong></td><td><a href="https://pan.baidu.com/s/1VlnJSSbEgcNErV-gy3um6w">https://pan.baidu.com/s/1VlnJSSbEgcNErV-gy3um6w</a> 提取码：2173</td></tr><tr><td><strong>平台</strong></td><td>Win</td></tr><tr><td><strong>简介</strong></td><td>这是一个利用Windows通知栏背单词的软件，可以让你在上班、上课等恶劣环境下安全隐蔽地背单词</td></tr></tbody></table><table><thead><tr><th><strong>名称</strong></th><th>relingo</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://relingo.net/zh/index">https://relingo.net/zh/index</a></td></tr><tr><td><strong>教程</strong></td><td><a href="https://relingo.net/zh/guide">https://relingo.net/zh/guide</a></td></tr><tr><td><strong>平台</strong></td><td>浏览器插件</td></tr><tr><td><strong>简介</strong></td><td>基于兴趣阅读，不知不觉掌握词汇</td></tr></tbody></table><table><thead><tr><th><strong>名称</strong></th><th>简悦插件 · 划词翻译 生词本 1.0.0</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://relingo.net/zh/index">https://simpread.ksria.cn/plugins/details/ohnTKVHz4a</a></td></tr><tr><td><strong>教程</strong></td><td><a href="https://github.com/Kenshin/simpread/discussions/1592">教程</a> <a href="https://zhuanlan.zhihu.com/p/559387576">知乎</a></td></tr><tr><td><strong>平台</strong></td><td>浏览器插件</td></tr><tr><td><strong>简介</strong></td><td>自动将英文文章里不懂的单词标记出来并辅以中文，通过阅读上下文达到理解的作用。</td></tr><tr><td>同时也可制作自己的生词本或导入已发布的生词本。</td><td></td></tr></tbody></table><table><thead><tr><th><strong>名称</strong></th><th>Crow Translate 【新增：2023-02-11】</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://github.com/crow-translate/crow-translate">https://github.com/crow-translate/crow-translate</a></td></tr><tr><td><strong>平台</strong></td><td>Win、Linux</td></tr><tr><td><strong>简介</strong></td><td>一款简单轻便的翻译器，可让您使用 Google、Yandex Bing、LibreTranslate 和 Lingva 翻译和朗读文本</td></tr></tbody></table><table><thead><tr><th><strong>名称</strong></th><th>YouTube Dubbing 【新增：2023-09-27】</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://www.youtube-dubbing.com/">https://www.youtube-dubbing.com/</a></td></tr><tr><td><strong>平台</strong></td><td>浏览器插件</td></tr><tr><td><strong>简介</strong></td><td>🚀一个帮你把外语视频变成中文视频的神奇插件</td></tr></tbody></table><table><thead><tr><th><strong>名称</strong></th><th>Chrome插件EnglishXYZ 【新增：2023-09-27】</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://englishxyz.com/">https://englishxyz.com/</a></td></tr><tr><td><strong>平台</strong></td><td>浏览器插件</td></tr><tr><td><strong>简介</strong></td><td>将YouTube打造为你的专属英语学习教室，它能够为你的YouTube提供实时双语字幕。点击你不理解的单词，能立即获取发音、解释，还可以收藏，以便随时复习</td></tr></tbody></table><table><thead><tr><th><strong>名称</strong></th><th>MetWord 【新增：2023-09-27】</th></tr></thead><tbody><tr><td><strong>地址</strong></td><td><a href="https://metword.co/">https://metword.co/</a></td></tr><tr><td><strong>平台</strong></td><td>浏览器插件</td></tr><tr><td><strong>简介</strong></td><td>标记你查过的单词，在下次遇见时给出提醒。</td></tr></tbody></table><h1 id="查询工具"><a href="#查询工具" class="headerlink" title="查询工具"></a><a href="#查询工具" title="查询工具"></a><strong>查询工具</strong></h1><blockquote><p><strong>📔 英语词源字典</strong></p><p><strong><a href="https://www.quword.com/ciyuan/s/">https://www.quword.com/ciyuan/s/</a></strong></p></blockquote><blockquote><p><strong>📔 查英语词源的</strong></p><p><strong><a href="https://www.etymonline.com/">https://www.etymonline.com/</a></strong></p></blockquote><blockquote><p><strong>📔 英语词频统计工具，计算字符、单词、句子、行数</strong></p><p><strong><a href="https://textmechanic.com/text-tools/basic-text-tools/count-characters-words-lines/">https://textmechanic.com/text-tools/basic-text-tools/count-characters-words-lines/</a></strong></p></blockquote><blockquote><p><strong>📔 英语的同义词词典，查询同义词，也可以根据描述返回对应的词，加载速度很快</strong></p><p><strong><a href="http://www.onelook.com/thesaurus/">www.onelook.com/thesaurus/</a></strong></p></blockquote><blockquote><p><strong>📔 可以查到一个词的多项意义对应的同义词</strong></p><p><strong><a href="https://www.thesaurus.com/">https://www.thesaurus.com/</a></strong></p></blockquote><blockquote><p><strong>📔 海词词典_在线词典_在线翻译_海量正版权威词典官方网站</strong></p><p><strong><a href="https://dict.cn/">https://dict.cn/</a></strong></p></blockquote><blockquote><p><strong>📔一个适合精学单词，尤其是了解一个单词的多种用法和释义的网站/app</strong></p><p><strong><a href="https://www.vocabulary.com/">https://www.vocabulary.com/</a></strong> ⭐<code>2023-04-22</code></p></blockquote><blockquote><p><strong>📔学英语，背单词，考雅思</strong></p><p><strong><a href="https://ducky.pages.dev/">https://ducky.pages.dev/</a></strong> ⭐<code>2023-09-27</code></p></blockquote><blockquote><p><strong>📔Memword-单词记忆，随时随地学习，记单词</strong></p><p><strong><a href="https://danci.0231019.top/">https://danci.0231019.top/</a></strong> ⭐<code>2023-09-27</code></p></blockquote><blockquote><p><strong>📔查网络梗词和流行语</strong></p><p><strong><a href="https://www.urbandictionary.com/">https://www.urbandictionary.com/</a></strong> ⭐<code>2023-09-27</code></p></blockquote><h1 id="学习工具"><a href="#学习工具" class="headerlink" title="学习工具"></a><a href="#学习工具" title="学习工具"></a>学习工具</h1><blockquote><p><strong>📒免费在线语法检查器来改善单词的使用，任何英语文本的时态和标点符号</strong></p><p><strong><a href="https://writer.com/grammar-checker/">https://writer.com/grammar-checker/</a></strong> ⭐<code>2023-09-27</code></p></blockquote><blockquote><p><strong>📒在线免费AI英语雅思口语分析机器人</strong></p><p><strong><a href="https://app.insta-speak.com/">https://app.insta-speak.com/</a></strong> ⭐<code>2023-09-27</code></p></blockquote><blockquote><p><strong>📒微软的免费在线语法检查器,无需注册登录,可以帮助你修改语法错误</strong></p><p><strong><a href="https://www.microsoft.com/zh-cn/microsoft-365/microsoft-editor/grammar-checker">https://www.microsoft.com/zh-cn/microsoft-365/microsoft-editor/grammar-checker</a></strong> ⭐<code>2023-09-27</code></p></blockquote><blockquote><p><strong>📒雅思作文批改评分工具</strong></p><p><strong><a href="https://www.ielts9.me/">https://www.ielts9.me/</a></strong> ⭐<code>2023-09-27</code></p></blockquote><blockquote><p><strong>📒由剑桥大学开发的免费学习英语工具，练习书面英语还能自动反馈改进建议，不需要注册，适用于任何人</strong></p><p><strong><a href="https://writeandimprove.com/workbooks#/wi-workbooks/7485eb41-a047-4d23-ae25-5afb7387eba9">https://writeandimprove.com/workbooks#/wi-workbooks/7485eb41-a047-4d23-ae25-5afb7387eba9</a></strong> ⭐<code>2023-09-27</code></p></blockquote><blockquote><p><strong>📒2023，我私藏的英语学习工具</strong></p><p><strong><a href="https://sspai.com/post/80086">https://sspai.com/post/80086</a></strong> ⭐<code>2023-09-27</code></p></blockquote><blockquote><p><strong>📒Speak&amp;Improve剑桥大学的AI机器人提高英语听力和口语</strong></p><p><strong><a href="https://speakandimprove.com/">https://speakandimprove.com/</a></strong> ⭐<code>2023-09-27</code></p></blockquote><blockquote><p><strong>📒一个只会用1000个单词讲话的机器人：1000 Words-SimpleBot</strong></p><p><strong><a href="https://app.myshell.ai/zh/bot/ec703952118841268b8b5e4005466308">https://app.myshell.ai/zh/bot/ec703952118841268b8b5e4005466308</a></strong> ⭐<code>2023-09-27</code></p></blockquote><h1 id="语法词汇"><a href="#语法词汇" class="headerlink" title="语法词汇"></a><a href="#语法词汇" title="语法词汇"></a><strong>语法词汇</strong></h1><blockquote><p><strong>📕 从0开始学习英语语法</strong></p><p><strong><a href="https://hzpt-inet-club.github.io/english-note/">https://hzpt-inet-club.github.io/english-note/</a></strong></p><p><strong><a href="https://github.com/hzpt-inet-club/english-note">https://github.com/hzpt-inet-club/english-note</a></strong></p></blockquote><blockquote><p><strong>📕 程序员工作中常见的英语词汇</strong></p><p><strong><a href="https://learn-english.dev/">https://learn-english.dev/</a></strong></p><p><strong><a href="https://github.com/Wei-Xia/most-frequent-technology-english-words">https://github.com/Wei-Xia/most-frequent-technology-english-words</a></strong></p></blockquote><blockquote><p><strong>📕 新概念英语笔记,英语学习资料</strong></p><p><strong><a href="https://github.com/protogenesis/NewConceptEnglish">https://github.com/protogenesis/NewConceptEnglish</a></strong></p></blockquote><blockquote><p><strong>📕 排版好看并且内容准确的老友记剧本 PDF</strong></p><p><strong><a href="https://fangj.github.io/friends/">https://fangj.github.io/friends/</a></strong></p><p><strong><a href="https://github.com/cj1128/learn-english-with-friends">https://github.com/cj1128/learn-english-with-friends</a></strong></p></blockquote><blockquote><p><strong>📕 一份英文-&gt;中文字典的双解词典数据库</strong></p><p><strong><a href="https://github.com/skywind3000/ECDICT">https://github.com/skywind3000/ECDICT</a></strong></p></blockquote><blockquote><p><strong>📕 在线英语句子语法分析</strong></p><p><strong><a href="http://enpuz.com/">http://enpuz.com/</a></strong></p></blockquote><blockquote><p><strong>📕 中国程序员容易发音错误的单词</strong></p><p><strong><a href="https://github.com/shimohq/chinese-programmer-wrong-pronunciation">https://github.com/shimohq/chinese-programmer-wrong-pronunciation</a></strong></p></blockquote><blockquote><p><strong>📕 解谜英语语法</strong></p><p><strong><a href="http://www.yinwang.org/blog-cn/2018/11/23/grammar">http://www.yinwang.org/blog-cn/2018/11/23/grammar</a></strong></p></blockquote><blockquote><p><strong>📕 计算机专业术语中英文对照</strong></p><p><strong><a href="https://github.com/EarsEyesMouth/computerese-cross-references">https://github.com/EarsEyesMouth/computerese-cross-references</a></strong></p></blockquote><blockquote><p><strong>📕 英语语法网-全面详细介绍英语词法与句法以及语法学习的重点、难点和考点</strong></p><p><strong><a href="http://www.yygrammar.com/">http://www.yygrammar.com/</a></strong></p></blockquote><blockquote><p><strong>📕 柯帕斯英语网，主打英语语法</strong></p><p><strong><a href="https://www.cpsenglish.com/">https://www.cpsenglish.com/</a></strong></p></blockquote><blockquote><p><strong>📕 英语单词词库</strong> ⭐<code>2023-03-06</code></p><p><strong><a href="https://github.com/kajweb/dict">https://github.com/kajweb/dict</a></strong></p></blockquote><blockquote><p><strong>📕 各种免费词典:一个公益性词典网站,中文词典，英语词典，百科词典等各种</strong>⭐<code>2023-03-06</code></p><p><strong><a href="https://downloads.freemdict.com/#%E4%B8%AD%E6%96%87">https://downloads.freemdict.com/#%E4%B8%AD%E6%96%87</a></strong></p></blockquote><blockquote><p><strong>📕 Vocabulary适合精学单词，尤其是了解一个单词的多种用法和释义的网站/app</strong> ⭐<code>2023-03-06</code></p><p><strong><a href="https://www.vocabulary.com/">https://www.vocabulary.com/</a></strong></p></blockquote><blockquote><p><strong>📕 COCA 20000词表 (Anki APKG格式)</strong> ⭐<code>2023-03-06</code></p><p><strong><a href="https://github.com/ninja33/ninja33.github.io/blob/master/_posts/2017-03-06-anki-coca-20000-apkg.md">https://github.com/ninja33/ninja33.github.io/blob/master/_posts/2017-03-06-anki-coca-20000-apkg.md</a></strong></p></blockquote><blockquote><p><strong>📕 英语书籍词典Search FreeMdict Files</strong> ⭐<code>2023-04-22</code></p><p><strong><a href="https://search.freemdict.com/">https://search.freemdict.com/</a></strong></p></blockquote><blockquote><p><strong>📕 COCA 词汇语料库</strong> ⭐<code>2023-04-22</code></p><p><strong><a href="https://www.english-corpora.org/">https://www.english-corpora.org/</a></strong></p></blockquote><blockquote><p><strong>📕 从词性开始 | 英语语法</strong> ⭐<code>2023-04-22</code></p><p><strong><a href="https://hzpt-inet-club.github.io/english-note/guide/grammar.html">https://hzpt-inet-club.github.io/english-note/guide/grammar.html</a></strong></p></blockquote><blockquote><p><strong>📕1000个最常用的英语单词的列表</strong> ⭐<code>2023-04-22</code></p><p><strong><a href="https://gonaturalenglish.com/1000-most-common-words-in-the-english-language/">https://gonaturalenglish.com/1000-most-common-words-in-the-english-language/</a></strong></p></blockquote><blockquote><p><strong>📕 单词词汇</strong> ⭐<code>2023-04-22</code></p><p><strong><a href="https://downloads.freemdict.com/#%E4%B8%AD%E6%96%87">https://downloads.freemdict.com/#%E4%B8%AD%E6%96%87</a></strong></p></blockquote><blockquote><p><strong>📕 常用英语词汇表</strong> ⭐<code>2023-09-27</code></p><p><strong><a href="https://github.com/jnoodle/English-Vocabulary-Word-List">https://github.com/jnoodle/English-Vocabulary-Word-List</a></strong></p></blockquote><h1 id="学习指南"><a href="#学习指南" class="headerlink" title="学习指南"></a><a href="#学习指南" title="学习指南"></a><strong>学习指南</strong></h1><blockquote><p><strong>📗 专为程序员编写的英语学习指南</strong></p><p><strong><a href="https://a-programmers-guide-to-english.harryyu.me/">https://a-programmers-guide-to-english.harryyu.me/</a></strong></p><p><strong><a href="https://github.com/yujiangshui/A-Programmers-Guide-to-English">https://github.com/yujiangshui/A-Programmers-Guide-to-English</a></strong></p></blockquote><blockquote><p><strong>📗 如何学好英语？</strong></p><p><strong><a href="https://jacksonwuu.github.io/blog/thinking/%E5%A6%82%E4%BD%95%E5%AD%A6%E5%A5%BD%E8%8B%B1%E8%AF%AD%EF%BC%9F/">https://jacksonwuu.github.io/blog/thinking/%E5%A6%82%E4%BD%95%E5%AD%A6%E5%A5%BD%E8%8B%B1%E8%AF%AD%EF%BC%9F/</a></strong></p></blockquote><blockquote><p><strong>📗 可能是让你受益匪浅的英语进阶指南</strong></p><p><strong><a href="https://byoungd.gitbook.io/english-level-up-tips/">https://byoungd.gitbook.io/english-level-up-tips/</a></strong></p></blockquote><blockquote><p><strong>📗 我是如何从哑巴英语到无障碍英文工作沟通的</strong></p><p><strong><a href="https://www.kenshinji.me/wo-shi-ru-he-cong-ya-ba-ying-yu-dao-wu-zhang-ai-ying-wen-gong-zuo-gou-tong-de/">https://www.kenshinji.me/wo-shi-ru-he-cong-ya-ba-ying-yu-dao-wu-zhang-ai-ying-wen-gong-zuo-gou-tong-de/</a></strong></p></blockquote><blockquote><p><strong>📗 背单词计划表</strong></p><p><strong><a href="https://exam4.us/">https://exam4.us/</a></strong></p></blockquote><blockquote><p><strong>📗 人人都能用英语</strong></p><p><strong><a href="https://github.com/xiaolai/everyone-can-use-english">https://github.com/xiaolai/everyone-can-use-english</a></strong></p></blockquote><blockquote><p><strong>📗 可能是让你受益匪浅的英语进阶指南</strong></p><p><strong><a href="https://github.com/byoungd/English-level-up-tips">https://github.com/byoungd/English-level-up-tips</a></strong></p></blockquote><blockquote><p><strong>📗 颠覆你英文阅读、单词学习的工具方法</strong></p><p><strong><a href="https://zhuanlan.zhihu.com/p/136959984">https://zhuanlan.zhihu.com/p/136959984</a></strong></p></blockquote><blockquote><p><strong>📗 程序员英语学习指南</strong></p><p><strong><a href="https://github.com/terrytyli/terrys-english-learning-guide">https://github.com/terrytyli/terrys-english-learning-guide</a></strong></p></blockquote><blockquote><p><strong>📗 English-introduction 英语自学指南 ⭐<code>11-22</code></strong><br><strong><a href="https://bewaters.me/limxtop/2021/08/18/English-introduction/">https://bewaters.me/limxtop/2021/08/18/English-introduction/</a></strong></p></blockquote><blockquote><p><strong>📗 【转】我是如何学英文的，包含资料链接 ⭐<code>23-01-06</code></strong><br><strong><a href="https://twitter.com/LauraIsland0/status/1585840029426909184">https://twitter.com/LauraIsland0/status/1585840029426909184</a></strong></p></blockquote><blockquote><p><strong>📗 成年人英语速成指南（附资源及工具） ⭐<code>23-01-29</code></strong><br><strong><a href="https://mirror.xyz/abetterweb3.eth/mn5hFTBz3PzvL-o8BtkDd12TPlrGNPZcasuTg2lpeUg">https://mirror.xyz/abetterweb3.eth/mn5hFTBz3PzvL-o8BtkDd12TPlrGNPZcasuTg2lpeUg</a></strong></p></blockquote><blockquote><p><strong>📗 COCA词频表使用 ⭐<code>23-03-02</code></strong><br><strong><a href="https://juniway.github.io/English/english-process-coca-list/">https://juniway.github.io/English/english-process-coca-list/</a></strong></p></blockquote><blockquote><p><strong>📗 如何提高英语水平 ⭐<code>23-04-22</code></strong><br><strong><a href="https://linghao.io/posts/improve-english#Popover19-toggle">https://linghao.io/posts/improve-english#Popover19-toggle</a></strong></p></blockquote><blockquote><p><strong>📗 可能是让你受益匪浅的英语进阶指南 ⭐<code>23-04-22</code></strong><br><strong><a href="https://github.com/byoungd/English-level-up-tips">https://github.com/byoungd/English-level-up-tips</a></strong></p></blockquote><blockquote><p><strong>📗 成年人英语速成指南（附资源及工具） ⭐<code>23-09-27</code></strong><br><strong><a href="https://abetterweb3.notion.site/a769cd3afb7d4bf19727391df27d1cdb">https://abetterweb3.notion.site/a769cd3afb7d4bf19727391df27d1cdb</a></strong></p></blockquote><blockquote><p><strong>📗 离谱的英语进阶指南 ⭐<code>23-09-27</code></strong><br><strong><a href="https://byoungd.github.io/English-level-up-tips/#/">https://byoungd.github.io/English-level-up-tips/#/</a></strong></p></blockquote><blockquote><p><strong>📗 如何毫不费力学英语【零基础学英语课程】 ⭐<code>23-09-27</code></strong><br><strong><a href="https://space.bilibili.com/160507280/channel/collectiondetail?sid=48449">https://space.bilibili.com/160507280/channel/collectiondetail?sid=48449</a></strong></p></blockquote><blockquote><p><strong>📗 How I learn English? 我如何学习英语 ? ⭐<code>23-09-27</code></strong><br><strong><a href="https://github.com/dekuofa1995/MyNotes/blob/main/20230425T165757--how-i-learn-english__english_learning.org">https://github.com/dekuofa1995/MyNotes/blob/main/20230425T165757–how-i-learn-english__english_learning.org</a></strong></p></blockquote><h1 id="英语测试"><a href="#英语测试" class="headerlink" title="英语测试"></a><a href="#英语测试" title="英语测试"></a><strong>英语测试</strong></h1><blockquote><p><strong>📙 英语数字听力练习</strong></p><p><strong><a href="https://english-number.com/number-test">https://english-number.com/number-test</a></strong></p></blockquote><blockquote><p><strong>📙 英语听力精听、背单词</strong></p><p><strong><a href="https://www.youzack.com/">https://www.youzack.com/</a></strong></p></blockquote><blockquote><p><strong>📙 英语真题在线</strong></p><p><strong><a href="https://zhenti.burningvocabulary.com/">https://zhenti.burningvocabulary.com/</a></strong></p></blockquote><blockquote><p><strong>📙 在线英语发音纠正</strong></p><p><strong><a href="https://github.com/songquanpeng/pronunciation-corrector">https://github.com/songquanpeng/pronunciation-corrector</a></strong></p><p><strong><a href="https://corrector.justsong.cn/">https://corrector.justsong.cn/</a></strong></p></blockquote><blockquote><p><strong>📙 测试你的英语词汇量</strong></p><p><strong><a href="https://preply.com/en/learn/english/test-your-vocab">https://preply.com/en/learn/english/test-your-vocab</a></strong></p></blockquote><blockquote><p><strong>📙 测试英语词汇量,此网站也可测试中文，其他语言，游戏，影视等词汇量</strong></p><p><strong><a href="https://www.arealme.com/vocabulary-size-test/en/">https://www.arealme.com/vocabulary-size-test/en/</a></strong></p></blockquote><blockquote><p><strong>📙 雅思真题免费在线测试及答案</strong></p><p><strong><a href="https://ieltsonlinetests.com/zh-hans/ielts-exam-library">https://ieltsonlinetests.com/zh-hans/ielts-exam-library</a></strong></p></blockquote><blockquote><p><strong>📙 雅思官方推出：雅思机考模拟系统 在线模拟雅思真题考试</strong></p><p><strong><a href="https://cdielts.gelielts.com/">https://cdielts.gelielts.com/</a></strong></p></blockquote><blockquote><p><strong>📙 在线测试：你的英语词汇量有多少</strong></p><p><strong><a href="https://www.arealme.com/vocabulary-size-test/en/">https://www.arealme.com/vocabulary-size-test/en/</a></strong></p></blockquote><blockquote><p><strong>📙 英语测试：包括KET、PET、FCE、雅思、TOEIC®和TOEFL iBT™</strong></p><p><strong><a href="https://test-english.com/">https://test-english.com/</a></strong></p></blockquote><blockquote><p><strong>📙 英语级别测试</strong></p><p><strong><a href="https://www.englishtag.com/tests/intro.asp">https://www.englishtag.com/tests/intro.asp</a></strong></p></blockquote><blockquote><p><strong>📙 免费测试您的英语、法语、德语和西班牙语水平</strong></p><p><strong><a href="https://www.languagelevel.com/index.php">https://www.languagelevel.com/index.php</a></strong></p></blockquote><blockquote><p><strong>📙 不同水平都能用的听力学习网站</strong></p><p><strong><a href="https://www.elllo.org/index.htm">https://www.elllo.org/index.htm</a> ⭐<code>23-04-22</code></strong></p></blockquote><blockquote><p><strong>📙 Atomic Learning 英语听力练习</strong></p><p><strong><a href="https://atomiclearning.app/">https://atomiclearning.app/</a> ⭐<code>23-09-27</code></strong></p></blockquote><blockquote><p><strong>📙 DailyDictation 通过听写练习英语</strong></p><p><strong><a href="https://dailydictation.com/">https://dailydictation.com/</a> ⭐<code>23-09-27</code></strong></p></blockquote><h1 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a><a href="#学习网站" title="学习网站"></a><strong>学习网站</strong></h1><blockquote><p><strong>📘 给力英语网</strong></p><p><strong><a href="http://www.geilien.cn/">http://www.geilien.cn/</a></strong></p><p><strong><a href="http://www.geilien.cn/old.asp">http://www.geilien.cn/old.asp</a></strong></p></blockquote><blockquote><p><strong>📘 交互式英语单词学习网站</strong></p><p><strong><a href="https://visuwords.com/">https://visuwords.com/</a></strong></p></blockquote><blockquote><p><strong>📘 英语词源字典</strong></p><p><strong><a href="https://www.quword.com/ciyuan/s/">https://www.quword.com/ciyuan/s/</a></strong></p></blockquote><blockquote><p><strong>📘 英语学习导航</strong></p><p><strong><a href="https://www.up-6.com/">https://www.up-6.com/</a></strong></p></blockquote><blockquote><p><strong>📘 目前在线的最大发音指南</strong></p><p><strong><a href="https://forvo.com/">https://forvo.com/</a></strong></p></blockquote><blockquote><p><strong>📘 在线英语发音纠正</strong></p><p><strong><a href="https://github.com/songquanpeng/pronunciation-corrector">https://github.com/songquanpeng/pronunciation-corrector</a></strong></p><p><strong><a href="https://corrector.justsong.cn/">https://corrector.justsong.cn/</a></strong></p></blockquote><blockquote><p><strong>📘 从 YouTube 搜索母语发音者，练习口语，支持英文、中文、手语在内的 18 种语言</strong></p><p><strong><a href="https://youglish.com/">https://youglish.com/</a></strong></p></blockquote><blockquote><p><strong>📘 台词英语学习网站 通过从各种影视，动漫，儿童英语教学片等中，截成一个个小片段，来学习英语听力</strong></p><p><strong><a href="https://www.voscreen.com/">https://www.voscreen.com/</a></strong></p></blockquote><blockquote><p><strong>📘 查英语词源的</strong></p><p><strong><a href="https://www.etymonline.com/">https://www.etymonline.com/</a></strong></p></blockquote><blockquote><p><strong>📘 排版好看并且内容准确的老友记剧本 PDF，用于学习英语</strong></p><p><strong><a href="https://github.com/cj1128/learn-english-with-friends">https://github.com/cj1128/learn-english-with-friends</a></strong></p></blockquote><blockquote><p><strong>📘 练习和纠正英语发音</strong></p><p><strong><a href="https://elsaspeak.com/en/">https://elsaspeak.com/en/</a></strong></p></blockquote><blockquote><p><strong>📘 作者在阅读论文的过程中收集整理的一些好的英语用法</strong></p><p><strong><a href="https://github.com/yzy1996/English-Writing">https://github.com/yzy1996/English-Writing</a></strong></p></blockquote><blockquote><p><strong>📘 EnglishClub英语学习网站，语法，词汇，发音，听力，口语等</strong></p><p><strong><a href="https://www.englishclub.com/">https://www.englishclub.com/</a></strong></p></blockquote><blockquote><p><strong>📘 在线英语听力练习网站</strong></p><p><strong><a href="https://www.elllo.org/index.htm">https://www.elllo.org/index.htm</a></strong></p></blockquote><blockquote><p><strong>📘 看漫画学英语</strong></p><p><strong><a href="https://mangapanda.onl/search">https://mangapanda.onl/search</a></strong></p></blockquote><blockquote><p><strong>📘 可可英语 - 双语新闻|中英双语新闻|中英文对照新闻</strong></p><p><strong><a href="http://www.kekenet.com/read/news/">http://www.kekenet.com/read/news/</a></strong></p></blockquote><blockquote><p><strong>📘 语言学习论坛，包括多种语言</strong></p><p><strong><a href="https://forum.wordreference.com/forums/english-only.6/">https://forum.wordreference.com/forums/english-only.6/</a></strong></p></blockquote><blockquote><p><strong>📘 英语固定搭配查询，适合有一定英语基础的同学使用，因为是全英文的</strong></p><p><strong><a href="https://idioms.thefreedictionary.com/">https://idioms.thefreedictionary.com/</a></strong></p></blockquote><blockquote><p><strong>📘 可查询英语常见问题，语法类，单词类都可</strong></p><p><strong><a href="https://www.hjenglish.com/">https://www.hjenglish.com/</a></strong></p></blockquote><blockquote><p><strong>📘 英语语法网-全面详细介绍英语词法与句法以及语法学习的重点、难点和考点</strong></p><p><strong><a href="http://www.yygrammar.com/">http://www.yygrammar.com/</a></strong></p></blockquote><blockquote><p><strong>📘 柯帕斯英语网，主打英语语法</strong></p><p><strong><a href="https://www.cpsenglish.com/">https://www.cpsenglish.com/</a></strong></p></blockquote><blockquote><p><strong>📘 一个提高英语口语和听力网站（网络需要国际网络）</strong></p><p><strong><a href="https://www.voicetube.com/">https://www.voicetube.com/</a></strong></p></blockquote><blockquote><p><strong>📘 ELLLO 免费的英语听力学习网站，每篇内容都提供了文本、词汇、练习</strong></p><p><strong><a href="https://www.elllo.org/">https://www.elllo.org/</a></strong></p></blockquote><blockquote><p><strong>📘 学习一门语言的前1000个单词，目前只能通过英语学习法语</strong></p><p><strong><a href="https://www.lumalanguage.com/">https://www.lumalanguage.com/</a></strong></p></blockquote><blockquote><p><strong>📘 用来练习英语听力，里面还有对应的口语练习材料</strong></p><p><strong><a href="https://www.esl-lab.com/">https://www.esl-lab.com/</a></strong></p></blockquote><blockquote><p><strong>📘 学习者的论坛，涵盖英语词典、汉语词典、其他语种等词典</strong></p><p><strong><a href="https://forum.freemdict.com/c/13-category/13">https://forum.freemdict.com/c/13-category/13</a> ⭐<code>12-13</code></strong></p></blockquote><blockquote><p><strong>📘 英语词典、汉语词典、其他语种等词典搜索下载</strong></p><p><strong><a href="https://search.freemdict.com/">https://search.freemdict.com/</a> ⭐<code>12-13</code></strong></p></blockquote><blockquote><p><strong>📘 ESLBUZZ免费的英语课程【英文】</strong></p><p><strong><a href="https://www.eslbuzz.com/">https://www.eslbuzz.com/</a> ⭐<code>23-01-06</code></strong></p></blockquote><blockquote><p><strong>📘 儿童英语学习资料网站</strong></p><p><strong><a href="https://www.nortechplus.com/">https://www.nortechplus.com/</a></strong> ⭐<code>23-04-22</code></p></blockquote><blockquote><p><strong>📘 中国高校外语慕课平台（UMOOCs）</strong></p><p><strong><a href="https://umoocs.unipus.cn/">https://umoocs.unipus.cn/</a></strong> ⭐<code>23-04-22</code></p></blockquote><blockquote><p><strong>📘 搜寻英文短语的发音，视频片段主要截取自经典电影和美剧</strong></p><p><strong><a href="https://www.playphrase.me/#/search">https://www.playphrase.me/#/search</a></strong> ⭐<code>23-04-22</code></p></blockquote><blockquote><p><strong>📘 英语学习 | 数字生活指南导航</strong></p><p><strong><a href="https://nav.guidebook.top/english">https://nav.guidebook.top/english</a></strong> ⭐<code>23-04-22</code></p></blockquote><blockquote><p><strong>📘 英文少儿有声书网站，经典英文读物都有（音频+文本）</strong></p><p><strong><a href="https://www.storynory.com/">https://www.storynory.com/</a></strong> ⭐<code>23-04-22</code></p></blockquote><blockquote><p><strong>📘 查网络梗词和流行语</strong></p><p><strong><a href="https://www.urbandictionary.com/">https://www.urbandictionary.com/</a></strong> ⭐<code>23-09-27</code></p></blockquote><blockquote><p><strong>📘 形式中文，用英文语法将中文形式化并限定于阅读和写作的方式称为形式中文</strong></p><p><strong><a href="https://ishare20.github.io/formalizedChinese/docs/intro">https://ishare20.github.io/formalizedChinese/docs/intro</a></strong> ⭐<code>23-09-27</code></p></blockquote><blockquote><p><strong>📘 外语教材下载</strong></p><p><strong><a href="https://languagelearning.site/">https://languagelearning.site/</a></strong> ⭐<code>23-09-27</code></p></blockquote><blockquote><p><strong>📘 沉浸语言学习</strong></p><p><strong><a href="https://jiangzilong.notion.site/09128b7095974b188c9640d5333917b5">https://jiangzilong.notion.site/09128b7095974b188c9640d5333917b5</a></strong> ⭐<code>23-09-27</code></p></blockquote><blockquote><p><strong>📘 使用 AI 备考雅思口语考试</strong></p><p><strong><a href="https://learningprompt.wiki/zh-Hans/docs/ai-101/best-practice/learning/learning-IELTS">https://learningprompt.wiki/zh-Hans/docs/ai-101/best-practice/learning/learning-IELTS</a></strong> ⭐<code>23-09-27</code></p></blockquote><blockquote><p><strong>📘 免费双语读物</strong></p><p><strong><a href="http://zh.bilinguis.com/book/">http://zh.bilinguis.com/book/</a></strong> ⭐<code>23-09-27</code></p></blockquote><blockquote><p><strong>📘 免费在线课程 | 50种语言</strong></p><p><strong><a href="https://www.loecsen.com/zh">https://www.loecsen.com/zh</a></strong> ⭐<code>23-09-27</code></p></blockquote><blockquote><p><strong>📘 「OGDEN’s BASIC ENGLISH」用于简化你的英语学习和日常使用</strong></p><p><strong><a href="http://ogden.basic-english.org/">http://ogden.basic-english.org/</a></strong> ⭐<code>23-09-27</code></p></blockquote><blockquote><p><strong>📘 巴别英语 - 英语听力口语在线学习</strong></p><p><strong><a href="https://www.babelabc.com/">https://www.babelabc.com/</a></strong> ⭐<code>23-09-27</code></p></blockquote><h1 id="题库真题"><a href="#题库真题" class="headerlink" title="题库真题"></a><a href="#题库真题" title="题库真题"></a><strong>题库真题</strong></h1><blockquote><p><strong>📒 给力英语网真题试卷</strong></p><p><strong><a href="http://www.geilien.cn/">http://www.geilien.cn/</a></strong></p></blockquote><blockquote><p><strong>📒 大学英语题库查询</strong></p><p><strong><a href="https://shitidaquan.com/c/zk810avl">https://shitidaquan.com/c/zk810avl</a></strong></p></blockquote><blockquote><p><strong>📒 中国重要政治词汇对外翻译标准化专题库</strong></p><p><strong><a href="http://210.72.20.108/app/special/index.jsp">http://210.72.20.108/app/special/index.jsp</a></strong></p></blockquote><blockquote><p><strong>📒 英语真题在线</strong></p><p><strong><a href="https://zhenti.burningvocabulary.com/">https://zhenti.burningvocabulary.com/</a></strong></p></blockquote><blockquote><p><strong>📒 雅思真题免费在线测试及答案</strong></p><p><strong><a href="https://ieltsonlinetests.com/zh-hans/ielts-exam-library#all-test">https://ieltsonlinetests.com/zh-hans/ielts-exam-library#all-test</a></strong></p></blockquote><h1 id="经验分享"><a href="#经验分享" class="headerlink" title="经验分享"></a><a href="#经验分享" title="经验分享"></a>经验分享</h1><h2 id="篇1"><a href="#篇1" class="headerlink" title="篇1"></a><a href="#篇1" title="篇1"></a>篇1</h2><p>新增：2023-02-22</p><p>🔴 <strong>内容转自： <em>[404 [[ ]] KIDS SEE GHOSTS]</em></strong> 📝<a href="https://t.me/isaiahsystem/587">文章地址</a> <strong>丨</strong> 🦸‍♂️<a href="https://kidsseeghosts.art/">博客</a></p><p>语言学习最主要的是情境和惯习（惯习，布迪厄语），我认为这是很重要的，有情境（语境），也有对情境形成不假思索的反应。这可以很好概括语言学习，语言也自是如此。</p><p>以前我陆续分享了不少语言学习相关，工具、教程、方案。</p><p><strong>工具：</strong></p><p><a href="https://t.me/isaiahsystem/49">Lingq</a>：这是我很喜欢的，用来学除英语外的其它语言很有效。精熟几十种语言的 <a href="https://www.youtube.com/c/Thelinguist">Steve Kaufmann</a> 是联合创始人。对文本、单词、短语取词制卡，真正利用 context 语境优势渐进沉浸学习。</p><p><a href="https://t.me/isaiahsystem/163">Burning Vocabulary</a>：网页标注单词，全网高亮，间隔重复记忆。这个以前在用，目前感觉不必要，已经关了。同类型插件 <a href="https://t.me/isaiahsystem/230">Relingo</a>，还免费，和之前提到的 Clearly 阅读器同开发。</p><p><a href="https://t.me/isaiahsystem/184">YouTube 双字幕</a>：用于油管视频学习，也是很有用的。</p><p><a href="https://saladict.crimx.com/">沙拉查词</a>：目前返璞，也主要用这个划词翻译插件。</p><p><a href="https://mobile.twitter.com/iwilldev">雪球英语 APP</a>：这个确实很多人推荐，可以试试。我不常用 APP.</p><p><strong>Space Repetition System（ SRS 间隔重复系统）：</strong></p><p>提到语言学习，自然不能忽视渐进记忆和算法。各种花哨 APP 就不推荐了。</p><p><a href="https://apps.ankiweb.net/">Anki</a>：承载 SM-2 算法的闪卡记忆工具，多平台，可以学习单词。现在很多软件，尤其笔记软件也有记忆功能，比如 <a href="https://www.remnote.com/">Remnote</a> 还有个关于 SRS 的频道推荐：<a href="https://t.me/anki_keeper">@anki_keeper</a></p><p><a href="https://www.yuque.com/supermemo/wiki/help">Supermemo</a>：这个不多介绍了，最优秀的算法，摘录、排期、优先级都非常不错的。适合文章处理，如果记单词，建议录入整个句子，语境。Supermemo 文档也是人生指南宝藏。</p><p><strong>教程：</strong></p><p><a href="https://github.com/byoungd/English-level-up-tips">English-level-up-tips</a>：Github 一个英语进阶库，很不错。</p><p><a href="https://medium.com/learning-languages/dr-stephen-krashen-on-language-learning-and-acquisition-notes-47b6757ebc01">Dr. Stephen Krashen on Language Learning</a>：之前分享过的，剖析语言大师克拉申的经验。</p><p><a href="https://t.me/isaiahsystem/90">How I Learned French in 12 Months</a>：也是分享过的 HN 上一个法语学习经验贴。</p><p><a href="https://t.me/isaiahsystem/51">Don’t learn languages—acquire them</a>：也是分享过的，一个生产力玩家语言学习建议。</p><p><a href="https://linghao.io/posts/improve-english#Popover19-toggle">如何提高英语水平</a>：之前发现一个频道主的内容，分享。</p><p><strong>导航：</strong></p><p>第一个不错，英语学习导航（<em>后面可看看</em>）<br><a href="https://www.up-6.com/">https://www.up-6.com/</a></p><p><a href="http://www.yywz123.com/">http://www.yywz123.com/</a><br><a href="http://www.dioenglish.com/diolinks/">http://www.dioenglish.com/diolinks/</a><br><a href="https://www.zueiai.com/yingyu/">https://www.zueiai.com/yingyu/</a><br><a href="http://www.114222.com/lu/lu56.html">http://www.114222.com/lu/lu56.html</a><br><a href="http://www.63243.com/qita/yingyu/">http://www.63243.com/qita/yingyu/</a><br><a href="https://www.8769.com/list/5/87/">https://www.8769.com/list/5/87/</a></p><p>之前还分享了<a href="https://t.me/isaiahsystem/512">英文写作相关资源</a> //<strong>注：</strong><a href="https://eureka.mba/posts/3f43dc72.html#%E7%AF%872">篇2</a> //，编辑、修改等。</p><p>今天分享的，就我目前的一些经验。语言学习相通。当然还有某些网站或者语言学习小玩具，那些就看自己喜好，也不推荐了。如果语言学习非新手，就可以直接摄入内容，浸淫其中。如果是新手，这些工具辅助使用，结合油管看一下基本教学，都可（尤其学新的外语）。这个持续更新。</p><hr><h2 id="篇2"><a href="#篇2" class="headerlink" title="篇2"></a><a href="#篇2" title="篇2"></a>篇2</h2><p>新增：2023-02-22</p><p>🔴 <strong>内容转自： <em>[404 [[ ]] KIDS SEE GHOSTS]</em></strong> 📝<a href="https://t.me/isaiahsystem/512">文章地址</a> <strong>丨</strong> 🦸‍♂️<a href="https://kidsseeghosts.art/">博客</a></p><p>梳理了一下英文书写、编辑和修改的相关工具，属实吃饭家伙了。</p><p><strong>第一部分：</strong>语法错误检测、同类句转换 Rephraser 以及编辑相关，可以整体把握文本。</p><ul><li><a href="https://app.grammarly.com/ddocs/1779550646">Grammarly</a></li><li><a href="https://hemingwayapp.com/">Hemingway</a></li><li><a href="https://telegra.ph/">Telegraph</a></li><li><a href="https://quillbot.com/">QuillBot</a></li><li><a href="https://www.phrasebank.manchester.ac.uk/">Phrasekbank</a></li><li><a href="https://www.gingersoftware.com/products/sentence-rephraser">Rephraser</a></li><li><a href="https://www.deepl.com/translator">DeepL</a></li><li><a href="https://wordvice.cn/citation-generator/">参考文献</a></li></ul><p><strong>第二部分：</strong>释义溯源相关，俚语辞典以及 Linggle 相关的平行文本搜索，可以把握单词用法。</p><ul><li><a href="https://www.google.com/search?q=define:">Define</a></li><li><a href="https://www.linguee.com/">Linguee</a></li><li><a href="https://www.urbandictionary.com/">UrbanDic</a></li><li><a href="https://www.etymonline.com/">Etymonline</a></li><li><a href="https://www.thefreedictionary.com/">FreeDic</a></li><li><a href="http://onlineslangdictionary.com/">SlangDic</a></li><li><a href="https://www.linggle.com/">Linggle</a></li><li><a href="https://sentencestack.com/">SentenceStack</a></li></ul><p><strong>第三部分：</strong>语法增强和替换，同义词、反义词以及韵律 Rhyme 等词汇的处理，可以让文本增色不少。</p><ul><li><a href="https://www.powerthesaurus.org/">Thesaurus</a></li><li><a href="https://www.wordhippo.com/">WordHippo</a></li><li><a href="https://www.synonym.com/synonyms/love">Synonym</a></li><li><a href="https://www.allacronyms.com/">AbbreviationsDic</a></li><li><a href="https://www.abbreviations.com/">Abbreviations</a></li><li><a href="https://www.rhymezone.com/">RhymeZone</a></li><li><a href="https://www.rhymer.com/">Rhyme</a></li></ul><hr><h2 id="篇3"><a href="#篇3" class="headerlink" title="篇3"></a><a href="#篇3" title="篇3"></a>篇3</h2><p>新增：2023-09-27</p><p><strong>✖️【<a href="https://twitter.com/vista8/status/1686204015174955008?s=20">转X</a>】学英语缺阅读素材？</strong></p><p>往往太长的看不下去，太短的趣味性不足。</p><p>最近发现两个网站，都是专业作家和写手UGC的100字英文短篇故事，每篇又短又有趣。</p><p>100字故事：<br><a href="https://100wordstory.org/">https://100wordstory.org</a></p><p>星期五快闪小说的100字故事：<br><a href="https://fridayflashfiction.com/100-word-stories">https://fridayflashfiction.com/100-word-stories</a></p><p>配合 <a href="https://immersivetranslate.com/">沉浸式翻译插件</a> 或 <a href="https://www.trancy.org/zh-cn">Trancy</a> 工具，一起读起来。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/lin64850/tuchuang/master/img/202311/photo_2023-09-27_13-22-07.jpg" alt=""></p><h2 id="篇4"><a href="#篇4" class="headerlink" title="篇4"></a><a href="#篇4" title="篇4"></a>篇4</h2><p>新增：2023-09-27</p><p><strong>【罗肖尼】如何永远学会一个单词？</strong></p><p><a href="https://www.bilibili.com/video/BV1ns4y1A7fj?t=1.1">https://www.bilibili.com/video/BV1ns4y1A7fj?t=1.1</a></p><h2 id="篇5"><a href="#篇5" class="headerlink" title="篇5"></a><a href="#篇5" title="篇5"></a>篇5</h2><p>新增：2023-09-27</p><p><strong>【程序员的喵】英语学习分享</strong><br><a href="https://catcoding.me/">https://catcoding.me/</a></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/lin64850/tuchuang/master/img/202311/Snipaste_2023-09-27_13-52-54.png" alt=""></p><h1 id="文档翻译软件"><a href="#文档翻译软件" class="headerlink" title="文档翻译软件"></a><a href="#文档翻译软件" title="文档翻译软件"></a><strong>文档翻译软件</strong></h1><blockquote><p><strong>🆎 翻译软件</strong></p><p><strong><a href="https://eureka.mba/posts/c7f8ec10.html">https://eureka.mba/posts/c7f8ec10.html</a></strong></p></blockquote><blockquote><p><strong>🆎 英语词频统计工具，计算字符、单词、句子、行数</strong></p><p><strong><a href="https://textmechanic.com/text-tools/basic-text-tools/count-characters-words-lines/">https://textmechanic.com/text-tools/basic-text-tools/count-characters-words-lines/</a></strong></p></blockquote><h1 id="英文写作润色工具"><a href="#英文写作润色工具" class="headerlink" title="英文写作润色工具"></a><a href="#英文写作润色工具" title="🆎 英文写作润色工具"></a><strong>英文写作润色工具</strong></h1><blockquote><p><strong>Ps：排名不分先后，随机排序的</strong></p></blockquote><ol><li>Academic Phrasebank<br>可以查到源于英语母语学习者的地道表达。Academic Phrasebank也有literature review、critical writing等方方面面的写作指导<br><a href="https://www.phrasebank.manchester.ac.uk/">https://www.phrasebank.manchester.ac.uk/</a></li><li>Hemingway Editor<br>可以修改语法错误，自动检测文章中的长难句，给出修改意见。<br><a href="https://hemingwayapp.com/">https://hemingwayapp.com/</a></li><li>Grammarly<br>帮助识别重复的单词、错别字、错误的介词、冗长的句子、过度使用的单词和被动语态，甚至可以检查标点<br><a href="https://www.grammarly.com/">https://www.grammarly.com/</a></li><li>Ginger<br>可以逐句优化，还有句子改写、字典功能和发音阅读等<br><a href="https://www.gingersoftware.com/">https://www.gingersoftware.com/</a></li><li>Quillbot<br>同义词替换，去掉长杂句,还可以调整类型比如普通，流利，缩短，扩写等等<br><a href="https://quillbot.com/">https://quillbot.com/</a></li><li>Thesaurus<br>高级词汇,帮你查找同义词<br><a href="https://www.thesaurus.com/">https://www.thesaurus.com/</a></li><li>ARizona<br>可以帮助你解决撰写论文中通常最困难的部分：提出论文<br><a href="https://awc.ashford.edu/thesis-generator">https://awc.ashford.edu/thesis-generator</a></li><li>Ludwig<br>一个集翻译、替换、查找、比较等功能于一身的英文写作工具，可以帮助你修改论文语法，提高词汇多样性，甚至让你写出来的句子更加local.可以把你的大白话变成学术用语<br><a href="https://ludwig.guru/">https://ludwig.guru/</a></li><li>剑桥Write&amp;Improve<br>剑桥大学推出的免费写作训练网站<br><a href="http://www.writeandimprove.com/">www.writeandimprove.com</a></li><li>改写匠<br>人工智能英语批改和写作辅助平台，可针对不同文体、不同写作维度和不同错误类型进行智能评估，给出对应的润色建议，并支持一键改写<br><a href="https://www.rewriter.cn/">https://www.rewriter.cn/</a></li><li>1Checker<br>校对、语法检查和智能润色<br><a href="http://www.1checker.com/">http://www.1checker.com/</a></li><li>SlickWrite<br>在线校对+文章可读性检测软件，就和GRAMMARLY差不多。<br><a href="https://www.slickwrite.com/">https://www.slickwrite.com/</a></li><li>Reverso Spell Checker<br>用拼写+语法错误的检查，还能帮你修改标点符号<br><a href="https://www.reverso.net/spell-checker/english-spelling-grammar/">https://www.reverso.net/spell-checker/english-spelling-grammar/</a></li><li>Linggle<br>可用于英语写作的语法、句子工具，可帮助学习者分析更准确的英文写作建议<br><a href="https://www.linggle.com/">https://www.linggle.com/</a></li><li>Nounplus<br>可以检查语法措辞及修正建议。也会用不同的颜色贴心的帮你标记出来。<br><a href="https://www.nounplus.net/">https://www.nounplus.net/</a></li><li>微软爱写作<br>免费英语作文批改网站，国内也可使用<br><a href="http://aimwriting.mtutor.engkoo.com/">http://aimwriting.mtutor.engkoo.com/</a></li><li>Virtual Writing Tutor Grammar Checker<br>语法检查网站,校对器帮助作者计算单词、检查拼写、检查语法和标点、检查释义、改进单词选择、自我评估目标结构的使用以及掌握英语发音<br><a href="https://www.virtualwritingtutor.com/">https://www.virtualwritingtutor.com/</a></li><li>秘塔写作猫<br>国产好用的润色工具，支持中英文润色<br><a href="https://xiezuocat.com/#/">https://xiezuocat.com/#/</a></li><li>Antidote 【法语润色】<br>可以修改语法、词法、句法，也可以当字典以及语法书用<br><a href="https://www.antidote.info/en/">https://www.antidote.info/en/</a></li><li>LanguageTool<br>一款语法、文风和拼字校对工具，LanguageTool支持超过20种语言<br><a href="https://languagetool.org/">https://languagetool.org/</a></li><li>Rewordify<br>一个功能强大的免费在线软件，可以改善阅读、学习和教学，也可以用于重写润色。<br><a href="http://rewordify.com/">http://rewordify.com/</a></li><li>Triivi<br>一款SCI论文写作的辅助工具，分分钟解决论文写作中词汇量的问题<br>英文输入软件，免费开源，具备词频调整、智能纠错，根据已经输入的字母猜出想写点词或短语，提高英文输入速度！标准版具有50万词汇量,专业词库(约20万词汇).<br><a href="https://download.cnet.com/Triivi-English-Typing-Accelerator/3000-2079_4-10576967.html">https://download.cnet.com/Triivi-English-Typing-Accelerator/3000-2079_4-10576967.html</a></li><li>StyleWriter<br>这款润色神器除了校对功能外，还有专业术语、句子和可读性检查等多达39项检测，会自动给出修改建议及原因，并用不同的颜色来标记，其检查的准确性高<br><a href="https://www.stylewriter-usa.com/">https://www.stylewriter-usa.com/</a></li><li>Write like a PRO<br>一款英文自动校对工具，可为您自动检测文本各类语言使用错误，完成准确高效的校对<br><a href="https://wordvice.ai/cn">https://wordvice.ai/cn</a></li><li>British national corpus3<br>可以根据自己需要的意思找到比较常用的说法<br><a href="http://www.natcorp.ox.ac.uk/">http://www.natcorp.ox.ac.uk/</a></li><li>ProwritingAid<br>拥有查重功能，以及选择写作风格<br><a href="https://prowritingaid.com/">https://prowritingaid.com/</a></li><li>句解霸<br>英语句子成分分析<br><a href="http://www.en998.com/">http://www.en998.com/</a></li><li>WhiteSmoke<br>一款强大的写作辅助工具，能够检测数百个语法和拼写错误，并给提供拼写建议；可以提供全文翻译、多语言字典；同时能够改善语句、词汇和写作风格<br><a href="https://www.whitesmoke.com/">https://www.whitesmoke.com/</a></li><li>Wordtune:人工智能写作伴侣<br>帮助作者将思想提炼成正确的单词，检查语法错误<br><a href="https://www.wordtune.com/">https://www.wordtune.com/</a></li><li>Microsoft office Word<br>内置软件拼写和语法检查软件，可以帮助作者找出语法和拼写错误或标点错误</li></ol>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简历核心知识点</title>
      <link href="/posts/520504/"/>
      <url>/posts/520504/</url>
      
        <content type="html"><![CDATA[<h1 id="简历知识点"><a href="#简历知识点" class="headerlink" title="简历知识点"></a>简历知识点</h1><h2 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h2><h3 id="DDD架构与MVC架构"><a href="#DDD架构与MVC架构" class="headerlink" title="DDD架构与MVC架构"></a>DDD架构与MVC架构</h3><p>DDD领域驱动设计是一种架构思想，主要为了解决MVC架构VO、PO腐化的问题</p><p><img src= "/img/loading.gif" data-src="https://qiniu.azkk.top/typora/image-20240301155810884.png" alt="image-20240301155810884"></p><p>在MVC架构中，PO、VO与Service之间是互相调用的，也就是说可能一个VO被多个Service引用，但是每个Service中需要的属性可能略有差别，造成VO十分臃肿，并且属于哪个Service不明确，造成工程腐化，难以维护与迭代。而在DDD架构中，倾向于将工程拆分为一个个领域，每个领域有相应的对象(值对象，实体对象，聚合对象)、Service服务和仓储服务，这样单个领域属于一个充血模型，对象属于属于哪个Service一目了然，各领域之间互不干扰，方便维护与迭代。但是MVC前期开发速度很快，相对来说DDD架构前期开发成本较高，比较适用于软件需要长期维护与迭代，如果软件只需要存活几年，则无需使用DDD架构。</p><h3 id="DDD架构分层"><a href="#DDD架构分层" class="headerlink" title="DDD架构分层"></a>DDD架构分层</h3><p><img src= "/img/loading.gif" data-src="https://qiniu.azkk.top/typora/image-20240301162323699.png" alt="image-20240301162323699"></p><ul><li><strong>接口定义 - xfg-frame-api</strong>：因为微服务中引用的 RPC 需要对外提供接口的描述信息，也就是调用方在使用的时候，需要引入 Jar 包，让调用方好能依赖接口的定义做代理。</li><li><strong>应用封装 - xfg-frame-app</strong>：这是应用启动和配置的一层，如一些 aop 切面或者 config 配置，以及打包镜像都是在这一层处理。你可以把它理解为专门为了启动服务而存在的。</li><li><strong>领域封装 - xfg-frame-domain</strong>：领域模型服务，是一个非常重要的模块。无论怎么做DDD的分层架构，domain 都是肯定存在的。在一层中会有一个个细分的领域服务，在每个服务包中会有【模型、仓库、服务】这样3部分。</li><li><strong>仓储服务 - xfg-frame-infrastructure</strong>：基础层依赖于 domain 领域层，因为在 domain 层定义了仓储接口需要在基础层实现。这是依赖倒置的一种设计方式，依赖倒置的处理方式也是为了让PO不暴露出去，做到防腐。</li><li><strong>领域封装 - xfg-frame-trigger</strong>：触发器层，一般也被叫做 adapter 适配器层。用于提供接口实现、消息接收、任务执行等。所以对于这样的操作，把它叫做触发器层。</li><li><strong>类型定义 - xfg-frame-types</strong>：通用类型定义层，在我们的系统开发中，会有很多类型的定义，包括；基本的 Response、Constants 和枚举。它会被其他的层进行引用使用。</li><li><strong>领域编排【可选】 - xfg-frame-case</strong>：领域编排层，一般对于较大且复杂的的项目，为了更好的防腐和提供通用的服务，一般会添加 case/application 层，用于对 domain 领域的逻辑进行封装组合处理（对领域进行编排）。</li></ul><h3 id="DDD领域分层"><a href="#DDD领域分层" class="headerlink" title="DDD领域分层"></a>DDD领域分层</h3><p><img src= "/img/loading.gif" data-src="https://qiniu.azkk.top/typora/image-20240301163743315.png" alt="image-20240301163743315"></p><ul><li>model 模型对象；<ul><li>aggreate：聚合对象，实体对象、值对象的协同组织，就是聚合对象。</li><li>entity：实体对象，大多数情况下，实体对象(Entity)与数据库持久化对象(PO)是1v1的关系，但也有为了封装一些属性信息，会出现1vn的关系。</li><li>valobj：值对象，通过对象属性值来识别的对象 </li></ul></li><li>repository 仓储服务；从数据库等数据源中获取数据，传递的对象可以是聚合对象、实体对象，返回的结果可以是；实体对象、值对象。因为仓储服务是由基础层(infrastructure) 引用领域层(domain)，是一种依赖倒置的结构，但它可以天然的隔离PO数据库持久化对象被引用。</li><li>service 服务设计；这里要注意，不要以为定义了聚合对象，就把超越1个对象以外的逻辑，都封装到聚合中，这会让你的代码后期越来越难维护。聚合更应该注重的是和本对象相关的单一简单封装场景，而把一些重核心业务方到 service 里实现。<strong>此外；如果你的设计模式应用不佳，那么无论是领域驱动设计、测试驱动设计还是换了三层和四层架构，你的工程质量依然会非常差。</strong></li></ul><blockquote><p>也就是说从MVC转为DDD，其实就相当于把空间归置好，让其变得整洁，知道衣服在什么地方，但衣服怎么叠还是涉及到代码质量的问题，所以在DDD中使用设计模式尤为重要，会使代码更清晰更好维护，如利用模板模式抽象整个流程，规则引擎过滤账号校验、策略模式包装不同类型的具体实现等等</p></blockquote><p><img src= "/img/loading.gif" data-src="https://qiniu.azkk.top/typora/road-map-ddd-08.png" alt="road-map-ddd-08"></p><h3 id="Spring核心"><a href="#Spring核心" class="headerlink" title="Spring核心"></a>Spring核心</h3><h4 id="1、Bean的创建生命周期"><a href="#1、Bean的创建生命周期" class="headerlink" title="1、Bean的创建生命周期"></a>1、Bean的创建生命周期</h4><p><img src= "/img/loading.gif" data-src="https://qiniu.azkk.top/typora/image-20240302233441921.png" alt="image-20240302233441921"></p><h4 id="2、AOP基本原理"><a href="#2、AOP基本原理" class="headerlink" title="2、AOP基本原理"></a>2、AOP基本原理</h4><p>初始化后如果对象需要经过AOP，则会创建一个代理对象，将生成的普通对象赋值给代理对象的target属性，也就是说生成的Bean就是这个代理对象，调用方法也是调用的代理对象的方法，当然代理对象也只是对功能进行增强，执行切面逻辑后需要调用target的对应方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Public <span class="keyword">class</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> OrderServioce orderService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Public <span class="keyword">class</span> <span class="title class_">UserServiceProxy</span> extend UserService&#123;<span class="comment">//CGLIB动态代理</span></span><br><span class="line"><span class="keyword">private</span> UserService target;<span class="comment">//(将bean创建过程中生成的普通对象赋值给他)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//执行切面逻辑（例：@Before在执行原始对象方法前）</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//执行方法</span></span><br><span class="line">        target.test()；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Public <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;<span class="comment">//(将bean创建过程中生成的普通对象赋值给他)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//在这里的userService其实是代理对象</span></span><br><span class="line">        <span class="comment">//在处理切面逻辑没进入原始对象的test方法之前orderService等属性是为null的</span></span><br><span class="line">        userService.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>代理对象</strong>：当使用AOP时，Spring会为目标对象创建一个代理对象。这个代理对象包含了目标对象以及切面的逻辑。当你调用代理对象的方法时，首先会执行切面的逻辑，然后再调用目标对象的方法。</li><li><strong>代理对象属性</strong>：虽然代理对象包含了目标对象的所有属性和方法，但代理对象本身并不直接持有目标对象的依赖对象（如OrderService）。因此，在代理对象内部直接访问这些依赖对象可能会导致空指针异常。但在实际执行目标对象的方法时，由于已经切换到了目标对象，所以可以正常访问这些依赖对象。</li></ol><blockquote><p>当然Spring的事务管理（@Transactional）也是通过AOP实现的，切面逻辑：</p><p>​    1.通过事务管理器开启DataSource连接                                                 2. 将conn.autoCommit置为false</p><p>​    3.执行方法，正常则执行conn.commit()，否则conn.rollback()          4. 将conn.autoCommit置为true</p></blockquote><h3 id="MySQL核心知识"><a href="#MySQL核心知识" class="headerlink" title="MySQL核心知识"></a>MySQL核心知识</h3><ul><li>MySQL事务并行执行可能出现的问题</li></ul><ol><li>脏读（一个事务可以读取到其他事务修改但未提交的数据）</li><li>不可重复读（事务执行过程中多次查询同一个数据是不一样的）</li><li>幻读（事务A进行对范围内的数据执行查询操作，此时事务B插入了一条数据，使得事务A多次查询数据集合不一致）</li></ol><ul><li><p>隔离级别</p><pre><code>1. 读未提交（会造成脏读、不可重复读、幻读）1. 读已提交（会造成不可重复读、幻读）1. 可重复读（会造成幻读，MYSQL默认隔离级别，InnoDB使用MVCC机制解决脏读和不可重复读问题，使用锁机制解决幻读问题）1. 串行化（事务串行执行，效率最差安全性最高）</code></pre></li><li><p>事务原理</p></li></ul><blockquote><p>事务四大特性：A(原子性)、C(一致性)、I(隔离性)、D(持久性)，事务原理就是InnoDB怎么保证事务ACID特性</p></blockquote><ol><li>事务的原子性指的是事务执行的所有操作要么同时成功要么同时失败，在执行失败的时候事务需要回滚操作，主要是通过定义undo log日志实现的，undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作</li><li>事务的一致性指的是数据从一个一致状态到另一个一致状态，主要是针对数据层面，而原子性更多指的是操作层面</li><li>事务的隔离性，MYSQL定义了四种隔离级别，默认为RR可重复读</li><li>事务的持久性指的是事务执行完成后必须写入磁盘做持久化，为了提高数据写入磁盘效率，事务执行后会将操作先写入redo log中，同时将数据写入Buffer Pool缓存中，定时读取redo log日志进行刷盘，同时数据库宕机了也通过redo log进行数据恢复。</li></ol><ul><li>索引</li></ul><blockquote><p>索引是一种提高数据库检索速度的数据结构，分为聚簇索引和非聚簇索引，底层由B+树实现，但索引并不是越多越好，因为在对数据进行修改的同时需要动态维护索引树，会造成额外开销</p></blockquote><ol><li>聚簇索引：主键就是一种聚簇索引，叶子节点上保存着整行记录</li><li>非聚簇索引：叶子节点上保存着主键ID，想要得到整行记录还需要通过主键ID进行回表操作，所以最好查询的信息覆盖索引，也就是说查询的字段在索引值上就可以获取得到，不用再执行回表操作，提高效率</li><li>联合索引：非聚簇索引，SQL语句想要走联合索引需要符合最左前缀原则，比如联合索引 age-name ，若SQL语句通过name作为条件查询，是没有办法走索引的，因为越过了age，不符合最左前缀原则，但如果用age作为条件或者age和name作为条件查询，则可以走索引（注意：只要符合最左前缀原则，SQL语句条件字段的顺序与索引顺序无关，InnoDB底层会自动优化成索引的顺序）</li></ol><h3 id="MyBatis核心知识"><a href="#MyBatis核心知识" class="headerlink" title="MyBatis核心知识"></a>MyBatis核心知识</h3><h3 id="Redis核心知识"><a href="#Redis核心知识" class="headerlink" title="Redis核心知识"></a>Redis核心知识</h3><blockquote><p><strong>Redis</strong> 有 6 种基础数据结构，它们分别是：<strong>string(字符串)</strong>、<strong>list(列表)</strong>、<strong>hash(字典)</strong>、<strong>set(集合)</strong> 、 <strong>zset(有序集合)</strong>和 <strong>Stream(流)</strong>。</p></blockquote><ul><li>持久化机制</li></ul><blockquote><p>Redis持久化机制主要有两种方式：RDB和AOF</p></blockquote><ol><li><p>RDB持久化是指在指定的时间间隔内将内存中的数据集以快照的方式写入磁盘，并保存到一个名为dump.rdb的二进制文件中，也是默认的持久化方式，它恢复时是将快照文件从磁盘直接读到内存里。</p><ul><li><p>save命令，以阻塞的方式进行RDB持久化</p></li><li><p>bgsave命令，会fork一个子进程来完成RDB的过程（阻塞fork这个动作），可以理解为Copy On Write机制，可能造成数据丢失</p></li><li><p>自动触发</p><blockquote><p>save 900 1              #在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。</p><p>save 300 10            #在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。</p><p>save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。</p></blockquote></li></ul></li><li><p>AOF日志是持续增量的备份，将Redis执行过的每个写操作以日志的形式记录下来(读操作不记录)，只许追加文件但不可以改写文件(appendonly.aof文件)。redis启动的时候会读取该文件进行数据恢复，根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p><ul><li><p>AOF重写机制：</p><blockquote><p>AOF是将每一个写操作记录到文件中，会造成AOF文件越来越大，当文件大小超过阈值时，需要对AOF文件进行重写，执行BGREWRITEAOF命令，Redis会维护一个AOF缓冲区用来记录重写过程中执行的写命令，当重写完成后会将缓冲区命令追加到重写后新的AOF文件中，最后用新的AOF文件替换旧的AOF文件</p></blockquote></li><li><p>AOF触发机制</p><blockquote><p>（1）每修改同步：appendfsync always   同步持久化，每次发生数据变更会被立即记录到磁盘，性能较差但数据完整性比较好。</p><p>（2）每秒同步：appendfsync everysec    异步操作，每秒记录，如果一秒内宕机，有数据丢失。</p><p>（3）不同步：appendfsync no   从不同步</p></blockquote></li></ul></li></ol><ul><li>过期删除策略——惰性＋定期</li></ul><ol><li>定时删除：给key设置过期时间的同时创建一个计时器，当key过期时立即删除</li><li>定期删除：每隔一段时间，随机挑选一些key进行检查，过期则删除</li><li>惰性删除：不主动检查key是否过期，而是在访问的时候先判断key是否过期，过期则删除</li></ol><blockquote><p>在执行SAVE命令或者BGSAVE命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。如果数据库中的某个键已经过期，并且服务器开启了AOF持久化功能，当过期键被惰性删除或者定期删除后，程序会向AOF文件追加一条DEL命令，显式记录该键已被删除。</p></blockquote><ul><li>主从复制</li></ul><ol><li>全量同步</li></ol><p><img src= "/img/loading.gif" data-src="https://qiniu.azkk.top/typora/image-20240310144245999.png" alt="image-20240310144245999"></p><p><img src= "/img/loading.gif" data-src="https://qiniu.azkk.top/typora/image-20240310144409173.png" alt="image-20240310144409173"></p><p><img src= "/img/loading.gif" data-src="https://qiniu.azkk.top/typora/image-20240310144853948.png" alt="image-20240310144853948"></p><ol start="2"><li>增量同步</li></ol><p><img src= "/img/loading.gif" data-src="https://qiniu.azkk.top/typora/image-20240310145454128.png" alt="image-20240310145454128"></p><p><img src= "/img/loading.gif" data-src="https://qiniu.azkk.top/typora/image-20240310150235337.png" alt="image-20240310150235337"></p><ul><li><p>哨兵模式</p><p><img src= "/img/loading.gif" data-src="https://qiniu.azkk.top/typora/image-20240310150743321.png" alt="image-20240310150743321"></p></li></ul><p>​    <img src= "/img/loading.gif" data-src="https://qiniu.azkk.top/typora/image-20240310151008554.png" alt="image-20240310151008554"></p><p>​    <img src= "/img/loading.gif" data-src="https://qiniu.azkk.top/typora/image-20240310151222677.png" alt="image-20240310151222677"></p><p><img src= "/img/loading.gif" data-src="https://qiniu.azkk.top/typora/image-20240310151429592.png" alt="image-20240310151429592"></p><ul><li>缓存三大问题</li></ul><ol><li>缓存穿透：访问的数据在数据库和Redis中均不存在，通过缓存空对象（or 布隆过滤器）解决</li><li>缓存雪崩：同一时间大量key过期或Redis宕机，使得大量请求打到数据库，通过设置随机过期时间解决</li><li>缓存击穿：针对热点key过期，使得大量请求打到数据库，可以通过设置逻辑过期时间来解决，也就是不给热点key设置过期时间，当逻辑过期了，查询数据库进行缓存重建，但这段时间仍旧可以在Redis中请求到热点数据</li></ol><ul><li>Mysql与Redis的数据一致性保证</li></ul><ol><li>先删除缓存，再修改数据库（X）</li></ol><blockquote><p>如果先删除Redis缓存，此时还未来得及修改数据库，另一个线程就来读取数据，那么会把数据库中旧数据再写入到缓存中</p></blockquote><ol start="2"><li>先修改数据库，再删除缓存（X）</li></ol><blockquote><p>如果先修改数据库，修改完成之后不幸线程挂掉了，导致缓存没有删除，那么下次线程读取的是旧缓存的数据</p></blockquote><ol start="3"><li>延时双删 （✓）</li></ol><blockquote><p>先删除缓存，再操作数据库，待线程休眠XXX毫秒之后，再删除一次缓存</p><p>为什么要双删呢？</p><p>答：因为第一次删除的是还没更新前的数据，第二次删除则是因为读取的并发性导致的缓存重新写入数据出现的垃圾数据。</p></blockquote><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><blockquote><p>RabbitMQ工作模式：<a href="https://juejin.cn/post/6997217228743507981#heading-11">https://juejin.cn/post/6997217228743507981#heading-11</a></p></blockquote><h4 id="1、消息可靠性保证"><a href="#1、消息可靠性保证" class="headerlink" title="1、消息可靠性保证"></a>1、消息可靠性保证</h4><blockquote><p>MQ消息丢失可能有三种可能：1、生产者没有成功投递到MQ中；2、MQ自己把消息弄丢了；3、消费者未成功消费</p></blockquote><p><img src= "/img/loading.gif" data-src="https://qiniu.azkk.top/typora/image-20240310193426427.png" alt="image-20240310193426427"></p><ul><li>生产者端：开启消息确认，Confirm模式，当MQ收到消息之后给生产者返回ack，在生产者中可以进行消息重传</li><li>MQ端：开启消息持久化，搭配生产者confirm机制，也就是将消息持久化之后再返回ack给生产者</li><li>消费者端：关闭MQ自动ack，当业务处理完毕再手动返回ack，MQ未收到ack即会再次把消息发给消费者消费</li></ul><h4 id="2、消息重复消费"><a href="#2、消息重复消费" class="headerlink" title="2、消息重复消费"></a>2、消息重复消费</h4><blockquote><p>在MQ中消息是无法保证不重复消费的，所以需要我们在业务中做幂等性保证，以下是几个思路：</p><ol><li>如果是直接写库的业务，先根据主键ID查询是否有这条记录，有则更新无则插入</li><li>如果是执行redis写操作，则天然就是幂等的</li><li>也可以传一个消息唯一ID过来，消费过则存入redis中，下次消息过来先判断消息ID在redis是否存在，无则消费</li></ol></blockquote><h3 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a>Seata</h3><h4 id="XA"><a href="#XA" class="headerlink" title="XA"></a>XA</h4><p><img src= "/img/loading.gif" data-src="https://qiniu.azkk.top/typora/image-20240310210050660.png" alt="image-20240310210050660"></p><h4 id="TA"><a href="#TA" class="headerlink" title="TA"></a>TA</h4><p><img src= "/img/loading.gif" data-src="https://qiniu.azkk.top/typora/image-20240310205215766.png" alt="image-20240310205215766"></p><p>会出现丢失更新，所以引入了全局锁，记录事务ID、表以及哪行记录，事务提交时需要获取全局锁，默认重试时间为10毫秒*30次</p><h3 id="杂谈"><a href="#杂谈" class="headerlink" title="杂谈"></a>杂谈</h3><p>OpenAI项目中SDK为什么用会话模型结构实现，因为通过工厂屏蔽使用细节，简化接口调用，像mybatis也是运用了这种结构，底层只有查和改两种操作（增删改都是改），但是通过会话工厂包装会话，提供增删改查四个接口，简化了接口调用，也方便用户调用。</p>]]></content>
      
      
      <categories>
          
          <category> 简历核心知识点 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDD架构 </tag>
            
            <tag> MySQL </tag>
            
            <tag> Redis </tag>
            
            <tag> Seata </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>资源合集</title>
      <link href="/posts/520506/"/>
      <url>/posts/520506/</url>
      
        <content type="html"><![CDATA[<p><strong>💡 文章转自<a href="https://lin64850.github.io/">Eureka</a>——资源汇总合集</strong></p><h1 id="📕-PDF处理工具推荐"><a href="#📕-PDF处理工具推荐" class="headerlink" title="📕 PDF处理工具推荐"></a><a href="#📕-PDF处理工具推荐" title="📕 PDF处理工具推荐"></a>📕 PDF处理工具推荐</h1><blockquote><p>集合了很多 PDF 处理工具，支持格式转换、PDF 编辑、合并、分割、加水印、OCR 识别、压缩、签名、加密/解密、旋转等，功能非常丰富</p></blockquote><table><thead><tr><th align="center">网站</th><th>网址</th><th align="center">网站</th><th>网址</th></tr></thead><tbody><tr><td align="center">smallPDF</td><td><a href="https://smallpdf.com/">https://smallpdf.com/</a></td><td align="center">ALL TO ALL</td><td><a href="https://www.alltoall.net/">https://www.alltoall.net/</a></td></tr><tr><td align="center">Online OCR</td><td><a href="https://www.onlineocr.net/">https://www.onlineocr.net/</a></td><td align="center">inyWow</td><td><a href="https://tinywow.com/">https://tinywow.com/</a></td></tr><tr><td align="center">PDF to Word Converter</td><td><a href="https://www.pdftoword.com/">https://www.pdftoword.com/</a></td><td align="center">PDF转换器</td><td><a href="https://www.pdfwordconvert.com/zh/">https://www.pdfwordconvert.com/zh/</a></td></tr><tr><td align="center">加加PDF</td><td><a href="https://www.addpdf.cn/pdf-to-word">https://www.addpdf.cn/pdf-to-word</a></td><td align="center">PDF转换</td><td><a href="https://www.onlinepdftoimage.com/zh/">https://www.onlinepdftoimage.com/zh/</a></td></tr><tr><td align="center">ilovePDF</td><td><a href="https://www.ilovepdf.com/">https://www.ilovepdf.com/</a></td><td align="center">免费在线PDF分配器</td><td><a href="https://www.splitapdf.com/zh/">https://www.splitapdf.com/zh/</a></td></tr><tr><td align="center">PDFconverter</td><td><a href="https://www.pdfconverter.com/">https://www.pdfconverter.com</a></td><td align="center">文件格式转换工具</td><td><a href="https://www.aconvert.com/">https://www.aconvert.com/</a></td></tr><tr><td align="center">PDFbao</td><td><a href="http://www.pdfbao.com/">http://www.pdfbao.com/</a></td><td align="center">ZAMZAR</td><td><a href="https://www.zamzar.com/">https://www.zamzar.com/</a></td></tr><tr><td align="center">LightPDF</td><td><a href="https://lightpdf.com/zh/">https://lightpdf.com/zh/</a></td><td align="center">CAJ 转 PDF 转换器</td><td><a href="https://caj2pdf-qt.sainnhe.dev/">https://caj2pdf-qt.sainnhe.dev/</a></td></tr><tr><td align="center">cloudconvert</td><td><a href="https://cloudconvert.com/pdf-to-doc">https://cloudconvert.com/pdf-to-doc</a></td><td align="center">Web Apps by 123apps</td><td><a href="https://123apps.com/">https://123apps.com/</a></td></tr><tr><td align="center">迅捷PDF转换器</td><td><a href="https://app.xunjiepdf.com/">https://app.xunjiepdf.com/</a></td><td align="center">立即翻译任何文档格式为任意语言</td><td><a href="https://www.onlinedoctranslator.com/zh-CN/">https://www.onlinedoctranslator.com/zh-CN/</a></td></tr><tr><td align="center">UPDF正文编辑</td><td><a href="https://www.updf.cn/updf/">https://www.updf.cn/updf/</a></td><td align="center">docsmall</td><td><a href="https://docsmall.com/">https://docsmall.com/</a></td></tr><tr><td align="center">PDF2go</td><td><a href="https://www.pdf2go.com/zh/">https://www.pdf2go.com/zh/</a></td><td align="center">HiPDF让PDF变得简单高效</td><td><a href="https://www.hipdf.cn/">https://www.hipdf.cn/</a></td></tr><tr><td align="center">ABBYY FineReader</td><td><a href="https://ocr.abbyy.cn/">https://ocr.abbyy.cn/</a></td><td align="center">PDF派</td><td><a href="https://www.pdfpai.com/">https://www.pdfpai.com/</a></td></tr><tr><td align="center">PDF.IO</td><td><a href="https://pdf.io/tw/">https://pdf.io/tw/</a></td><td align="center">onlineocr</td><td><a href="https://www.onlineocr.net/">https://www.onlineocr.net/</a></td></tr><tr><td align="center">PDFtodoc</td><td><a href="http://pdf2doc.com/zh/">http://pdf2doc.com/zh/</a></td><td align="center">rightpdf</td><td><a href="https://online.rightpdf.com/cn/office-to-pdf">https://online.rightpdf.com/cn/office-to-pdf</a></td></tr><tr><td align="center">pdfcandy</td><td><a href="https://pdfcandy.com/cn/">https://pdfcandy.com/cn/</a></td><td align="center">PDF格式转换</td><td><a href="http://www.pdfbao.com/pdf2word.html">http://www.pdfbao.com/pdf2word.html</a></td></tr><tr><td align="center">记灵工具</td><td><a href="https://remeins.com/">https://remeins.com/</a></td><td align="center">将DOC/DOCX文档转换成PDF</td><td><a href="https://doctopdf.com/zh/">https://doctopdf.com/zh/</a></td></tr><tr><td align="center">超级PDF</td><td><a href="https://xpdf.cn/">https://xpdf.cn/</a></td><td align="center">PDF Burger</td><td><a href="https://pdfburger.com/combine-to-pdf">https://pdfburger.com/combine-to-pdf</a></td></tr><tr><td align="center">PDF24 Tools</td><td><a href="https://tools.pdf24.org/zh/">https://tools.pdf24.org/zh/</a></td><td align="center">PDF转换器</td><td><a href="https://pdf.to/">https://pdf.to/</a></td></tr></tbody></table><hr><h1 id="🤖-机器人服务"><a href="#🤖-机器人服务" class="headerlink" title="🤖 机器人服务"></a><a href="#🤖-机器人服务" title="🤖 机器人服务"></a>🤖 机器人服务</h1><blockquote><p>一些机器人服务工具，免费付费的都有</p></blockquote><table><thead><tr><th align="center">网站</th><th align="center">网址</th><th align="center">简介</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">傻妞机器人</td><td align="center"><a href="https://github.com/cdle/sillyGirl">https://github.com/cdle/sillyGirl</a></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">图灵机器人</td><td align="center"><a href="http://www.turingapi.com/">http://www.turingapi.com/</a></td><td align="center">需求实名制认证，并每天免费数量只有 100 条</td><td align="center"></td></tr><tr><td align="center">青云客智能聊天机器人</td><td align="center"><a href="http://api.qingyunke.com/">http://api.qingyunke.com/</a></td><td align="center">无须申请，无数量限制，但有点智障，分手神器。分手神器，慎用</td><td align="center"></td></tr><tr><td align="center">智能闲聊（腾讯）</td><td align="center"><a href="https://ai.qq.com/">https://ai.qq.com/</a></td><td align="center">申请使用，免费且无限量。大厂靠谱</td><td align="center"></td></tr><tr><td align="center">天行机器人</td><td align="center"><a href="https://www.tianapi.com/apiview/47">https://www.tianapi.com/apiview/47</a></td><td align="center">认证后有 7 万条免费使用。之后收费：1 万条/1 块钱</td><td align="center"></td></tr><tr><td align="center">海知智能</td><td align="center"><a href="https://ruyi.ai/">https://ruyi.ai/</a></td><td align="center">功能很强大，不仅仅用于聊天。需申请 key，免费</td><td align="center"></td></tr><tr><td align="center">思知对话机器人</td><td align="center"><a href="https://www.ownthink.com/">https://www.ownthink.com/</a></td><td align="center">免费，可不申请 appid</td><td align="center"></td></tr><tr><td align="center">一个AI</td><td align="center"><a href="http://www.yige.ai/">http://www.yige.ai/</a></td><td align="center">免费且无数量限制。可自定义回复、对话、场景。但高级功能使用比较复杂。但已长时间没人维护</td><td align="center"></td></tr><tr><td align="center">小I机器人</td><td align="center"><a href="https://www.xiaoi.com/index">https://www.xiaoi.com/index</a></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">茉莉机器人</td><td align="center"><a href="https://mlyai.com/">https://mlyai.com/</a></td><td align="center"></td><td align="center"></td></tr></tbody></table><hr><h1 id="🐧-微信QQ辅助工具"><a href="#🐧-微信QQ辅助工具" class="headerlink" title="🐧 微信QQ辅助工具"></a><a href="#🐧-微信QQ辅助工具" title="🐧 微信QQ辅助工具"></a>🐧 微信QQ辅助工具</h1><blockquote><p>微信 or QQ机器人、微信群管理、多开等辅助工具</p></blockquote><table><thead><tr><th>网站</th><th align="center">网址</th><th align="left">简介</th><th>备注</th></tr></thead><tbody><tr><td>茉莉QQ机器人</td><td align="center"><a href="https://github.com/xggz/mqr">项目</a> 📍 <a href="http://mqr.molicloud.com/">文档</a></td><td align="left">采用mirai的Android协议实现的QQ机器人服务，</td><td></td></tr><tr><td>通过web控制机器人的启停和配置</td><td align="center"></td><td align="left"></td><td></td></tr><tr><td>QQBotHub</td><td align="center"><a href="https://github.com/yiyungent/QQBotHub">项目</a> 📍 <a href="https://moeci.com/QQBotHub/#/">文档</a></td><td align="left">QQ 机器人,基于 Konata.Core, 一键免费部署</td><td></td></tr><tr><td>高效率 QQ 机器人支持库</td><td align="center"><a href="https://github.com/mamoe/mirai">项目</a></td><td align="left">mirai 是一个在全平台下运行，</td><td></td></tr><tr><td>提供 QQ Android 协议支持的高效率机器人库</td><td align="center"></td><td align="left"></td><td></td></tr><tr><td>微信SDK</td><td align="center"><a href="https://github.com/silenceper/wechat">项目</a> 📍 <a href="https://silenceper.com/wechat/">文档</a></td><td align="left">使用Golang开发的微信SDK，简单、易用。</td><td></td></tr><tr><td>微信助手</td><td align="center"><a href="https://github.com/sfyc23/EverydayWechat">项目</a></td><td align="left">1.每日定时给好友（女友）发送定制消息。</td><td></td></tr><tr><td>2.机器人自动回复好友。</td><td align="center"></td><td align="left"></td><td></td></tr><tr><td>3.群助手功能</td><td align="center"></td><td align="left"></td><td></td></tr><tr><td>（例如：查询垃圾分类、天气、日历、</td><td align="center"></td><td align="left"></td><td></td></tr><tr><td>电影实时票房、快递物流、PM2.5等）</td><td align="center"></td><td align="left"></td><td></td></tr><tr><td>微信每日说</td><td align="center"><a href="https://github.com/leochen-g/wechatBot">项目</a></td><td align="left">教你用Node做一个微信哄女友(基友)神器！</td><td></td></tr><tr><td>还能帮女朋友解决垃圾分类难题</td><td align="center"></td><td align="left"></td><td></td></tr><tr><td>WxPusher (微信推送服务)</td><td align="center"><a href="https://github.com/wxpusher/wxpusher-sdk-java/">项目</a> 📍 <a href="https://wxpusher.zjiecode.com/docs/#/">文档</a></td><td align="left">一个使用微信公众号作为通道的，实时信息推送平台，</td><td></td></tr><tr><td>你可以通过调用API的方式，把信息推送到微信上，</td><td align="center"></td><td align="left"></td><td></td></tr><tr><td>无需安装额外的软件，即可做到信息实时通知。</td><td align="center"></td><td align="left"></td><td></td></tr><tr><td>你可以使用WxPusher来做服务器报警通知、</td><td align="center"></td><td align="left"></td><td></td></tr><tr><td>抢课通知、抢票通知，信息更新提示等。</td><td align="center"></td><td align="left"></td><td></td></tr><tr><td>贴心小助手客户端</td><td align="center"><a href="https://github.com/lizhounet/wx-intimate-pro">项目</a></td><td align="left">微信机器人, 群管理、头像处理、智能机器人对话、</td><td></td></tr><tr><td>好友互动、定时任务，情侣每日说等功能的配置</td><td align="center"></td><td align="left"></td><td></td></tr><tr><td>itchat开源的微信个人号接口</td><td align="center"><a href="https://github.com/littlecodersh/ItChat">项目</a> 📍 <a href="https://itchat.readthedocs.io/zh/latest/">文档</a></td><td align="left">微信个人号接口、微信机器人及命令行微信，</td><td></td></tr><tr><td>三十行即可自定义个人号机器人</td><td align="center"></td><td align="left"></td><td></td></tr><tr><td>Wechaty</td><td align="center"><a href="https://github.com/wechaty/wechaty">项目</a> 📍 <a href="https://wechaty.gitbook.io/wechaty/v/zh/">文档</a></td><td align="left">一个开源的的对话机器人 SDK，支持 个人号 微信</td><td></td></tr></tbody></table><hr><h1 id="🏖-解压网站"><a href="#🏖-解压网站" class="headerlink" title="🏖 解压网站"></a><a href="#🏖-解压网站" title="🏖 解压网站"></a>🏖 解压网站</h1><blockquote><p>有趣的解压创意网站，在工作、生活中添加一些乐趣</p></blockquote><table><thead><tr><th align="center">网站</th><th align="center">网址</th><th>简介</th><th>备注</th></tr></thead><tbody><tr><td align="center">1. Earth.fm</td><td align="center"><a href="https://earth.fm/">https://earth.fm/</a></td><td>一个可以聆听来自世界各地的自然声音的网站</td><td></td></tr><tr><td align="center">2. 动感解压节奏</td><td align="center"><a href="https://aidn.jp/mikutap/">https://aidn.jp/mikutap/</a></td><td>配合空格键和鼠标按键敲出节奏</td><td></td></tr><tr><td align="center">3. 弹力球</td><td align="center"><a href="https://bouncyballs.org/">https://bouncyballs.org/</a></td><td>可以选择球的外观——塑料、气泡、表情符号或眼球</td><td></td></tr><tr><td align="center">球会根据麦克风（和声音）和鼠标的点击来进行跳动</td><td align="center"></td><td></td><td></td></tr><tr><td align="center">可以播放一段音乐，会发生变化</td><td align="center"></td><td></td><td></td></tr><tr><td align="center">4. Patatap</td><td align="center"><a href="https://www.patatap.com/">https://www.patatap.com/</a></td><td>敲击键盘，就会通过声音和简短的动画</td><td></td></tr><tr><td align="center">按空格切换背景和模式</td><td align="center"></td><td></td><td></td></tr><tr><td align="center">5. Pixel Thoughts</td><td align="center"><a href="https://www.pixelthoughts.co/#">https://www.pixelthoughts.co/#</a></td><td>把你的压力写上去</td><td></td></tr><tr><td align="center">网站可以带你进行 60 秒的冥想课程，为您提供最佳体验</td><td align="center"></td><td></td><td></td></tr><tr><td align="center">6.A Soft Murmur</td><td align="center"><a href="https://asoftmurmur.com/">https://asoftmurmur.com/</a></td><td>使用该网站来创建令人敬畏且富有成效的环境噪音</td><td></td></tr><tr><td align="center">7. 找到隐藏的牛</td><td align="center"><a href="https://findtheinvisiblecow.com/">https://findtheinvisiblecow.com/</a></td><td>移动你的鼠标直到你找到了隐藏的牛</td><td></td></tr><tr><td align="center">你鼠标离得越近，它叫的越响</td><td align="center"></td><td></td><td></td></tr><tr><td align="center">8. 创造你的沙画</td><td align="center"><a href="https://thisissand.com/">https://thisissand.com/</a></td><td>在电脑屏幕前创造一幅沙画</td><td></td></tr></tbody></table><hr><h1 id="🥨-高质量文案素材网站"><a href="#🥨-高质量文案素材网站" class="headerlink" title="🥨 高质量文案素材网站"></a><a href="#🥨-高质量文案素材网站" title="🥨 高质量文案素材网站"></a>🥨 高质量文案素材网站</h1><blockquote><p>一些新媒体人必备的文案素材网站，不论你是不会写文、没有题材还是缺乏灵感，看看这些都足以帮你解决问题，写出优秀的文案</p></blockquote><table><thead><tr><th>网站</th><th>网址</th><th>简介</th></tr></thead><tbody><tr><td>1. 文案迷</td><td><a href="http://www.wenanmi.com/">http://www.wenanmi.com/</a></td><td>专注于广告文案</td></tr><tr><td>2. 素材巷</td><td><a href="http://www.sucaixiang.com/">http://www.sucaixiang.com/</a></td><td>分享文字素材的资源平台</td></tr><tr><td>3. 小鸡词典</td><td><a href="https://jikipedia.com/">https://jikipedia.com/</a></td><td>汇集最新网络热梗</td></tr><tr><td>4. 学句子</td><td><a href="http://www.xuejuzi.cn/">http://www.xuejuzi.cn/</a></td><td>唯美句子大全</td></tr><tr><td>5. addog</td><td><a href="https://www.addog.vip/">https://www.addog.vip/</a></td><td>广告人的网址导航</td></tr><tr><td>6. 名言通</td><td><a href="https://www.mingyantong.com/">https://www.mingyantong.com/</a></td><td>提供高品质名言的专业网站</td></tr><tr><td>7. 句子控</td><td><a href="https://www.juzikong.com/">https://www.juzikong.com/</a></td><td>文字分享社区</td></tr><tr><td>8. 广告门</td><td><a href="https://www.adquan.com/">https://www.adquan.com/</a></td><td>聚集行业顶尖广告创意文案制作人才</td></tr><tr><td>9. 数英网</td><td><a href="https://www.digitaling.com/">https://www.digitaling.com/</a></td><td>汇集大量优秀营销案例，激发文案灵感</td></tr><tr><td>10. 押韵助手</td><td><a href="https://yayun.la/">https://yayun.la/</a></td><td>辅助词句押韵的在线工具</td></tr><tr><td>11. 句易网</td><td><a href="http://www.ju1.cn/">http://www.ju1.cn/</a></td><td>敏感、违禁词汇查询</td></tr></tbody></table><hr><h1 id="🧩-图片压缩工具合集"><a href="#🧩-图片压缩工具合集" class="headerlink" title="🧩 图片压缩工具合集"></a><a href="#🧩-图片压缩工具合集" title="🧩 图片压缩工具合集"></a>🧩 图片压缩工具合集</h1><p><strong>獨特且強悍的JavaScript演算法，能極速壓縮80%的圖片大小，而不損害其品質</strong><br><a href="https://www.picdiet.com/zh-tw">https://www.picdiet.com/zh-tw</a></p><p><strong>开源的在线压缩网页项目</strong><br><a href="https://github.com/twoabd/CompressioWeb">https://github.com/twoabd/CompressioWeb</a><br>网站：<a href="https://compressio.app/">https://compressio.app/</a></p><p><strong>Upscaler是一个免费的基于人工智能的工具，可以在短短几秒钟内自动缩放图像。</strong><br>可以将图像 “拉伸” 2倍或4倍而不降低其质量。<br>使用该工具只需上传或拖动图片，选择您想要的大小即可。所有这些都是完全免费的。支持的格式：.png, .jpeg, .jpg, .webp。<br><a href="https://www.upscale.media/">https://www.upscale.media/</a></p><p><strong>开源图片压缩客户端</strong><br>开源压缩工具客户端，支持Linux，Windows和MacOS<br><a href="https://github.com/meowtec/Imagine">https://github.com/meowtec/Imagine</a></p><p><strong>Google开源的图片压缩网站/客户端</strong><br>在线：<a href="https://squoosh.app/">https://squoosh.app/</a><br>客户端：<a href="https://squoosh-desktop.vercel.app/">https://squoosh-desktop.vercel.app/</a></p><p><strong>简单易用的图片压缩软件</strong><br><a href="https://tuya.xinxiao.tech/">https://tuya.xinxiao.tech/</a></p><hr><h1 id="🌐-Chrome谷歌浏览器"><a href="#🌐-Chrome谷歌浏览器" class="headerlink" title="🌐 Chrome谷歌浏览器"></a><a href="#🌐-Chrome谷歌浏览器" title="🌐 Chrome谷歌浏览器"></a>🌐 Chrome谷歌浏览器</h1><p><code>历史版本下载</code></p><p><strong>Chrome浏览器最新离线版下载</strong><br><a href="https://www.chromedownloads.net/">https://www.chromedownloads.net/</a></p><p><strong>Index of /chromedriver/</strong><br><a href="https://registry.npmmirror.com/binary.html?path=chromedriver/">https://registry.npmmirror.com/binary.html?path=chromedriver/</a></p><p><strong>Chromium History Versions Download ↓</strong><br><a href="https://mrseawave.github.io/chromium-history-page/">https://mrseawave.github.io/chromium-history-page/</a></p><p><strong>Chrome 离线包 - 历史版本（官方）</strong><br>链接来自 Chromium 官网， 含 Mac、Linux、Windows、Android、ChromiumOS 等<br><a href="https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html">https://commondatastorage.googleapis.com/chromium-browser-snapshots/index.html</a></p><p><strong>GOOGLE CHROME 的旧版本</strong><br><a href="https://google-chrome.cn.uptodown.com/windows/versions">https://google-chrome.cn.uptodown.com/windows/versions</a></p><p><strong>Chromium Portable Files</strong><br><a href="https://sourceforge.net/projects/crportable/files/">https://sourceforge.net/projects/crportable/files/</a></p><p><strong>Google Chrome Older Versions Download (Windows, Linux &amp; Mac)</strong><br><a href="https://www.slimjet.com/chrome/google-chrome-old-version.php">https://www.slimjet.com/chrome/google-chrome-old-version.php</a></p><hr><h1 id="🥅-检测网页变动通知提醒服务"><a href="#🥅-检测网页变动通知提醒服务" class="headerlink" title="🥅 检测网页变动通知提醒服务"></a><a href="#🥅-检测网页变动通知提醒服务" title="🥅 检测网页变动通知提醒服务"></a>🥅 检测网页变动通知提醒服务</h1><p><a href="https://monit.or.passby.me/zh">https://monit.or.passby.me/zh</a><br><a href="https://distill.pub/">https://distill.pub/</a><br><a href="https://visualping.io/">https://visualping.io/</a><br><a href="https://courier.toptopn.com/pusher.html">https://courier.toptopn.com/pusher.html</a></p><hr><h1 id="📃-精校小说下载"><a href="#📃-精校小说下载" class="headerlink" title="📃 精校小说下载"></a><a href="#📃-精校小说下载" title="📃 精校小说下载"></a>📃 精校小说下载</h1><p>知轩藏书：<a href="http://www.zxcs.me/">http://www.zxcs.me/</a><br>贼吧网：<a href="https://www.zei8.vip/">https://www.zei8.vip/</a><br>精校全本：<a href="https://noveless.com/">https://noveless.com/</a><br>免费小说网：<a href="http://www.12z.cn/index.html">http://www.12z.cn/index.html</a><br>精校吧：<a href="https://www.jingjiaoba.com/">https://www.jingjiaoba.com/</a><br>其他：<a href="https://www.yuque.com/eureka007/ziyuan/suw05o#OGHRM">https://www.yuque.com/eureka007/ziyuan/suw05o#OGHRM</a></p><hr><h1 id="💾-一些软件对比网站"><a href="#💾-一些软件对比网站" class="headerlink" title="💾 一些软件对比网站"></a><a href="#💾-一些软件对比网站" title="💾 一些软件对比网站"></a>💾 一些软件对比网站</h1><p><strong>1️⃣ Product Hunt</strong><br>每天会根据热度推荐各种平台冷门好用的工具，<br>这些平台包括但不限于Android、iOS。它的热度是由使用者投票决定，<br>因此，通过投票数就可以直观的分辨这款工具是否好用<br><a href="https://www.producthunt.com/">https://www.producthunt.com/</a></p><p><strong>2️⃣ AlternativeTo</strong><br>一个用于搜索替代品的网站,可以给你找出相关的其他工具<br>把每款推荐软件详细内容罗列出来<br><a href="https://alternativeto.net/">https://alternativeto.net/</a></p><p><strong>3️⃣ SaaSHub</strong><br>一个可以和AlternativeTo相媲美的网站<br>简单的列出每款相关软件的名称、热度<br><a href="https://www.saashub.com/">https://www.saashub.com/</a></p><p><strong>4️⃣ Alternative</strong><br>一个替代软件查找网站<br><a href="https://alternative.me/">https://alternative.me/</a></p><p><strong>5️⃣ Slant</strong><br>根据每一个专题去对比、选择相关方向最好的软件<br><a href="https://www.slant.co/">https://www.slant.co/</a></p><p><strong>6️⃣ SimilarSites</strong><br>一个相关网站查找网站,有插件版<br><a href="https://www.similarsites.com/">https://www.similarsites.com/</a></p><p><strong>7️⃣ StackShare</strong><br>一个专注于开发类软件的网站，进行软件搜索、软件对比<br><a href="https://stackshare.io/">https://stackshare.io/</a></p><p><strong>8️⃣ FileHorse</strong><br>收集和整理了很多优质软件的最新版本和下载方式<br><a href="https://www.filehorse.com/">https://www.filehorse.com/</a></p><hr><h1 id="🔗-短链接"><a href="#🔗-短链接" class="headerlink" title="🔗 短链接"></a><a href="#🔗-短链接" title="🔗 短链接"></a>🔗 短链接</h1><p><a href="https://tt.vg/">https://tt.vg/</a><br><a href="https://9-u.cn/">https://9-u.cn/</a><br><a href="https://020.name/">https://020.name/</a><br><a href="http://mtw.so/">http://mtw.so/</a><br><a href="https://zhiurl.cn/">https://zhiurl.cn/</a><br><a href="https://dlj.li/">https://dlj.li/</a><br><a href="https://colors.to/">https://colors.to/</a><br><a href="https://pxmd.co/">https://pxmd.co/</a><br><a href="https://urlify.cn/">https://urlify.cn/</a><br><a href="https://e.mezw.com/">https://e.mezw.com/</a><br><a href="https://xiaomark.com/">https://xiaomark.com/</a><br><a href="https://www.ft12.com/">https://www.ft12.com/</a><br><a href="https://dh6.ink/">https://dh6.ink/</a><br><a href="https://anran.gs/T/dwz/">https://anran.gs/T/dwz/</a><br><a href="http://suo.nz/">http://suo.nz/</a></p><hr><h1 id="🌏-谷歌镜像"><a href="#🌏-谷歌镜像" class="headerlink" title="🌏 谷歌镜像"></a><a href="#🌏-谷歌镜像" title="🌏 谷歌镜像"></a>🌏 谷歌镜像</h1><p><a href="http://www.yaersen.com/x.html">http://www.yaersen.com/x.html</a><br><a href="https://item.guidebook.top/google/">https://item.guidebook.top/google/</a><br><a href="https://www.library.ac.cn/?=njau">https://www.library.ac.cn/?=njau</a><br><a href="https://search.ahnu.cf/">https://search.ahnu.cf/</a><br><a href="https://g20.i-research.edu.eu.org/">https://g20.i-research.edu.eu.org/</a><br><a href="https://search.ecnu.cf/">https://search.ecnu.cf/</a><br><a href="https://nl.libre.men/scholar">https://nl.libre.men/scholar</a><br><a href="https://ge1.azurewebsites.net/">https://ge1.azurewebsites.net/</a><br><a href="http://d.6wl.cc/">http://d.6wl.cc/</a><br><a href="https://s.iit.xyz/">https://s.iit.xyz/</a><br><a href="https://谷歌.ml/">https://xn–flw351e.ml/</a><br><a href="https://google.icloudnative.io/">https://google.icloudnative.io/</a><br><a href="https://gogogle.cf/">https://gogogle.cf/</a><br><a href="https://g.xzx725.top/">https://g.xzx725.top/</a><br><a href="https://g.qwq.fan/">https://g.qwq.fan/</a></p><hr><h1 id="🎞-通过台词搜索下载相应的电影片段"><a href="#🎞-通过台词搜索下载相应的电影片段" class="headerlink" title="🎞 通过台词搜索下载相应的电影片段"></a><a href="#🎞-通过台词搜索下载相应的电影片段" title="🎞 通过台词搜索下载相应的电影片段"></a>🎞 通过台词搜索下载相应的电影片段</h1><p><strong>根据音乐查影片</strong></p><ol><li><a href="https://www.tunefind.com/">https://www.tunefind.com/</a></li></ol><p><strong>动漫对白搜索</strong></p><ol><li><a href="http://3.gameit.sinaapp.com/">http://3.gameit.sinaapp.com/</a></li><li><a href="http://dialogue.moe/">http://dialogue.moe/</a><br><a href="https://github.com/windrises/dialogue.moe">https://github.com/windrises/dialogue.moe</a></li></ol><p><strong>日语动漫台词</strong></p><ol><li><a href="https://www.immersionkit.com/">https://www.immersionkit.com/</a></li></ol><p><strong>中文搜索</strong></p><ol><li><a href="http://33.agilestudio.cn/">http://33.agilestudio.cn/</a></li><li><a href="http://www.zhaotaici.cn/">http://www.zhaotaici.cn/</a></li><li><a href="http://www.taicishe.com/">http://www.taicishe.com/</a></li><li><a href="https://t.cn/A6aNcGPm">https://t.cn/A6aNcGPm</a></li></ol><p><strong>英文搜索</strong></p><ol><li><a href="http://www.quodb.com/">http://www.quodb.com</a></li><li><a href="http://www.subzin.com/">http://www.subzin.com</a></li><li><a href="https://www.whatismymovie.com/">https://www.whatismymovie.com</a></li><li><a href="https://getyarn.io/">https://getyarn.io</a></li><li><a href="http://find-movie.info/">http://find-movie.info</a></li><li><a href="https://www.moviequotes.com/">https://www.moviequotes.com</a></li></ol><p><code>一个英文台词Google 搜索技巧</code><br>【 google imdb quote 要查询的台词 】</p><hr><h1 id="🕹-上班摸鱼有趣小游戏大全"><a href="#🕹-上班摸鱼有趣小游戏大全" class="headerlink" title="🕹 上班摸鱼有趣小游戏大全"></a><a href="#🕹-上班摸鱼有趣小游戏大全" title="🕹 上班摸鱼有趣小游戏大全"></a>🕹 上班摸鱼有趣小游戏大全</h1><p>——————————<br>无尽之湖：<a href="http://t.cn/A6PLFX50">http://t.cn/A6PLFX50</a><br>召唤神龙：<a href="http://t.cn/A6xgjIKF">http://t.cn/A6xgjIKF</a><br>交换冰淇淋：<a href="http://t.cn/A6JvzNbk">http://t.cn/A6JvzNbk</a><br>水果大王：<a href="http://t.cn/A6VaWJv7">http://t.cn/A6VaWJv7</a><br>苹果的诱惑：<a href="http://t.cn/A6hDZLMR">http://t.cn/A6hDZLMR</a><br>我的停车场：<a href="http://t.cn/A6MkRZ8G">http://t.cn/A6MkRZ8G</a><br>一起剁手吧：<a href="https://t.cn/A6XKYxR2">https://t.cn/A6XKYxR2</a><br>暴力厨房：<a href="http://t.cn/A6xD8SIZ">http://t.cn/A6xD8SIZ</a><br>女皇登基：<a href="http://t.cn/A6xjfCb3">http://t.cn/A6xjfCb3</a><br>龟龟滑雪：<a href="http://t.cn/A6Il6q65">http://t.cn/A6Il6q65</a><br>山楂串：<a href="http://t.cn/A6MkRZ8U">http://t.cn/A6MkRZ8U</a><br>捉迷藏：<a href="http://t.cn/A6MkRZ82">http://t.cn/A6MkRZ82</a><br>宝石魔方：<a href="http://t.cn/A6MkRZ8y">http://t.cn/A6MkRZ8y</a><br>水果爆冰球：<a href="http://t.cn/A6MkRZ8L">http://t.cn/A6MkRZ8L</a><br>植树造林：<a href="http://t.cn/A6MkRZ84">http://t.cn/A6MkRZ84</a><br>小鱼找对象：<a href="http://t.cn/A6Me3TLX">http://t.cn/A6Me3TLX</a><br>打雪仗：<a href="http://t.cn/A6MkRZ8b">http://t.cn/A6MkRZ8b</a><br>转盘小丸子：<a href="http://t.cn/A6MKKk6w">http://t.cn/A6MKKk6w</a><br>车水马龙：<a href="http://t.cn/A6c9W6G9">http://t.cn/A6c9W6G9</a><br>枪王之战: <a href="http://t.cn/A6yy20F4">http://t.cn/A6yy20F4</a><br>画地为牢: <a href="http://t.cn/A6JvUa2A">http://t.cn/A6JvUa2A</a><br>牛气冲天: <a href="http://t.cn/A67ZZWnm">http://t.cn/A67ZZWnm</a><br>剪指甲: <a href="http://t.cn/A6xkrPcZ">http://t.cn/A6xkrPcZ</a><br>小鸭子过河: <a href="http://t.cn/A6xkNeKf">http://t.cn/A6xkNeKf</a><br>倒酒: <a href="http://t.cn/A6xpr8SX">http://t.cn/A6xpr8SX</a><br>凿壁借光: <a href="http://t.cn/A6xHzUcf">http://t.cn/A6xHzUcf</a><br>弹珠碰碰: <a href="http://t.cn/A6IK8B3w">http://t.cn/A6IK8B3w</a><br>转盘小丸子：<a href="http://t.cn/A6MKKk6w">http://t.cn/A6MKKk6w</a><br>合成大西瓜：<a href="http://t.cn/A65yQIb7">http://t.cn/A65yQIb7</a><br>摸鱼在线游戏：<a href="https://poki.cn/">https://poki.cn</a></p><hr><h1 id="🎼-伴奏提取网站"><a href="#🎼-伴奏提取网站" class="headerlink" title="🎼 伴奏提取网站"></a><a href="#🎼-伴奏提取网站" title="🎼 伴奏提取网站"></a>🎼 伴奏提取网站</h1><p><a href="https://dango.ai/">https://dango.ai/</a><br><a href="https://vocalremover.org/">https://vocalremover.org/</a><br><a href="https://songdonkey.ai/">https://songdonkey.ai/</a><br><a href="https://www.lalal.ai/">https://www.lalal.ai/</a></p><hr><h1 id="🧲免费矢量插画下载网站"><a href="#🧲免费矢量插画下载网站" class="headerlink" title="🧲免费矢量插画下载网站:"></a><a href="#🧲免费矢量插画下载网站" title="🧲免费矢量插画下载网站:"></a>🧲免费矢量插画下载网站:</h1><ol><li><a href="https://undraw.co/illustrations">https://undraw.co/illustrations</a><br>开源项目，免费使用。可自定义颜色，然后下载svg或者png适量插画素材。</li><li><a href="https://icons8.com/illustrations">https://icons8.com/illustrations</a><br>十分全面的样式与分类，可免费下载png格式，svg格式为付费的。 免费版使用需要提及来源。</li><li><a href="https://absurd.design/">https://absurd.design/</a><br>画风荒诞夸张的矢量插画素材，免费版使用需要链接来源。</li><li><a href="https://www.humaaans.com/">https://www.humaaans.com/</a><br>主要是矢量人物插画，肢体分离，各种颜色样式可随意组合，包括png、sketch和studio文件，可免费商用。无需标记。</li><li><a href="https://gallery.manypixels.co/">https://gallery.manypixels.co/</a><br>可以自定义颜色的免费矢量素材插画库，可免费商业使用。</li><li><a href="https://iradesign.io/">https://iradesign.io/</a><br>提供5种渐变色自定义矢量插画的各部位颜色，可免费商用。</li><li><a href="https://www.drawkit.io/?ref=lapaninja">https://www.drawkit.io/?ref=lapaninja</a><br>提供免费版和付费版，免费版可商用。</li><li><a href="https://lukaszadam.com/illustrations">https://lukaszadam.com/illustrations</a><br>开源矢量插画，可免费商用。</li><li><a href="https://react-kawaii.vercel.app/">https://react-kawaii.vercel.app/</a><br>开源插画图标，可以组合表情，包括react代码及sketch文件</li><li><a href="http://www.freevector.com/">www.freevector.com/</a><br>历史悠久的一个矢量图网站，文件一般有ai、png、svg格式个人免费使用，需要注明来源。</li><li><a href="https://www.glazestock.com/">https://www.glazestock.com/</a><br>一个免费插画素材库，提供各种类型的图片素材</li><li><a href="https://www.opendoodles.com/">https://www.opendoodles.com/</a><br>可以下载非常漂亮、生动且有质感的手绘插图，包括PNG和SVG两种格式，这些素材使用CC0授权方式释出，可以自由复制、编辑、重新混合或共享这些图案，也能使用于个人或商业用途而不受版权限制</li><li><a href="https://iconscout.com/free-illustrations">https://iconscout.com/free-illustrations</a><br>Iconscout旗下的FreeIllustrations分类中拥有330款免费插图，资源质量非常高，并且大部分都可商用，支持一键下载源文件，非常方便。</li><li><a href="https://www.manypixels.co/gallery">https://www.manypixels.co/gallery</a><br>可一键下载svg和png两种格式。完全免费可商用。</li><li><a href="https://mixkit.co/free-stock-art/">https://mixkit.co/free-stock-art/</a><br>里面聚集了超多高质量的插画作品素材，全部免费可商用，而且还支持一键下载，而且分类详尽，插画质量也比较高。</li><li><a href="https://fresh-folk.com/">https://fresh-folk.com/</a><br>完全免费且可商用</li><li><a href="https://delesign.com/free-designs/graphics/">https://delesign.com/free-designs/graphics/</a><br>是一款集合了很多设计分类的素材库，免费可商用，并且可以在线更换颜色，下载svg和png也更方便</li><li><a href="https://icons8.com/mega-creator">https://icons8.com/mega-creator</a><br>一款免费矢量插图设计工具，免费可商用，支持导出png格式.</li></ol><hr><h1 id="⌨️-打字练习网站"><a href="#⌨️-打字练习网站" class="headerlink" title="⌨️ 打字练习网站"></a><a href="#⌨️-打字练习网站" title="⌨️ 打字练习网站"></a>⌨️ 打字练习网站</h1><ol><li>TypingClub<br><a href="https://www.typingclub.com/da-zi">https://www.typingclub.com/da-zi</a></li><li>Typing<br><a href="https://www.typing.com/">https://www.typing.com/</a></li><li>QWERTY Learner<br><a href="https://qwerty.kaiyi.cool/">https://qwerty.kaiyi.cool/</a></li><li>Typelit：看小说练打字<br><a href="https://www.typelit.io/">https://www.typelit.io/</a></li><li>双拼练习：Shuang<br><a href="https://api.ihint.me/shuang/">https://api.ihint.me/shuang/</a></li><li>双拼入门：Linci<br><a href="https://sp.linci.co/">https://sp.linci.co/</a></li><li>一分钟速度测试：10FastFingers &amp; Typing-cn<br><a href="https://10fastfingers.com/">https://10fastfingers.com/</a></li><li>一分钟打字测试模式的练习网站：typing-cn<br><a href="https://barneyzhao.gitee.io/typing-cn/#/">https://barneyzhao.gitee.io/typing-cn/#/</a></li><li>monkeytype<br><a href="https://monkeytype.com/">https://monkeytype.com/</a></li><li>Typing Practice<br><a href="https://www.keybr.com/">https://www.keybr.com/</a></li><li>在线打字测试<br><a href="https://dazi.kukuw.com/">https://dazi.kukuw.com/</a></li><li>在线打字练习<br><a href="https://dazi.91xjr.com/">https://dazi.91xjr.com</a></li><li>专为程序员设计的打字练习<br><a href="https://developer-typing-game.netlify.app/?ref=producthunt#/">https://developer-typing-game.netlify.app/?ref=producthunt#/</a></li><li>Typing Practice for Programmers<br><a href="https://typing.io/">https://typing.io/</a></li><li>一个不错的练习打字工具，提供了代码练习模式。<br><a href="https://codeflow.biaoyansu.com/">https://codeflow.biaoyansu.com/</a></li></ol><hr><h1 id="🖼-免费壁纸网站大全"><a href="#🖼-免费壁纸网站大全" class="headerlink" title="🖼 免费壁纸网站大全"></a><a href="#🖼-免费壁纸网站大全" title="🖼 免费壁纸网站大全"></a>🖼 免费壁纸网站大全</h1><p><strong>壁纸湖壁纸</strong><br><a href="http://bizihu.com/">http://bizihu.com</a><br><strong>3G 壁纸</strong><br><a href="https://www.3gbizhi.com/">https://www.3gbizhi.com</a><br><strong>美图集</strong><br><a href="https://photo.ihansen.org/">https://photo.ihansen.org</a><br><strong>搜图神器</strong><br>一键搜索多家免版权图库，可以用作壁纸也可以用于商业，下载比较方便。<br><a href="https://www.logosc.cn/so/">https://www.logosc.cn/so/</a><br><strong>乌云壁纸</strong><br><a href="http://www.obzhi.com/">http://www.obzhi.com</a><br><strong>极简壁纸</strong><br><a href="https://bz.zzzmh.cn/">https://bz.zzzmh.cn</a><br><strong>wallhere</strong><br><a href="https://wallhere.com/">https://wallhere.com</a><br><strong>Wallpaper abyss 是国外知名的壁纸下载网站，分享的壁纸数量很多。</strong><br><a href="https://wall.alphacoders.com/">https://wall.alphacoders.com</a><br><strong>Wallhaven免费壁纸网站大全</strong><br><a href="https://wallhaven.cc/">https://wallhaven.cc</a><br><strong>WallpaperCave 是国外知名的壁纸社区，分享的壁纸质量很高。</strong><br><a href="https://wallpapercave.com/">https://wallpapercave.com</a><br><strong>unsplash</strong><br><a href="https://unsplash.com/t/wallpapers">https://unsplash.com/t/wallpapers</a><br><strong>piqsels</strong><br><a href="https://www.piqsels.com/zh">https://www.piqsels.com/zh</a><br><strong>wallroom 质量较高，壁纸分辨率从 1920 到 8k 不等。</strong><br><a href="https://wallroom.io/">https://wallroom.io</a><br><strong>bing每日壁纸</strong><br><a href="https://www.bingimg.cn/list1">https://www.bingimg.cn/list1</a><br><strong>干净简洁的下载必应壁纸每日一图</strong><br><a href="https://bing.xinac.net/">https://bing.xinac.net</a><br><strong>微软官方出品的必应壁纸客户端</strong><br><a href="https://www.microsoft.com/zh-cn/bing/bing-wallpaper">https://www.microsoft.com/zh-cn/bing/bing-wallpaper</a></p><hr><h1 id="♻️-家谱相关网站"><a href="#♻️-家谱相关网站" class="headerlink" title="♻️ 家谱相关网站"></a><a href="#♻️-家谱相关网站" title="♻️ 家谱相关网站"></a>♻️ 家谱相关网站</h1><ol><li>中国家谱族谱库<br><a href="http://gd.ccnu.edu.cn/">http://gd.ccnu.edu.cn/</a></li><li>中国家谱知识服务平台<br><a href="https://jiapu.library.sh.cn/#/">https://jiapu.library.sh.cn/#/</a></li><li>上海图书馆藏家谱全文选览<br><a href="http://wrd2016.library.sh.cn/channel/stjp/">http://wrd2016.library.sh.cn/channel/stjp/</a></li><li>在線族譜及家庭樹資源 • FamilySearch<br><a href="https://www.familysearch.org/zh/">https://www.familysearch.org/zh/</a><br>5.家庭树在线制作<br><a href="https://creately.com/zh/lp/family-tree-creator/">https://creately.com/zh/lp/family-tree-creator/</a></li><li>家谱编辑软件 - My Family Tree<br><a href="https://chronoplexsoftware.com/products/index.htm">https://chronoplexsoftware.com/products/index.htm</a></li></ol><hr><h1 id="💠-接口API服务商"><a href="#💠-接口API服务商" class="headerlink" title="💠 接口API服务商"></a><a href="#💠-接口API服务商" title="💠 接口API服务商"></a><strong>💠 接口API服务商</strong></h1><p>京东云：<a href="https://wx.jdcloud.com/api">https://wx.jdcloud.com/api</a><br>APISpace：<a href="https://www.apispace.com/">https://www.apispace.com/</a><br>百度：<a href="https://apis.baidu.com/">https://apis.baidu.com/</a><br>微博：<a href="https://open.weibo.com/wiki/API">https://open.weibo.com/wiki/API</a><br>百度AI：<a href="http://ai.baidu.com/">http://ai.baidu.com/</a><br>聚合：<a href="https://www.juhe.cn/">https://www.juhe.cn/</a><br>旷视人脸：<a href="https://www.faceplusplus.com.cn/">https://www.faceplusplus.com.cn/</a><br>融云：<a href="https://www.rongcloud.cn/">https://www.rongcloud.cn/</a><br>讯飞：<a href="https://www.xfyun.cn/">https://www.xfyun.cn/</a><br>高德：<a href="https://lbs.amap.com/">https://lbs.amap.com/</a></p><hr><h1 id="📝-论文、语法、写作、英语等纠错检查工具"><a href="#📝-论文、语法、写作、英语等纠错检查工具" class="headerlink" title="📝 论文、语法、写作、英语等纠错检查工具"></a><a href="#📝-论文、语法、写作、英语等纠错检查工具" title="📝 论文、语法、写作、英语等纠错检查工具"></a>📝 论文、语法、写作、英语等纠错检查工具</h1><ol><li><p>秘塔写作猫<br>写作猫是新一代AI写作伴侣，帮你推敲用语、斟酌文法、改写文风，还能实时同步翻译。<br><a href="https://xiezuocat.com/">https://xiezuocat.com/</a></p></li><li><p>爱校对官网<br>-查错别字 文本校对 文档纠错 智能校对工具平台<br><a href="https://www.ijiaodui.com/home">https://www.ijiaodui.com/home</a></p></li><li><p>Grammarly<br>在线语法校对工具，能够对语法，标点和拼写错误的地方进行检测，同时也会给出修改意见，支持Windows、Mac、iOS和Android，还可以帮助查重<br><a href="https://www.grammarly.com/">https://www.grammarly.com/</a></p></li><li><p>languagetool<br>一款用于对语法与拼写进行检查的工具，免费的在线检测软件，提供中文界面，具有英文校对功能，支持多种语言，能够给出错误原因，提供修改方法，直接复制段落，即可检测。<br><a href="https://languagetool.org/">https://languagetool.org/</a></p></li><li><p>QuillBot<br>SCI论文改写神器<br><a href="https://quillbot.com/">https://quillbot.com/</a></p></li><li><p>Textranch<br>比较两个单词、短语或者句子哪一个更常用，<br><a href="https://textranch.com/sentence-checker/">https://textranch.com/sentence-checker/</a></p></li><li><p>Giner<br>检查语法、句子改写、翻译、字典、朗读<br><a href="https://www.gingersoftware.com/">https://www.gingersoftware.com/</a></p></li><li><p>1Checker<br>能够即时检测并修改拼写、语法和样式错误，以不同颜色的Highlight出错误并修改意见，让文章句式更加准确。<br><a href="http://www.1checker.com/">http://www.1checker.com/</a></p></li><li><p>Scribbr<br>可以纠正语法，有非常高的准确度，能准确检查出论文中存在的任何涉嫌抄袭和剽窃内容，还支持20种语言，最大的特点在于可以纠正措辞不当，优化模糊用词表达，检查句子中多余的单词， 不过修改有局限性，只能作为参考。<br><a href="https://www.scribbr.com/">https://www.scribbr.com/</a></p></li><li><p>Wordtune<br>通过内容上下文和语法语境对内容进行修改，不仅有常规的语法检查，、还有五大功能满足学生需求。<br><a href="https://www.wordtune.com/">https://www.wordtune.com/</a></p></li><li><p>StyleWriter<br>一款英文润色软件，具有校对功能，指出语法、拼写、标点、大写字母等错误，将需要润色的地方用颜色标注出来，自动给出修改意见。<br><a href="http://www.stylewriter-usa.com/">http://www.stylewriter-usa.com</a></p></li><li><p>Reverso<br>包括英语，法语，意大利语，德语等多种语言，能够提供拼写检查，查找同义词等的功能<br><a href="https://www.reverso.net/spell-check">https://www.reverso.net/spell-check</a></p></li><li><p>Wordvice AI Proofreader<br>一款英文自动校对工具，可为您自动检测文本各类语言使用错误，完成准确高效的校对。<br><a href="https://wordvice.ai/cn">https://wordvice.ai/cn</a></p></li><li><p>writeful<br>能够自动从google的图书、学术、网页上搜集一个词组的搭配，并给出了每种搭配的百分比，还会配上例句， 很直观，很方便。现在也推出了word插件，类似grammarly的风格，兼具语法提示和修改功能<br><a href="https://www.writefull.com/">https://www.writefull.com/</a></p></li><li><p>Netspeak<br>用来查找你记不太清楚的词汇，比如congratulations，你不记得全部拼写了，你就可以在这个网站上来查一下。<br><a href="https://netspeak.org/">https://netspeak.org/</a></p></li><li><p>Linggle<br>提供英文常用语、搭配、近义词等检索，可以根据词性来推测完整搭配，还能帮助学习者分析出更准确的英文写作建议。<br><a href="http://www.linggle.com/">http://www.linggle.com/</a></p></li><li><p>近邻词汇检索<br>可免费查找近似短语和相关术语，词穷的时候可以看看。<br><a href="https://tool.mingdawoo.com/">https://tool.mingdawoo.com/</a></p></li><li><p>Microsoft office<br>Word 有內建 Microsoft Editor拼写和语法纠错，365 訂戶可以解鎖使用</p></li></ol><h1 id="🧾-Markdown-编辑器"><a href="#🧾-Markdown-编辑器" class="headerlink" title="🧾 Markdown 编辑器"></a><a href="#🧾-Markdown-编辑器" title="🧾 Markdown 编辑器"></a>🧾 Markdown 编辑器</h1><ol><li><p>Typora[付费]<br>一款轻便简洁的Markdown编辑器，支持即时渲染技术<br>网站：<a href="https://typoraio.cn/">https://typoraio.cn/</a><br>学习版：<a href="https://wwc.lanzoul.com/i7bBz09yhk8j">https://wwc.lanzoul.com/i7bBz09yhk8j</a></p></li><li><p>Arya - 在线 Markdown 编辑器<br>一款基于 <code>Vue</code>、<code>Vditor</code>，为未来而构建的在线 Markdown 编辑器；<br>轻量且强大：内置粘贴 HTML 自动转换为 Markdown，支持流程图、甘特图、时序图、任务列表，<br>可导出携带样式的图片、PDF、微信公众号特制的 HTML 等等<br>网站：<a href="https://markdown.lovejade.cn/">https://markdown.lovejade.cn/</a><br>项目：<a href="https://github.com/nicejade/markdown-online-editor">https://github.com/nicejade/markdown-online-editor</a></p></li><li><p>react-markdown-editor-lite<br>一款轻量的基于React的markdown编辑器<br>网站：<a href="https://harrychen0506.github.io/react-markdown-editor-lite/">https://harrychen0506.github.io/react-markdown-editor-lite/</a><br>项目：<a href="https://github.com/HarryChen0506/react-markdown-editor-lite">https://github.com/HarryChen0506/react-markdown-editor-lite</a></p></li><li><p>墨滴软件-mdnice[付费]<br>跨平台Markdown排版、编辑软件<br>网站：<a href="https://product.mdnice.com/">https://product.mdnice.com/</a></p></li><li><p>妙言-Mac<br>轻灵的 Markdown 笔记本伴你写出妙言~只有Mac版<br>网站：<a href="https://miaoyan.app/">https://miaoyan.app/</a><br>项目：<a href="https://github.com/tw93/MiaoYan">https://github.com/tw93/MiaoYan</a></p></li><li><p>Editor<br>开源在线 Markdown 编辑器<br>网站：<a href="https://pandao.github.io/editor.md/">https://pandao.github.io/editor.md/</a><br>网站：<a href="http://editor.md.ipandao.com/">http://editor.md.ipandao.com/</a><br>项目：<a href="https://github.com/pandao/editor.md">https://github.com/pandao/editor.md</a></p></li><li><p>Obsidian<br>一款本地 Markdown 编辑工具<br>网站：<a href="https://obsidian.md/">https://obsidian.md/</a><br>中文论坛：<a href="https://forum-zh.obsidian.md/">https://forum-zh.obsidian.md/</a></p></li><li><p>思源笔记[付费]<br>一款个人知识管理系统，融合 Markdown、双向链接、大纲和块级引用功能。<br>支持 Win / Mac / iOS / 安卓等平台，<br>本地优先可离线使用，并提供设备间端到端加密同步<br>网站：<a href="https://b3log.org/siyuan/">https://b3log.org/siyuan/</a><br>项目：<a href="https://github.com/siyuan-note/siyuan">https://github.com/siyuan-note/siyuan</a></p></li><li><p>Doocs<br>一款在线高度简洁的微信 Markdown 编辑器<br>支持 Markdown 语法、色盘取色、多图上传、一键下载文档、自定义 CSS 样式、一键重置等特性<br>网站：<a href="https://doocs.github.io/md/">https://doocs.github.io/md/</a><br>项目：<a href="https://github.com/doocs/md">https://github.com/doocs/md</a></p></li><li><p>WeChat Format<br>微信公众号排版编辑器，转换 Markdown 到微信特制的 HTML<br>网站：<a href="https://lab.lyric.im/wxformat/">https://lab.lyric.im/wxformat/</a><br>项目：<a href="https://github.com/lyricat/wechat-format">https://github.com/lyricat/wechat-format</a></p></li><li><p>MWeb Pro for Mac, iPad and iPhone[付费]<br>专业的 Markdown 写作、记笔记、静态博客生成软件<br>网站：<a href="https://zh.mweb.im/">https://zh.mweb.im/</a></p></li><li><p>MarkText<br>开源免费，支持windows、苹果、linux系统平台，支持实时预览、数学表达式、代码高亮,可输出 HTML 和 PDF 文件,也可以直接从剪贴板粘贴图像<br>网站：<a href="https://marktext.app/">https://marktext.app/</a> [目前打不开，去GitHub下载]<br>项目：<a href="https://github.com/marktext/marktext">https://github.com/marktext/marktext</a></p></li><li><p>Markdoc<br>Markdown 前端开发库<br>网站：<a href="https://markdoc.dev/">https://markdoc.dev/</a><br>项目：<a href="https://github.com/markdoc/markdoc">https://github.com/markdoc/markdoc</a></p></li><li><p>LetsMarkdown<br>一个轻量级的网页版 Markdown 编辑器，支持实时协作编辑、语法高亮、自动补全、主题设置等功能<br>网站：<a href="https://letsmarkdown.com/">https://letsmarkdown.com/</a><br>项目：<a href="https://github.com/Cveinnt/LetsMarkdown.com">https://github.com/Cveinnt/LetsMarkdown.com</a></p></li><li><p>QOwnNotes<br>开源记事本，具有针对GNU/Linux，macOS和Windows的markdown支持和待办事项列表管理器，可与Nextcloud Notes和ownCloud Notes一起使用<br>网站：<a href="https://www.qownnotes.org/">https://www.qownnotes.org/</a><br>项目：<a href="https://github.com/pbek/QOwnNotes">https://github.com/pbek/QOwnNotes</a></p></li><li><p>MDX Editor<br>微信排版编辑器，使用MDX，可自定义组件、样式、生成二维码、代码 diff 高亮，可导出 markdown 和 PDF<br>网站：<a href="https://editor.runjs.cool/">https://editor.runjs.cool/</a><br>项目：<a href="https://github.com/maqi1520/mdx-editor">https://github.com/maqi1520/mdx-editor</a></p></li><li><p>effie<br>支持Markdown的极简写作应用，支持Windows和MacOS。<br>网站：<a href="https://www.effie.co/">https://www.effie.co/</a></p></li><li><p>md-editor-v3<br>vue3 环境的 Markdown 编辑器，支持暗黑模式<br>网站：<a href="https://imzbf.github.io/md-editor-v3/index">https://imzbf.github.io/md-editor-v3/index</a><br>项目：<a href="https://github.com/imzbf/md-editor-v3">https://github.com/imzbf/md-editor-v3</a></p></li><li><p>MarkPad<br>一个Metro风格的轻量级开源Markdown编辑器<br>项目：<a href="https://github.com/Code52/DownmarkerWPF">https://github.com/Code52/DownmarkerWPF</a><br>网站：<a href="http://code52.org/DownmarkerWPF/">http://code52.org/DownmarkerWPF/</a></p></li><li><p>可能吧 Markdown to 公众号一键转换器<br>网站：<a href="https://knb.im/mp/">https://knb.im/mp/</a></p></li><li><p>Md2ALL<br>Markdown排版利器<br>网站：<a href="http://md.aclickall.com/">http://md.aclickall.com/</a></p></li><li><p>mdfmt<br>一款 Markdown 格式化工具，和 gofmt 比较类似，不过格式化的对象是 Markdown 文本<br>项目：<a href="https://github.com/elliotxx/mdfmt">https://github.com/elliotxx/mdfmt</a></p></li><li><p>Zettlr<br>一款非常适合撰写专业文本的 MarkDown 编辑器，无论是大学生、科研人员、记者还是作家，Zettlr 特有的文献引用、聚焦模式、热图搜索、代码高亮、组织结构几大特色都可以让 MarkDown 从编辑器变身生产力工具<br>网站：<a href="https://www.zettlr.com/">https://www.zettlr.com/</a><br>项目：<a href="https://github.com/Zettlr/Zettlr">https://github.com/Zettlr/Zettlr</a></p></li><li><p>Notable<br>开源免费的跨平台Markdown编辑器，适用于MacOS，Windows，Linux。还可以快速的将自己的笔记通过链接的方式分享出去<br>网站：<a href="https://notable.app/#">https://notable.app/#</a><br>项目：<a href="https://github.com/notable/notable">https://github.com/notable/notable</a></p></li><li><p>Milkdown<br>插件驱动的所见即所得的Markdown编辑器框架<br>网站：<a href="https://milkdown.dev/">https://milkdown.dev/</a><br>项目：<a href="https://github.com/Saul-Mirone/milkdown">https://github.com/Saul-Mirone/milkdown</a></p></li><li><p>HedgeDoc<br>网站：<a href="https://hedgedoc.org/">https://hedgedoc.org/</a><br>项目：<a href="https://github.com/hedgedoc/hedgedoc">https://github.com/hedgedoc/hedgedoc</a></p></li><li><p>ShowDoc[付费]<br>一个非常适合IT团队的在线API文档、技术文档工具<br>网站：<a href="https://www.showdoc.com.cn/">https://www.showdoc.com.cn/</a><br>项目：<a href="https://github.com/star7th/showdoc">https://github.com/star7th/showdoc</a></p></li><li><p>Pine<br>一个用 Swift 编写的，轻量、现代的 macOS 上的 markdown 编辑器<br>网站：<a href="https://lukakerr.github.io/Pine/">https://lukakerr.github.io/Pine/</a><br>项目：<a href="https://github.com/lukakerr/Pine">https://github.com/lukakerr/Pine</a></p></li><li><p>VNote<br>一款跨平台的开源 Markdown 笔记软件<br>网站：<a href="https://vnotex.github.io/vnote/zh_cn/">https://vnotex.github.io/vnote/zh_cn/</a><br>项目：<a href="https://github.com/vnotex/vnote">https://github.com/vnotex/vnote</a></p></li></ol><hr><h1 id="🐱‍🐉-免费查重网站包括"><a href="#🐱‍🐉-免费查重网站包括" class="headerlink" title="🐱‍🐉 免费查重网站包括"></a><a href="#🐱‍🐉-免费查重网站包括" title="🐱‍🐉 免费查重网站包括"></a><strong>🐱‍🐉 免费查重网站包括</strong></h1><ol><li>万方免费查重（应届生免费一次）：<br><a href="chsi.wanfangtech.net">chsi.wanfangtech.net</a></li><li>PaperDay（标准版永久免费，旗舰版每日限免）：<br><a href="http://www.paperday.cn/">www.paperday.cn</a></li><li>论文狗（每日免费一次）：<br><a href="http://www.lunwengo.net/">www.lunwengo.net</a></li><li>PaperYY（每日免费一次，11点多免费两次）：<br><a href="http://www.paperyy.com/">www.paperyy.com</a></li><li>FreeCheck（每日免费一次）：<br><a href="http://www.freecheck.cn/">www.freecheck.cn</a></li><li>WritePass（每日1000个免费名额）：<br><a href="http://www.writepass.cn/">www.writepass.cn</a></li><li>超星大雅（免费看相似度）：<br><a href="dsa.dayainfo.com">dsa.dayainfo.com</a></li><li>百度学术（免费使用PaperTime一次）：<br><a href="xueshu.baidu.com/usercenter/papercheck">xueshu.baidu.com/usercenter/papercheck</a></li><li>秘塔写作猫：写作改错和词语替换（需要注册）<br><a href="https://xiezuocat.com/#/">https://xiezuocat.com/#/</a></li><li>火龙果写作：<br><a href="http://www.mypitaya.com/">www.mypitaya.com</a></li></ol><hr><h1 id="🏞-在线智能抠图网站"><a href="#🏞-在线智能抠图网站" class="headerlink" title="🏞 在线智能抠图网站"></a><a href="#🏞-在线智能抠图网站" title="🏞 在线智能抠图网站"></a>🏞 在线智能抠图网站</h1><ol start="0"><li><a href="https://www.remove.bg/zh">https://www.remove.bg/zh</a></li><li><a href="https://www.magiceraser.io/">https://www.magiceraser.io/</a></li><li><a href="https://bgsub.cn/">https://bgsub.cn/</a></li><li><a href="https://jpgrm.com/">https://jpgrm.com/</a></li><li><a href="https://photoscissors.com/">https://photoscissors.com/</a></li><li><a href="https://www.picup.shop/">https://www.picup.shop/</a></li><li><a href="https://clippingmagic.com/">https://clippingmagic.com/</a></li><li><a href="https://photokit.com/?lang=zh#cutout">https://photokit.com/?lang=zh#cutout</a></li><li><a href="https://www.sukoutu.com/">https://www.sukoutu.com/</a></li><li><a href="http://matting.deeplor.com/#/">http://matting.deeplor.com/#/</a></li><li><a href="https://www.apowersoft.cn/remove-background-online">https://www.apowersoft.cn/remove-background-online</a></li><li><a href="https://picwish.cn/">https://picwish.cn/</a></li><li><a href="https://www.cutout.pro/zh-CN">https://www.cutout.pro/zh-CN</a></li><li><a href="https://www.gaoding.com/koutu">https://www.gaoding.com/koutu</a></li><li><a href="https://express.adobe.com/zh-Hans-CN/tools/remove-background">https://express.adobe.com/zh-Hans-CN/tools/remove-background</a></li></ol><hr><h1 id="🥡-在线学习、解题、搜题、答题网站及电报下载"><a href="#🥡-在线学习、解题、搜题、答题网站及电报下载" class="headerlink" title="🥡 在线学习、解题、搜题、答题网站及电报下载"></a><a href="#🥡-在线学习、解题、搜题、答题网站及电报下载" title="🥡 在线学习、解题、搜题、答题网站及电报下载"></a>🥡 在线学习、解题、搜题、答题网站及电报下载</h1><ol><li><p>slideshare<br>世界最大演示文稿PPT分享平台<br>网站：<a href="https://www.slideshare.net/">https://www.slideshare.net/</a><br>电报下载：<a href="https://t.me/slidesharebynx">https://t.me/slidesharebynx</a></p></li><li><p>Scribd<br>全球最大的文档分享平台<br>网站：<a href="https://es.scribd.com/">https://es.scribd.com/</a><br>电报下载：<a href="https://t.me/Scribdbynx">https://t.me/Scribdbynx</a></p></li><li><p>Studocu<br>可以跟踪你所在大学的所有课程，看到你同学上传的课程总结、学姐上传的试卷以及同学的练习题等，不用费尽心思总结大量复习材料——能立即使用的即立即使用，自己拥有的也可以分享给别人<br>网站：<a href="http://studocu.com/">http://studocu.com/</a><br>电报下载：<a href="https://t.me/studocubynx">https://t.me/studocubynx</a></p></li><li><p>Academia<br>一个学术性社交网站，专门供科研人员使用，这些人员可以在网站上相互间免费分享和查看各自最新的科研论文，将研究成果惠及更多的人<br>网站：<a href="https://www.academia.edu/">https://www.academia.edu/</a><br>电报下载1：<a href="https://t.me/Academicbynx">https://t.me/Academicbynx</a></p></li><li><p>Bartleby<br>美国一个以收藏经典参考书、诗歌、小说为主的网站，提供大量免费的电子图书。<br>网站：<a href="https://www.bartleby.com/">https://www.bartleby.com/</a><br>电报下载：<a href="https://t.me/BartlebyByNX">https://t.me/BartlebyByNX</a></p></li><li><p>Coursehero<br>一个在线学习的平台。为学生和教育工作者提供特定课程的资源,<br>辅助做题，家庭作业答案和帮手<br>网站：<a href="https://www.coursehero.com/">https://www.coursehero.com</a><br>电报下载:<a href="https://t.me/Courseherovipbot">https://t.me/Courseherovipbot</a></p></li><li><p>Numerade<br>来自美国各地大学的 1700 多名博士和助教组成的团队为您的科学、数学和经济学问题提供分步解决方案<br>网站：<a href="https://www.numerade.com/">https://www.numerade.com</a><br>电报下载：<a href="https://t.me/NumeradebyNX">https://t.me/NumeradebyNX</a></p></li><li><p>chegg<br>其中包含数百万个经过全面解释的循序渐进的教科书解决方案，适用于数学、商业、物理、工程、化学等学科。获得 80 门科目和数百门课程的家庭作业帮助。 Chegg 为您提供最艰难的课程和作业。<br>网站：<a href="https://www.chegg.com/">https://www.chegg.com/</a><br>电报下载：<a href="https://t.me/chegg_nx">https://t.me/chegg_nx</a><br>电报下载：<a href="https://t.me/nxexpro">https://t.me/nxexpro</a><br>电报下载：<a href="https://t.me/expertnxbot">https://t.me/expertnxbot</a></p></li><li><p>Issuu<br>有非常多的作品集案例，包括建筑的、室内的都有，实现在线PDF文档共享<br>网站：<a href="https://issuu.com/">https://issuu.com/</a><br>电报下载：<a href="https://t.me/nxexpro">https://t.me/nxexpro</a><br>网站下载：<a href="https://issuudownload.com/">https://issuudownload.com/</a><br>网站下载：<a href="https://vebuka.com/">https://vebuka.com/</a></p></li><li><p>Transtutor<br>是一個學生問老師答的網站，可以發問教科書裡的所有問題<br>网站：<a href="https://www.transtutors.com/">https://www.transtutors.com/</a><br>电报下载：<a href="https://t.me/transtutorbynx">https://t.me/transtutorbynx</a></p></li><li><p>Study.com<br>提供 4,500 多个各级在线课程——高中、大学、成人教育和专业执照<br>网站：<a href="https://study.com/">https://study.com</a><br>电报下载：<a href="https://t.me/studybynx">https://t.me/studybynx</a></p></li><li><p>Queseba<br>百万教科书解决方案<br>网站:<a href="https://www.quesba.com/">https://www.quesba.com/</a><br>电报下载：<a href="https://t.me/Quesbabynx">https://t.me/Quesbabynx</a></p></li><li><p>Gauthmath<br>解答大学数学题网站<br>网站：<a href="https://www.gauthmath.com/">https://www.gauthmath.com/</a><br>电报下载：<a href="https://t.me/GauthmathbyNX">https://t.me/GauthmathbyNX</a></p></li><li><p>wyzant<br>一个私人家教网站<br>网站：<a href="https://www.wyzant.com/">https://www.wyzant.com/</a><br>电报下载：<a href="https://t.me/wyzantbynx">https://t.me/wyzantbynx</a></p></li><li><p>Socratic<br>搜题网站<br>网站：<a href="https://socratic.org/">https://socratic.org/</a><br>电报下载：<a href="https://t.me/wyzantbynx">https://t.me/wyzantbynx</a></p></li><li><p>Brainly<br>搜题网站<br>网站：<a href="https://brainly.ph/">https://brainly.ph/</a><br>电报下载：<a href="https://t.me/Brainlybynx">https://t.me/Brainlybynx</a></p></li><li><p>Solutioninn<br>搜题网站<br>网站：<a href="https://www.solutioninn.com/">https://www.solutioninn.com/</a><br>电报下载：<a href="https://t.me/solutioninnbynx">https://t.me/solutioninnbynx</a></p></li><li><p>Wegglab<br>答题网站<br>网站：<a href="https://wegglab.com/">https://wegglab.com</a><br>电报下载：<a href="https://t.me/wegglabbyNX">https://t.me/wegglabbyNX</a></p></li><li><p>Studypool<br>在线课业答疑平台<br>根据需要从经过验证的导师那里获得家庭作业问题的 24/7 帮助。在我们的 Notebank 中访问 2000 万份作业答案、课堂笔记和学习指南<br>网站：<a href="https://www.studypool.com/">https://www.studypool.com/</a><br>电报下载：<a href="https://t.me/studypoolbynx">https://t.me/studypoolbynx</a></p></li><li><p>Quizlet<br>制作了简单的学习工具，可让您学习任何东西。立即开始使用抽认卡、游戏和学习工具进行学习 - 全部免费<br>网站：<a href="https://quizlet.com/">https://quizlet.com/</a><br>电报下载：<a href="https://t.me/QuizletbyNX">https://t.me/QuizletbyNX</a></p></li></ol><hr><h1 id="🈲-违禁词查询工具合集"><a href="#🈲-违禁词查询工具合集" class="headerlink" title="🈲 违禁词查询工具合集"></a><a href="#🈲-违禁词查询工具合集" title="🈲 违禁词查询工具合集"></a><strong>🈲 违禁词查询工具合集</strong></h1><p>1.禁用词查询(综合)<br>2022年新广告法,违禁词查询,敏感词查询,禁用词查询,广告禁用词,淘宝违禁词,抖音禁用词,淘宝极限词,抖音违禁词,敏感词汇,在线检测 | 禁用词查询<br><a href="https://www.jinyongci.com/">https://www.jinyongci.com/</a></p><p>2.零克查词(小红书)<br>专业的小红书、抖音、B站、小红书敏感词检测工具<br><a href="http://ci.lingke.pro/">http://ci.lingke.pro/</a></p><p>3.句无忧(通用)<br>2022年广告法禁用违规词、网络铭敏感词、淘宝禁用词、抖音违禁词、查询检测工具<br><a href="https://www.check51.com/">https://www.check51.com/</a></p><p>4.句易网(通用,新闻,美妆)<br>2022年最新广告法淘宝抖音违禁词敏感词在线查询检测工具<br><a href="http://www.ju1.cn/">http://www.ju1.cn/</a></p><p>5.IT工具网(综合工具)<br>违禁词在线检测_敏感词在线查询<br><a href="https://www.coder.work/textcensoring">https://www.coder.work/textcensoring</a></p><p>6.词爪(电商)<br>免费禁用词查询_违禁词查询_电商敏感词_新广告法禁用词查询工具<br><a href="https://www.cizhua.com/">https://www.cizhua.com/</a></p><p>7.轻抖(手机APP)<br>违禁词检测<br><a href="http://www.qingdou.vip/">http://www.qingdou.vip/</a></p><h1 id="🏞-预览图生成器"><a href="#🏞-预览图生成器" class="headerlink" title="🏞 预览图生成器"></a><a href="#🏞-预览图生成器" title="🏞 预览图生成器"></a>🏞 预览图生成器</h1><p>▎适合为博客文章生成适配 Twitter, Telegram 等媒介的预览图</p><ol><li><a href="https://pika.style/open-graph-generator">https://pika.style/open-graph-generator</a></li><li><a href="https://cards.microlink.io/editor">https://cards.microlink.io/editor</a></li><li><a href="https://poet.so/">https://poet.so/</a></li><li><a href="https://influencermarketinghub.com/instagram-ads-mockup/">https://influencermarketinghub.com/instagram-ads-mockup/</a></li><li><a href="https://influencermarketinghub.com/facebook-ads-mockup/">https://influencermarketinghub.com/facebook-ads-mockup/</a></li><li><a href="https://coverview.vercel.app/editor">https://coverview.vercel.app/editor</a></li></ol><h1 id="🌈-渐变图"><a href="#🌈-渐变图" class="headerlink" title="🌈 渐变图"></a><a href="#🌈-渐变图" title="🌈 渐变图"></a>🌈 渐变图</h1><ol><li><a href="http://color.oulu.me/">http://color.oulu.me/</a></li><li><a href="https://webkul.github.io/coolhue/">https://webkul.github.io/coolhue/</a></li><li><a href="https://uigradients.com/#GradeGrey">https://uigradients.com/#GradeGrey</a></li><li><a href="https://webgradients.com/">https://webgradients.com/</a></li><li><a href="https://gradient.shapefactory.co/">https://gradient.shapefactory.co/</a></li></ol><h1 id="🎬-全球10大盗版片源BT网站"><a href="#🎬-全球10大盗版片源BT网站" class="headerlink" title="🎬 全球10大盗版片源BT网站"></a><a href="#🎬-全球10大盗版片源BT网站" title="🎬 全球10大盗版片源BT网站"></a>🎬 全球10大盗版片源BT网站</h1><p>⭐09-18</p><ol><li><p>海盗湾：<a href="https://thepiratebay.org/">https://thepiratebay.org/</a></p></li><li><p>1337X：<a href="https://1337x.to/">https://1337x.to/</a></p></li><li><p>EZTV： <a href="https://eztv.re/">https://eztv.re/</a></p></li><li><p>YTS： <a href="https://yts.mx/">https://yts.mx/</a></p></li><li><p>RARBG: <a href="https://rarbg.to/">https://rarbg.to/</a>  </p></li><li><p>恶魔网：<a href="https://www.demonoid.is/">https://www.demonoid.is/</a></p></li><li><p>Nyaa: <a href="https://nyaa.si/">https://nyaa.si/</a></p></li><li><p>BT4G：<a href="https://bt4g.org/">https://bt4g.org/</a></p></li><li><p>magnetDL： <a href="https://www.magnetdl.com/">https://www.magnetdl.com/</a></p></li><li><p>Zooqle：<a href="https://zooqle.com/">https://zooqle.com/</a></p></li></ol><p>•ETTV： <a href="https://www.ettv.be/">https://www.ettv.be/</a><br>• GlotorRents:<a href="http://glodls.to/">http://glodls.to/</a><br>•Torlock:<a href="https://torlock2.com/">https://Torlock2.com</a><br>•ProxyBB：<a href="http://proxybb.com/">http://proxybb.com/</a><br>•Edvok: <a href="https://edvok.com/">https://edvok.com/</a><br>•动漫花园：<a href="https://www.dmhy.org/">https://www.dmhy.org/</a><br>• Pirateiro <a href="https://pirateiro.eu/">https://pirateiro.eu/</a></p><h1 id="🔔-文本语音AI"><a href="#🔔-文本语音AI" class="headerlink" title="🔔 文本语音AI"></a><a href="#🔔-文本语音AI" title="🔔 文本语音AI"></a>🔔 文本语音AI</h1><p>⭐09-18</p><p>◾️【腾讯】声咖-智能、快捷、高效的音视频创作平台<br><a href="https://shengka.ai.sogou.com/">https://shengka.ai.sogou.com/</a></p><p>◾️【搜狗】智影-在线智能视频创作平台<br><a href="https://zenvideo.qq.com/home">https://zenvideo.qq.com/home</a></p><p>◾️【讯飞】开放平台-以语音交互为核心的人工智能开放平台<br><a href="https://www.xfyun.cn/">https://www.xfyun.cn/</a></p><p>◾️【阿里云】语音合成TTS_智能客服_文字转语音_AI配音_机器朗读<br><a href="https://ai.aliyun.com/nls/tts">https://ai.aliyun.com/nls/tts</a></p><p>◾️ 【网易工作台】AI 智能语音识别自动生成字幕<br><a href="https://jianwai.youdao.com/">https://jianwai.youdao.com/</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> 资源合集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PDF </tag>
            
            <tag> 网站 </tag>
            
            <tag> 工具 </tag>
            
            <tag> 软件 </tag>
            
            <tag> 学习 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音乐软件</title>
      <link href="/posts/520507/"/>
      <url>/posts/520507/</url>
      
        <content type="html"><![CDATA[<p><strong>💡 文章转自<a href="https://lin64850.github.io/">Eureka</a>——各平台音乐下载、歌词工具、音乐标签、音频格式解锁等</strong></p><hr><h2 id="在线音乐"><a href="#在线音乐" class="headerlink" title="在线音乐"></a><a href="#在线音乐" title="在线音乐"></a>在线音乐</h2><p>在线音乐播放器，可以搜索网易云、QQ音乐、酷狗、虾米、百度里的音乐<br>可在线播放，甚至可以下载</p><blockquote><p><a href="https://www.yinyueke.net/">https://www.yinyueke.net/</a><br><a href="http://tools.liumingye.cn/music/">http://tools.liumingye.cn/music/</a><br><a href="https://tonzhon.com/">https://tonzhon.com/</a><br><a href="http://ayy.ayxhk.com/">http://ayy.ayxhk.com/</a><br><a href="https://peal.cc/player">https://peal.cc/player</a></p><p><a href="https://www.yinyueke.net/">https://www.yinyueke.net/</a><br><a href="https://www.9ku.com/laoge/">https://www.9ku.com/laoge/</a><br><a href="https://lvyueyang.github.io/web-music/">https://lvyueyang.github.io/web-music/</a></p></blockquote><hr><h2 id="音乐软件"><a href="#音乐软件" class="headerlink" title="音乐软件"></a><a href="#音乐软件" title="音乐软件"></a>音乐软件</h2><h3 id="NCMD"><a href="#NCMD" class="headerlink" title="NCMD"></a><a href="#NCMD" title="NCMD"></a>NCMD</h3><p>网易云音乐</p><p>Netease Cloud Music Downloader</p><p>一个高效网易云音乐™下载、管理器</p><p><strong>支持：网易云的歌单下载</strong></p><p><strong>平台：Windows</strong></p><p><a href="https://github.com/pluto0x0/ncmd" title="项目">项目</a></p><hr><h3 id="YesplayMusic"><a href="#YesplayMusic" class="headerlink" title="YesplayMusic"></a><a href="#YesplayMusic" title="YesplayMusic"></a>YesplayMusic</h3><p>网易云音乐</p><p>高颜值的第三方网易云播放器</p><p><strong>平台： Windows / macOS / Linux</strong></p><p><a href="https://github.com/qier222/YesPlayMusic" title="项目">项目</a></p><p><strong>📦️ 安装</strong></p><p>访问本项目的 <a href="https://github.com/qier222/YesPlayMusic/releases">Releases</a> 页面下载安装包</p><p>或</p><ul><li>macOS 用户也可以通过 <a href="https://www.oschina.net/p/homebrew?hmsr=aladdin1e1">Homebrew</a> 来安装：brew install –cask yesplaymusic</li><li>Windows 用户也可以通过 <a href="https://eureka.mba/posts/6c4c90ed.html">Scoop</a> 来安装：scoop install extras/yesplaymusic</li></ul><p><strong>✨ 特性</strong></p><ul><li><p>✅ 使用 Vue.js 全家桶开发</p></li><li><p>🔴 网易云账号登录（扫码/手机/邮箱登录）</p></li><li><p>📺 支持 MV 播放</p></li><li><p>📃 支持歌词显示</p></li><li><p>📻 支持私人 FM / 每日推荐歌曲</p></li><li><p>🚫🤝 无任何社交功能</p></li><li><p>🟢 支持部署到Vercel、 Docker、Replit、服务器等</p></li><li><p>🌎️ 海外用户可直接播放（需要登录网易云账号）</p></li><li><p>🔐 支持 <a href="https://github.com/UnblockNeteaseMusic/server#%E9%9F%B3%E6%BA%90%E6%B8%85%E5%8D%95">UnblockNeteaseMusic</a>，自动使用<a href="https://github.com/UnblockNeteaseMusic/server#%E9%9F%B3%E6%BA%90%E6%B8%85%E5%8D%95">各类音源</a>替换变灰歌曲链接 （网页版不支持）</p></li><li><ul><li>「各类音源」指默认启用的音源。</li></ul></li><li><p>YouTube 音源需自行安装 yt-dlp。</p></li><li><p>✔️ 每日自动签到（手机端和电脑端同时签到）</p></li><li><p>🌚 Light/Dark Mode 自动切换</p></li><li><p>👆 支持 Touch Bar</p></li><li><p>🖥️ 支持 PWA，可在 Chrome/Edge 里点击地址栏右边的 ➕ 安装到电脑</p></li><li><p>🟥 支持 Last.fm Scrobble</p></li><li><p>☁️ 支持音乐云盘</p></li><li><p>⌨️ 自定义快捷键和全局快捷键</p></li><li><p>🛠 更多特性开发中</p></li></ul><hr><h3 id="Listen-1-音乐播放器"><a href="#Listen-1-音乐播放器" class="headerlink" title="Listen 1 音乐播放器"></a><a href="#Listen-1-音乐播放器" title="Listen 1 音乐播放器"></a>Listen 1 音乐播放器</h3><p>网易云音乐 QQ音乐 酷狗音乐 Bilibili 咪咕音乐</p><p>Listen 1可以搜索和播放来自网易云音乐，QQ音乐，酷狗音乐，酷我音乐，Bilibili，咪咕音乐网站的歌曲，让你的曲库更全面</p><p><a href="http://listen1.github.io/listen1/" title="官网">官网</a> <a href="https://github.com/listen1" title="项目">项目</a><br><a href="https://github.com/listen1/listen1_chrome_extension" title="Chrome和Firefox插件版">Chrome和Firefox插件版</a> <a href="https://github.com/listen1/listen1_desktop" title="Windows，Mac，Linux桌面版">Windows，Mac，Linux桌面版</a> <a href="https://github.com/listen1/listen1_mobile" title="iOS、Android版">iOS、Android版</a></p><p><strong>平台：浏览器插件、安卓版、Windows、Linux、Mac</strong></p><hr><h3 id="方格音乐"><a href="#方格音乐" class="headerlink" title="方格音乐"></a><a href="#方格音乐" title="方格音乐"></a>方格音乐</h3><p>⭐<code>更新：2023-12-15</code></p><p>一款免费简洁的音乐播放器</p><p><strong>官网：</strong><a href="http://morin.vin/">http://morin.vin/</a></p><p><strong>平台： Windows / 安卓</strong></p><hr><h3 id="Vi-Music"><a href="#Vi-Music" class="headerlink" title="Vi Music"></a><a href="#Vi-Music" title="Vi Music"></a>Vi Music</h3><p>一个代替YouTube Music的轻量级应用</p><p><a href="https://github.com/vfsfitvnm/ViMusic" title="项目">项目</a> <a href="https://github.com/vfsfitvnm/ViMusic/releases" title="下载">下载</a><br>支持平台：安卓</p><p><strong>软件特点：</strong><br>•播放来自YouTube Music的任何歌曲或视频<br>•支持后台播放<br>•支持缓存音频块以供离线播放<br>•搜索歌曲、专辑、MV和播放列表<br>•书签艺术家和专辑<br>•支持导入播放列表<br>•获取、显示和编辑歌曲歌词或同步歌词<br>•本地播放列表管理<br>•重新排序播放列表或队列中的歌曲<br>•支持浅色/深色/动态主题<br>•跳过静音<br>•睡眠定时器<br>•音频标准化</p><hr><h3 id="InnerTune"><a href="#InnerTune" class="headerlink" title="InnerTune"></a><a href="#InnerTune" title="InnerTune"></a>InnerTune</h3><p>一个代替YouTube音乐的轻量级客户端</p><p><a href="https://github.com/z-huang/InnerTune" title="项目">项目</a> <a href="https://github.com/z-huang/InnerTune/releases" title="下载">下载</a><br>支持平台：安卓</p><p><strong>软件特点：</strong><br>•播放无广告歌曲<br>•浏览几乎所有 YouTube 音乐页面<br>•从 YouTube Music 搜索歌曲、专辑、视频和播放列表<br>•打开 YouTube 音乐链接<br>•在本地数据库中保存歌曲、专辑和<br>•播放列表<br>•下载音乐以供离线播放<br>•喜欢歌曲<br>•本地播放列表管理<br>•添加指向您喜爱的YouTube Music<br>•播放列表的链接<br>•通过 SAF 导出下载的歌曲<br>•材料设计播放器<br>•锁屏播放<br>•缓存歌曲<br>•（同步）歌词<br>•跳过沉默<br>•音频标准化<br>•支持统计<br>•持久队列<br>•自定义主题<br>•深色主题<br>•本土化<br>•支持代理<br>•备份和恢复</p><hr><h2 id="音乐格式解锁"><a href="#音乐格式解锁" class="headerlink" title="音乐格式解锁"></a><a href="#音乐格式解锁" title="音乐格式解锁"></a>音乐格式解锁</h2><ul><li><strong>支持把网易云音乐NCM 、QQ音乐QMC 等格式转换成无限制播放的MP3格式.</strong></li></ul><p>网易云音乐(ncm) QQ音乐(qmc,mflac,mgg) 酷狗音乐(kgm) 虾米音乐(xm) 酷我音乐(.kwm)</p><h3 id="网易云音乐解锁格式"><a href="#网易云音乐解锁格式" class="headerlink" title="网易云音乐解锁格式"></a><a href="#网易云音乐解锁格式" title="网易云音乐解锁格式"></a>网易云音乐解锁格式</h3><p><strong>1️⃣ 网易云音乐</strong></p><p>NCM格式转换为MP3格式</p><p>项目：<a href="https://github.com/kpali/ncmdumpGUI">https://github.com/kpali/ncmdumpGUI</a></p><p><strong>2️⃣ NCMconverter</strong></p><p>将ncm文件转换为mp3或者flac文件</p><p>实现了基本功能，提供目录解析，多线程下载</p><p>支持：Windows 和 Linux</p><p>项目: <a href="https://github.com/closetool/NCMconverter">https://github.com/closetool/NCMconverter</a></p><p>使用：通过命令行操作</p><p><strong>3️⃣ auto-ncmdump</strong></p><p>使用 ncmdump ，实现全自动网易云音乐ncm格式转mp3</p><p>支持：仅支持 Windows 10操作系统</p><p>项目：<a href="https://github.com/iKunpw/auto-ncmdump">https://github.com/iKunpw/auto-ncmdump</a></p><p><strong>4️⃣ NCMBot</strong></p><p>能够帮你把网易云音乐ncm格式转换为flac的Telegram Bot</p><p>电报：<a href="https://t.me/netease_ncm_bot">https://t.me/netease_ncm_bot</a></p><p><strong>5️⃣ 网易云ncm音乐格式转换为mp3音乐格式工具</strong></p><p>项目：<a href="https://github.com/charlotte-xiao/NCM2MP3">https://github.com/charlotte-xiao/NCM2MP3</a></p><p><strong>6️⃣ 音乐解锁</strong></p><p>移除已购音乐的加密保护。 目前支持网易云音乐(ncm)、QQ音乐(qmc, mflac, tkm, ogg) 。</p><p>项目：<a href="https://github.com/ZogeMung/DecrypeMusic">https://github.com/ZogeMung/DecrypeMusic</a></p><p>网址：<a href="http://jiesuo.zogemung.top/">http://jiesuo.zogemung.top/</a></p><h3 id="QQ音乐解锁格式"><a href="#QQ音乐解锁格式" class="headerlink" title="QQ音乐解锁格式"></a><a href="#QQ音乐解锁格式" title="QQ音乐解锁格式"></a>QQ音乐解锁格式</h3><p><strong>1️⃣ unlock-music</strong></p><p>界面：网页在线</p><p>Unlock encrypted music file in browser. 在浏览器中解锁加密的音乐文件。</p><p>支持：网易云音乐(ncm), QQ音乐(qmc, mflac, mgg), 酷狗音乐(kgm), 虾米音乐(xm), 酷我音乐(.kwm)</p><p>项目：<a href="https://demo.unlock-music.dev/">https://demo.unlock-music.dev/</a></p><p>网址：<a href="https://demo.unlock-music.dev/">https://demo.unlock-music.dev/</a></p><p><strong>2️⃣ 音乐解锁</strong></p><p>界面：网页在线</p><p>移除已购音乐的加密保护。 目前支持网易云音乐(ncm)、QQ音乐(qmc, mflac, tkm, ogg) 。</p><p>项目：<a href="https://github.com/ZogeMung/DecrypeMusic">https://github.com/ZogeMung/DecrypeMusic</a></p><p>网址：<a href="http://jiesuo.zogemung.top/">http://jiesuo.zogemung.top/</a></p><p><strong>3️⃣ qmc-decode</strong></p><p>界面:命令行模式</p><p>腾讯 QMC 文件的编解码工具</p><p>项目：<a href="https://github.com/jixunmoe/qmc-decode">https://github.com/jixunmoe/qmc-decode</a></p><p><strong>4️⃣ qmcflactomp3</strong></p><p>界面：WIN客户端图像界面</p><p>用于将QQ音乐的QMCFLAC格式转换为Mp3的桌面程序</p><p>项目：<a href="https://github.com/OnlyPiglet/qmcflactomp3">https://github.com/OnlyPiglet/qmcflactomp3</a></p><p><strong>5️⃣ QMC2</strong></p><p>界面：WIN、linux图像界面</p><p>(mflac/mflac0/mflac1/mgg/mgg0/mgg1) 格式文件解密。</p><p>网址：<a href="https://jixunmoe.github.io/qmc2/">https://jixunmoe.github.io/qmc2/</a></p><p><strong>6️⃣ qmcdump</strong></p><p>界面：网页在线</p><p>一个网页版的QQ音乐解码器（qmcflac/qmc0/qmc3 转 flac/mp3），仅为个人学习参考用</p><p><a href="http://mbear.top/qmc.html">http://mbear.top/qmc.html</a></p><p><strong>7️⃣ QMC Decode</strong></p><p>界面：带有跨平台的Java图形界面</p><p>解码QQ音乐下载文件（*.qmc0 *.qmc3 *.qmcogg *.qmcflac）</p><p>带有跨平台的Java图形界面</p><p><a href="https://github.com/hexian000/qmcdecode">https://github.com/hexian000/qmcdecode</a></p><p><strong>8️⃣ QMCDecode</strong></p><p>界面：仅支持macOS，图形界面</p><p>Q音乐QMC格式转换为普通格式(qmcflac转flac，qmc0,qmc3转mp3)，仅支持macOS，可自动识别到QQ音乐下载目录，默认转换结果存储到~/Music/QMCConvertOutput,可自定义需要转换的文件和输出路径</p><p><a href="https://github.com/gongjiehong/QMCDecode">https://github.com/gongjiehong/QMCDecode</a></p><p><strong>9️⃣ QMCTrans</strong></p><p>界面：WIN客户端图像界面</p><p>QQ音乐解码程序，QMC解密</p><p><a href="https://github.com/Ras0N/QMCTrans">https://github.com/Ras0N/QMCTrans</a></p><p><strong>🔟 qmc_file_decrypter</strong></p><p>界面：WIN客户端图像界面</p><p>QQ音乐VIP歌曲文件解密器</p><p><a href="https://github.com/REND42/qmc_file_decrypter">https://github.com/REND42/qmc_file_decrypter</a></p><p><strong>⏸ qmcToMp3Android</strong></p><p>界面：安卓端</p><p>QQ音乐加密文件解密转换mp3 安卓客户端</p><p><a href="https://github.com/deedywu/qmcToMp3Android">https://github.com/deedywu/qmcToMp3Android</a></p><h3 id="酷狗音乐解锁格式"><a href="#酷狗音乐解锁格式" class="headerlink" title="酷狗音乐解锁格式"></a><a href="#酷狗音乐解锁格式" title="酷狗音乐解锁格式"></a>酷狗音乐解锁格式</h3><p><strong>1️⃣ 音乐解锁:移除已购音乐的加密保护</strong><br>支持 网易云音乐(ncm), QQ音乐(qmc, mflac, mgg),<br>酷狗音乐(kgm), 虾米音乐(xm), 酷我音乐(.kwm)<br><a href="https://demo.unlock-music.dev/">https://demo.unlock-music.dev/</a><br><a href="https://github.com/unlock-music/unlock-music">https://github.com/unlock-music/unlock-music</a><br><a href="https://github.com/unlock-music/cli">https://github.com/unlock-music/cli</a></p><p><strong>2️⃣ KGM格式在线转换为MP3格式 KGM TO MP3</strong><br>已提供 酷狗音乐转MP3 酷我音乐转MP3 网易云音乐转MP3<br>虾米音乐转MP3 等功能，暂不提供QQ音乐转换<br><a href="https://kgm.worthsee.com/">https://kgm.worthsee.com/</a></p><p><strong>3️⃣ OpenYYY 开源云音乐 - 多种云音乐格式转MP3！</strong><br><a href="https://openyyy.com/">https://openyyy.com/</a></p><p><strong>4️⃣ 音乐解锁 - Microsoft Edge Addons</strong><br>使用Edge浏览器安装扩展程序，然后拖入kgm格式的文件即可转换为MP3<br><a href="https://microsoftedge.microsoft.com/addons/detail/%E9%9F%B3%E4%B9%90%E8%A7%A3%E9%94%81/ggafoipegcmodfhakdkalpdpcdkiljmd">https://microsoftedge.microsoft.com/addons/detail/%E9%9F%B3%E4%B9%90%E8%A7%A3%E9%94%81/ggafoipegcmodfhakdkalpdpcdkiljmd</a></p><hr><h2 id="歌词工具"><a href="#歌词工具" class="headerlink" title="歌词工具"></a><a href="#歌词工具" title="歌词工具"></a>歌词工具</h2><h3 id="lrc-maker歌词滚动姬"><a href="#lrc-maker歌词滚动姬" class="headerlink" title="lrc-maker歌词滚动姬"></a><a href="#lrc-maker歌词滚动姬" title="lrc-maker歌词滚动姬"></a>lrc-maker歌词滚动姬</h3><p>歌词滚动姬｜可能是你所能见到的最好用的歌词制作工具</p><p>项目：<a href="https://github.com/magic-akari/lrc-maker">https://github.com/magic-akari/lrc-maker</a></p><p>网址：<a href="https://lrc-maker.github.io/">https://lrc-maker.github.io/</a></p><p>网址：<a href="https://magic-akari.github.io/lrc-maker/">https://magic-akari.github.io/lrc-maker/</a></p><h3 id="163MusicLyrics"><a href="#163MusicLyrics" class="headerlink" title="163MusicLyrics"></a><a href="#163MusicLyrics" title="163MusicLyrics"></a>163MusicLyrics</h3><p>⭐<code>新增：2022-12-24</code></p><p>Windows云音乐歌词获取【网易云、QQ音乐】</p><p>项目：<a href="https://github.com/jitwxs/163MusicLyrics">https://github.com/jitwxs/163MusicLyrics</a><br>下载：<a href="https://github.com/jitwxs/163MusicLyrics/releases/tag/v5.5">https://github.com/jitwxs/163MusicLyrics/releases/tag/v5.5</a></p><p><a href="https://github.com/jitwxs/163MusicLyrics/wiki">👉163MusicLyrics Use Guide</a></p><ul><li>支持网易云音乐、QQ音乐两家音乐提供商</li><li>支持单曲、专辑、歌单三种查询类别，ID 和完整链接方式均可查询（即精确查询）</li><li>每种查询类别均支持关键字查询（即模糊查询）</li><li>支持批量查询 &amp;&amp; 扫盘查询</li><li>支持多种歌词原文和译文的组织方式</li><li>支持提取（部分）歌曲试听链接</li><li>支持多种保存命名规则、文件编码格式</li><li>支持 LRC 或 SRT 输出格式</li><li>日文歌曲支持罗马音</li><li>QQ 音乐支持逐字歌词模式(卡拉 OK 模式)</li></ul><hr><h2 id="音乐标签"><a href="#音乐标签" class="headerlink" title="音乐标签"></a><a href="#音乐标签" title="音乐标签"></a>音乐标签</h2><p>👉 可以将音乐标题、演唱者姓名、封面图、歌词、专辑名等信息添加至音乐文件中的软件</p><h3 id="音乐标签-1"><a href="#音乐标签-1" class="headerlink" title="音乐标签"></a><a href="#音乐标签-1" title="音乐标签"></a>音乐标签</h3><p>自动将音乐标题、演唱者、封面图、歌词、专辑名添加到音乐文件内</p><p>支持 QQ、网易云、iTunes 信息源</p><p>一款可以将音乐标题、演唱者姓名、封面图、歌词、专辑名等信息添加至音乐文件中的软件，支持 Windows、Android，信息源来自 QQ 音乐、网易云音乐、iTunes、酷我、Last.fm、VGMdb，可以批量为多个音乐文件添加ID3信息</p><p><strong>当前版本：</strong>1.0.9.0</p><p><strong>运行环境：</strong>.NET Framework 4.6.1</p><p><strong>操作系统：</strong>Windows Vista以上</p><p><a href="https://www.cnblogs.com/vinlxc/p/11347744.html" title="博客">博客</a> <a href="https://pan.baidu.com/s/18vN9wWGbbNC2foEy4MfJEA" title="百度云（提取码：x081）">百度云（提取码：x081）</a> <a href="https://wwc.lanzouy.com/ik0lo0ae7bcf" title="蓝奏云（解码密码：www.coolapk.com）">蓝奏云（解码密码：www.coolapk.com）</a></p><hr><h3 id="华丽的-MP3-伴侣"><a href="#华丽的-MP3-伴侣" class="headerlink" title="华丽的 MP3 伴侣"></a><a href="#华丽的-MP3-伴侣" title="华丽的 MP3 伴侣"></a>华丽的 MP3 伴侣</h3><p>自动批量添加『音乐』专辑封面和完整的专辑信息[Win]</p><p><a href="https://www.cnblogs.com/Gincenzo/p/3530181.html" title="博客">博客</a> <a href="http://pan.baidu.com/s/1bn05YKv" title="百度云">百度云</a></p><p>整理后的音乐,几乎每首歌曲都有了高清的专辑图</p><hr><h3 id="Quintessential-Media-Player"><a href="#Quintessential-Media-Player" class="headerlink" title="Quintessential Media Player"></a><a href="#Quintessential-Media-Player" title="Quintessential Media Player"></a>Quintessential Media Player</h3><p>自动扫描并填充 MP3 ID3 信息</p><p>利用 <strong>Gracenote</strong> 的插件，可以对 MP3 文件实现自动扫描并填充 MP3 ID3 信息</p><p><a href="https://www.appinn.com/quintessential-media-player/" title="介绍">介绍</a> <a href="https://u062.com/file/15690961-324685638" title="诚通网盘">诚通网盘</a></p><hr><h3 id="Mp3tag-豆瓣插件"><a href="#Mp3tag-豆瓣插件" class="headerlink" title="Mp3tag 豆瓣插件"></a><a href="#Mp3tag-豆瓣插件" title="Mp3tag 豆瓣插件"></a>Mp3tag 豆瓣插件</h3><p>自动将豆瓣音乐写入 MP3 音乐文件 ID3 信息，包括艺术家、专辑名、专辑封面等</p><p>一款专门修改 MP3 文件 ID3 信息的软件，自带一些信息源，可以批量修改 MP3 音乐文件的 ID3 信息</p><p><a href="https://github.com/yoyicue/mp3tag-douban-id3-plugins" title="项目">项目</a> <a href="https://www.appinn.com/douban-plugins-for-mp3tag/" title="介绍">介绍</a> <a href="https://github.com/yoyicue/mp3tag-douban-id3-plugins/releases/tag/v2.5.1" title="下载">下载</a></p><p><strong>安装方法</strong></p><p>找到 <code>%appdata%\mp3tag\data\sources</code> 位置，</p><p>下载 <a href="https://github.com/yoyicue/mp3tag-douban-id3-plugins/releases">release</a> 版本或者把最新的 <a href="https://raw.githubusercontent.com/yoyicue/mp3tag-douban-id3-plugins/main/DoubanMusic.src">DoubanMusic.src</a> 直接粘贴在这个目录下，重启 <strong>Mp3tag</strong> 即可</p><p><strong>使用方式</strong></p><ol><li>安装成功后，工具栏<code>标签数据源(S)</code> 下会有 <code>DoubanMusic</code> 选项</li><li>点击 <code>下一步(N)&gt;</code> 后会弹出一个查询条件的搜索框，写着<code>专辑集</code>，但这里是模糊查询，可以 <code>“歌手 专辑名”</code></li><li>在豆瓣音乐搜索成功后会让你选择一个结果，豆瓣返回结果的上限是100条，所以精准搜索很关键</li><li>相同的CD有不同的介质版本，比如CD，黑胶等等，还有不同的厂牌，热门CD可能还会有较多结果</li><li>可以按表头 <code>Rating</code>（豆瓣评分）作为一个参考，不放心可以点击 <code>预览</code>跳转到豆瓣页面看看</li><li>选好了点击 <code>下一步(N)&gt;</code> 会进入调整标签信息页面，检查完毕 <code>确认(O)</code> 即可</li></ol>]]></content>
      
      
      <categories>
          
          <category> 音乐软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
